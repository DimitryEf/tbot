package golang

import (
	"gorm.io/gorm"
	"tbot/internal/errors"
)

func initialize(db *gorm.DB) {
	err := db.Debug().AutoMigrate(&Topic{}, &Tag{})
	errors.PanicIfErr(err)

	create(db, "Get executable dir\n(tags: executable dir)\n---\n\nex, err := os.Executable()\ndir := filepath.Dir(ex)\nfmt.Println(\"dir:\", dir)\n")
	create(db, "Extract beginning of string (prefix)\n(tags: extract beginning string prefix)\n---\n\nt := string([]rune(s)[:5])")
	create(db, "Extract string suffix\n(tags: extract string suffix)\n---\n\nt := string([]rune(s)[len([]rune(s))-5:])")
	create(db, "Exec other program\n(tags: exec program)\n---\n\nerr := exec.Command(\"program\", \"arg1\", \"arg2\").Run()")
	create(db, "Telegram message markdown\n(tags: telegram message markdown)\n---\n\n*полужирный*\n_курсив_\n[ссылка](http://www.example.com/)\n`строчный моноширинный`\n```text\nблочный моноширинный (можно писать код)\n```\n\nimport \"github.com/go-telegram-bot-api/telegram-bot-api\"\n\nmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\nmsg.ParseMode = \"markdown\" //msg.ParseMode = tgbotapi.ModeMarkdown")
	create(db, "Telegram message html\n(tags: telegram message html)\n---\n\n<b>полужирный</b>, <strong>полужирный</strong>\n<i>курсив</i>\n<a href=\"http://www.example.com/\">ссылка</a>\n<code>строчный моноширинный</code>\n<pre>блочный моноширинный (можно писать код)</pre>\n\nimport \"github.com/go-telegram-bot-api/telegram-bot-api\"\n\nmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\nmsg.ParseMode = \"HTML\" //msg.ParseMode = tgbotapi.ModeHTML")
	create(db, "Iterate over map entries ordered by keys\n(tags: iterate map order key)\n---\n\nkeys := make([]string, 0, len(mymap))\nfor k := range mymap {\n    keys = append(keys, k)\n}\nsort.Strings(keys)\nfor _, k := range keys {\n    x := mymap[k]\n    fmt.Println(\"Key =\", k, \", Value =\", x)\n}\n")
	create(db, "Iterate over map entries ordered by values\n(tags: iterate map order value)\n---\n\ntype entry struct {\n    key   string\n    value int\n}\nentries := make([]entry, 0, len(mymap))\nfor k, x := range mymap {\n    entries = append(entries, entry{key: k, value: x})\n}\nsort.Slice(entries, func(i, j int) bool {\n    return entries[i].value < entries[j].value\n})\nfor _, e := range entries {\n    fmt.Println(\"Key =\", e.key, \", Value =\", e.value)\n}")
	create(db, "Slice to set\n(tags: slice set)\n---\n\ny := make(map[T]struct{}, len(x))\nfor _, v := range x {\n    y[v] = struct{}{}\n}")
	create(db, "Deduplicate slice\n(tags: deduplicate slice remove duplicate)\n---\n\nseen := make(map[T]bool)\nj := 0\nfor _, v := range x {\n    if !seen[v] {\n        x[j] = v\n        j++\n        seen[v] = true\n    }\n}\nfor i := j; i < len(x); i++ {\n    x[i] = nil\n}\nx = x[:j]")
	create(db, "Shuffle a slice\n(tags: slice shuffle)\n---\n\ny := make(map[T]struct{}, len(x))\nfor _, v := range x {\n    y[v] = struct{}{}\n}")
	create(db, "Sort slice asc\n(tags: sort slice asc)\n---\n\nsort.Slice(items, func(i, j int) bool {\n    return items[i].p < items[j].p\n})")
	create(db, "Sort slice desc\n(tags: sort slice desc)\n---\n\nsort.Slice(items, func(i, j int) bool {\n    return items[i].p > items[j].p\n})")
	create(db, "Remove item from slice by index\n(tags: remove item slice index)\n---\n\nitems = append(items[:i], items[i+1:]...)")
	create(db, "Graph with adjacency lists\n(tags: graph struct)\n---\n\ntype Vertex struct{\n    Id int\n    Label string\n    Neighbours map[*Vertex]bool\n}\ntype Graph []*Vertex")
	create(db, "Reverse a string\n(tags: string reverse)\n---\n\nrunes := []rune(s)\nfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n   runes[i], runes[j] = runes[j], runes[i]\n}\nt := string(runes)")
	create(db, "Insert item in slice\n(tags: insert item slice)\n---\n\ns = append(s, 0)\ncopy(s[i+1:], s[i:])\ns[i] = x")
	create(db, "Filter slice\n(tags: filter slice)\n---\n\ny := make([]T, 0, len(x))\nfor _, v := range x{\n    if p(v){\n        y = append(y, v)\n    }\n}")
	create(db, "File content to string\n(tags: file content string)\n---\n\nb, err := ioutil.ReadFile(f)\nlines := string(b)")
	create(db, "Write to std error\n(tags: write std error)\n---\n\nfmt.Fprintln(os.Stderr, x, \"is negative\")")
	create(db, "Big int\n(tags: big integer)\n---\n\nx := new(big.Int)\nx.Exp(big.NewInt(3), big.NewInt(247), nil)")
	create(db, "Round float to int\n(tags: round float int)\n---\n\ny := int(math.Floor(x + 0.5))")
	create(db, "Check if int addition will overflow\n(tags: check int add overflow)\n---\n\nfunc willAddOverflow(a, b int64) bool {\n    return a > math.MaxInt64 - b\n}")
	create(db, "Check if int multiplication will overflow\n(tags: check int multiply overflow)\n---\n\nfunc multiplyWillOverflow(x, y uint64) bool {\n   if x <= 1 || y <= 1 {\n     return false\n   }\n   d := x * y\n   return d/y != x\n}")
	create(db, "Load json file into struct\n(tags: load json file struct)\n---\n\nbuffer, err := ioutil.ReadFile(\"data.json\")\nerr = json.Unmarshal(buffer, &x)")
	create(db, "Load yaml file into struct\n(tags: load yaml file struct)\n---\n\nimport \"gopkg.in/yaml.v3\"\n\nbuffer, err := ioutil.ReadFile(\"data.yaml\")\nerr = yaml.Unmarshal(buffer, &x)")
	create(db, "Save struct into json file\n(tags: save struct json file)\n---\n\nbuffer, err := json.MarshalIndent(x, \"\", \"  \")\nerr = ioutil.WriteFile(\"data.json\", buffer, 0644)")
	create(db, "Print type of variable\n(tags: print type variable)\n---\n\nfmt.Printf(\"%T\", x) //fmt.Println(reflect.TypeOf(x))")
	create(db, "Load from HTTP GET request into a string\n(tags: load http get string)\n---\n\nres, err := http.Get(u)\nbuffer, err := ioutil.ReadAll(res.Body)\nres.Body.Close()\ns := string(buffer)")
	create(db, "Read int from stdin\n(tags: read int std in)\n---\n\n_, err := fmt.Scan(&n)")
	create(db, "UDP listen and read\n(tags: udp listen read)\n---\n\nServerAddr,err := net.ResolveUDPAddr(\"udp\",p)\nServerConn, err := net.ListenUDP(\"udp\", ServerAddr)\ndefer ServerConn.Close()\nn,addr,err := ServerConn.ReadFromUDP(b[:1024])\nif n<1024 {\n    return fmt.Errorf(\"Only %d bytes could be read.\", n)\n}")
	create(db, "Binary search in sorted slice\n(tags: binary search slice)\n---\n\nfunc binarySearch(a []T, x T) int {\n    imin, imax := 0, len(a)-1\n    for imin <= imax {\n        imid := (imin + imax) / 2\n        switch {\n        case a[imid] == x:\n        return imid\n        case a[imid] < x:\n        imin = imid + 1\n        default:\n        imax = imid - 1\n        }\n    }\n    return -1\n}")
	create(db, "Measure func call duration\n(tags: measure func call duration time)\n---\n\nt1 := time.Now()\nfoo()\nt := time.Since(t1)\nns := t.Nanoseconds()\nfmt.Printf(\"%dns\\n\", ns)")
	create(db, "Breadth-first traversing in a graph\n(tags: bfs traversing graph)\n---\n\nfunc (start *Vertex) Bfs(f func(*Vertex)) {\n    queue := []*Vertex{start}\n    seen := map[*Vertex]bool{start: true}\n    for len(queue) > 0 {\n        v := queue[0]\n        queue = queue[1:]\n        f(v)\n        for next, isEdge := range v.Neighbours {\n            if isEdge && !seen[next] {\n                queue = append(queue, next)\n                seen[next] = true\n            }\n        }\n    }\n}")
	create(db, "Depth-first traversing in a graph\n(tags: dfs traversing graph)\n---\n\nfunc (v *Vertex) Dfs(f func(*Vertex), seen map[*Vertex]bool) {\n    seen[v] = true\n    f(v)\n    for next, isEdge := range v.Neighbours {\n        if isEdge && !seen[next] {\n            next.Dfs(f, seen)\n        }\n    }\n}")
	create(db, "Check if string contains only digits\n(tags: check string contains only digits)\n---\n\nisNotDigit := func(c rune) bool { return c < '0' || c > '9' }\nb := strings.IndexFunc(s, isNotDigit) == -1")
	create(db, "Check if file exists\n(tags: check file exist)\n---\n\n_, err := os.Stat(fp)\nb := !os.IsNotExist(err)")
	create(db, "Read slice of int from stdin\n(tags: read slice int std in)\n---\n\nvar ints []int\ns := bufio.NewScanner(os.Stdin)\nfor s.Scan() {\n    i, err := strconv.Atoi(s.Text())\n    if err == nil {\n        ints = append(ints, i)\n    }\n}")
	create(db, "Detect if 32-bit or 64-bit architecture\n(tags: detect 32 64 architecture)\n---\n\nif strconv.IntSize==32 {\n    f32()\n}\nif strconv.IntSize==64 {\n    f64()\n}")
	create(db, "Parse flags\n(tags: parse flags args)\n---\n\nvar b = flag.Bool(\"b\", false, \"Do bat\")\nfunc main() {\n    flag.Parse()\n    if *b {\n        bar()\n    }\n}")
	create(db, "Open URL in default browser\n(tags: open url default browser)\n---\n\nfunc openbrowser(url string) {\n    var err error\n    switch runtime.GOOS {\n    case \"linux\":\n        err = exec.Command(\"xdg-open\", url).Start()\n    case \"windows\":\n        err = exec.Command(\"rundll32\", \"url.dll,FileProtocolHandler\", url).Start()\n    case \"darwin\":\n        err = exec.Command(\"open\", url).Start()\n    default:\n        err = fmt.Errorf(\"unsupported platform\")\n    }\n    if err != nil {\n        log.Fatal(err)\n    }\n}")
	create(db, "Concatenate two slices\n(tags: concat two slice)\n---\n\nab := append(a, b...)")
	create(db, "String length\n(tags: string length)\n---\n\nn := utf8.RuneCountInString(s)")
	create(db, "Make HTTP POST request\n(tags: make http post request)\n---\n\nresponse, err := http.Post(u, contentType, body)")
	create(db, "Bytes to hex string\n(tags: byte hex string)\n---\n\ns := hex.EncodeToString(a)")
	create(db, "Hex string to byte array\n(tags: byte hex string)\n---\n\na, err := hex.DecodeString(s)")
	create(db, "Find files with a given list of filename extensions\n(tags: file extension walk)\n---\n\nL := []string{}\nerr := filepath.Walk(D, func(path string, info os.FileInfo, err error) error {\n    if err != nil {\n        fmt.Printf(\"failure accessing a path %q: %v\\n\", path, err)\n        return err\n    }\n    for _, ext := range []string{\".jpg\", \".jpeg\", \".png\"} {\n        if strings.HasSuffix(path, ext) {\n            L = append(L, path)\n            break\n        }\n    }\n    return nil\n})\n")
	create(db, "Check if point is inside rectangle\n(tags: check point inside rect)\n---\n\np := image.Pt(x, y)\nr := image.Rect(x1, y1, x2, y2)\nb := p.In(r)")
	create(db, "List files in directory\n(tags: list file dir)\n---\n\nx, err := ioutil.ReadDir(d)")
	create(db, "Make HTTP PUT request\n(tags: make http put request)\n---\n\nreq, err := http.NewRequest(\"PUT\", u, body)\nreq.Header.Set(\"Content-Type\", contentType)\nreq.ContentLength = contentLength\nresponse, err := http.DefaultClient.Do(req)")
	create(db, "Execute function in 30 seconds\n(tags: exec func after time)\n---\n\ntimer := time.AfterFunc(\n    30*time.Second,\n    func() {\n        f(42)\n    })")
	create(db, "Matrix multiplication\n(tags: matrix multiply)\n---\n\nc := new(mat.Dense)\nc.Mul(a, b)")
	create(db, "Filter and transform slice\n(tags: filter transform slice)\n---\n\nvar y []Result\nfor _, e := range x {\n    if P(e) {\n        y = append(y, T(e))\n    }\n}")
	create(db, "Get an environment variable\n(tags: env var)\n---\n\nfoo, ok := os.LookupEnv(\"FOO\")\nif !ok {\n    foo = \"none\"\n}")
	create(db, "Create folder\n(tags: create folder dir)\n---\n\nerr := os.MkdirAll(path, os.ModeDir)")
	create(db, "Pad string on the right\n(tags: pad string right)\n---\n\nif n := utf8.RuneCountInString(s); n < m {\n    s += strings.Repeat(c, m-n)\n}")
	create(db, "Pad string on the left\n(tags: pad string left)\n---\n\nif n := utf8.RuneCountInString(s); n < m {\n    s = strings.Repeat(c, m-n) + s\n}")
	create(db, "Progress bar\n(tags: progress bar)\n---\n\nfunc printProgressBar(n int, total int) {\n    var bar []string\n    tantPerFourty := int((float64(n) / float64(total)) * 40)\n    tantPerCent := int((float64(n) / float64(total)) * 100)\n    for i := 0; i < tantPerFourty; i++ {\n        bar = append(bar, \"█\")\n    }\n    progressBar := strings.Join(bar, \"\")\n    fmt.Printf(\"\\r \" + progressBar + \" - \" + strconv.Itoa(tantPerCent) + \"\")\n}")
	create(db, "Create a zip archive\n(tags: create zip archive)\n---\n\nbuf := new(bytes.Buffer)\nw := zip.NewWriter(buf)\nfor _, filename := range list {\n    input, err := os.Open(filename)\n    output, err := w.Create(filename)\n    _, err = io.Copy(output, input)\n}\nerr := w.Close()\nerr = ioutil.WriteFile(name, buf.Bytes(), 0777)")
	create(db, "Slice intersection\n(tags: slice intersection)\n---\n\nseta := make(map[T]bool, len(a))\nfor _, x := range a {\n    seta[x] = true\n}\nsetb := make(map[T]bool, len(a))\nfor _, y := range b {\n    setb[y] = true\n}\n\nvar c []T\nfor x := range seta {\n    if setb[x] {\n        c = append(c, x)\n    }\n}")
	create(db, "Replace multiple spaces with single space\n(tags: replace space)\n---\n\nwhitespaces := regexp.MustCompile('\\s+')\nt := whitespaces.ReplaceAllString(s, \" \")")
	create(db, "Create a tuple value\n(tags: create tuple interface)\n---\n\nt := []interface{}{\n    2.5,\n    \"hello\",\n    make(chan int),\n}")
	create(db, "Remove all non-digits chars\n(tags: remove digit char)\n---\n\nre := regexp.MustCompile(\"[^\\\\d]\")\nt := re.ReplaceAllLiteralString(s, \"\")")
	create(db, "Add element to the beginning of the slice\n(tags: add beginning slice)\n---\n\nitems = append([]T{x}, items...)")
	create(db, "Copy slice\n(tags: copy slice)\n---\n\ny := make([]T, len(x))\ncopy(y, x)")
	create(db, "Copy file\n(tags: copy file)\n---\n\nfunc copy(dst, src string) error {\n    data, err := ioutil.ReadFile(src)\n    stat, err := os.Stat(src)\n    return ioutil.WriteFile(dst, data, stat.Mode())\n}")
	create(db, "Cancel an operation\n(tags: cancel operation func)\n---\n\nctx, cancel := context.WithCancel(context.Background())\ngo p(ctx)\nsomethingElse()\ncancel()")
	create(db, "Timeout\n(tags: timeout operation func)\n---\n\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\np(ctx)")
	create(db, "Check if bytes are a valid UTF-8 string\n(tags: check byte valid utf8)\n---\n\nb := utf8.Valid(s)")
	create(db, "Encode bytes to base64\n(tags: encode byte base64)\n---\n\ns := base64.StdEncoding.EncodeToString(data)")
	create(db, "Decode base64\n(tags: decode string base64)\n---\n\ndata, err := base64.StdEncoding.DecodeString(s)")
	create(db, "Set value on field of structure in map\n(tags: set value field struct map)\n---\n\ntemp := m[key]\ntemp.SomeField = 42\nm[key] = temp")
	create(db, "Deploy on Heroku\n(tags: heroku deploy)\n---\n\nCheck this:\n1. On site heroku/<myappname>/recources web toggle button turn on\n2. In code http.ListenAndServe(\":\" + os.Getenv(\"PORT\"), nil)\n3. In root app's dir you have \"Procfile\" with \"web: bin/myapp\"\n4. File go.mod have \"// +heroku goVersion go1.15\" above the line \"go 1.15\"")
	create(db, "HTTP file server\n(tags: http file server)\n---\n\nhttp.Handle(\"/\", http.FileServer(http.Dir(\".\")))\nhttp.ListenAndServe(\":80\", nil)\n// log.Fatal(http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\"/usr/share/doc\"))))")
	create(db, "Update major version of package in go.mod\n(tags: update major version package mod)\n---\n\n// go mod init myapp\n// go mod vendor\nadd version on import github.com/go-telegram-bot-api/telegram-bot-api/v5 \nor if you want to use the newest commit\ngo get github.com/go-telegram-bot-api/telegram-bot-api@b6df6c2\ngo mod tidy")
	create(db, "Using go mod vendor\n(tags: mod vendor)\n---\n\ngo mod init myapp\ngo mod vendor\ngo build -mod=vendor main.go")
	create(db, "Linux tcpdump\n(tags: linux tcpdump)\n---\n\n// output format\n[Timestamp] [Protocol] [Src IP].[Src Port] > [Dst IP].[Dst Port]: [Flags], [Seq], [Ack], [Win Size], [Options], [Data Length]\n// show available interfaces\ntcpdump -D\n// catch all packets\ntcpdump -i any\n// catch first 5 packets\ntcpdump -i any -c 5\n// do not resolve ip (-n) and ports (-nn)\ntcpdump -i any -c5 -nn\n// filter by icmp packets\ntcpdump -i any -c5 icmp\n// filter packets by a special host\ntcpdump -i any -c5 -nn host 54.204.39.132\n// filer packets by subnet\ntcpdump -n net 192.168.1\n// filter by port\ntcpdump -i any -c5 -nn port 80\n// filter by ports\ntcpdump -n portrange 11128-11142\n// filter by destination \ntcpdump -i any -c5 -nn dst 192.168.122.98\n// complexly\ntcpdump -i any -c5 -nn src 192.168.122.98 and port 80\ntcpdump -i any -c5 -nn \"port 80 and (src 192.168.122.98 or src 54.204.39.132)\"\n// print packet content in ascii (-A) or hex (-X)\ntcpdump -i any -c10 -nn -A port 80\n// save result in file\ntcpdump -i any -c10 -nn -w webserver.pcap port 80\n// read result from file (you may use wireshark)\ntcpdump -nn -r webserver.pcap\ntcpdump -nn -r webserver.pcap src 54.204.39.132")
	create(db, "Linux info\n(tags: linux info)\n---\n\nid      // info about your account\nw       // who there are in the system now\nlscpu   // info about processors\nlsof    // list of open files\nfree    // info about memory\ncat     // show content of the file\nless    // show file in fragments\nmore    // for big files\ntail -f // show end of file in interactive\ncmp     // compare files by bytes\ncomm    // show sort files string by string\ndiff    // show diff between files\ngrep    // find in text by regexp \nfind    // find files\nwc      // words count")
	create(db, "Linux bash hotkeys\n(tags: linux bash hotkeys)\n---\n\nalt+b  // move cursor to the start of word (back)\nalt+f  // move to the end of word (forward)\nctrl+a // move to the start\nctrl+e // move to the end\nctrl+]<char> // move right to first <char> entry\nctrl+alt+]<char> // move left to <char>\nctrl+w // remove word before the cursor\nalt+d  // remove word after\nctrl+u // remove all before cursor\nctrl+k // remove all after cursor\nctrl+y // return removed \n!! // repeat last command\n!$ // \"cat a.txt\" then \"less !$\" = \"less a.txt\"\n!* // \"head a.txt | grep '^Al'\" then \"tail !*\"\nalt+. // insert last arg from previous command\nalt+<N>+alt+. // insert <N> arg from previous command\n>a.txt // creat file or clean it\nctrl+l // clean terminal\nctrl+r // show history\nctrl+d // exit")
	create(db, "Linux std\n(tags: linux std in out err)\n---\n\n> send to stream\n< get from straem\n>> append to stream\n<< join stream\n// send stdout to out.txt, stderr to err.txt\n./myapp > out.txt 2> err.txt\n// send stdout and stderr in outerr.txt\n./myapp > outerr.txt 2>&1 ac -pd &> outerr.txt\n// skip stdout and stderr\n./myapp &> /dev/null\n// stdout as arg\ndiff <(ls dirA) <(ls dirB)\n// create files with names from list\nxargs touch < list.txt")
	create(db, "Linux find\n(tags: linux find)\n---\n\nfind /opt -name \"README*\" -exec wc -l {} +\n// criteria:\n-name,  -iname, -type (f, d, l), -inum <Н>, -not-name\n-user<uname>, -group<gname>,  -perm (ugo+/-rwx)\n-size +x[c], -empty, -newer <fname>\n-atime +x, -amin +x, -mmin -x, -mtime -x\n-and (-a), or (-o)\n-~ (hiden files), -perm (permissions)\n// actions:\n-print — default print\n-ls — exec ls -lids for every result file\n-exec cmd — exec command\n-ok cmd — exec command after user confirmation\n// examples:\nfind . -type f -iname \"*.txt\" — xt-files in curdir\nfind . -maxdepth 1 — equivalent ls\nfind ./somedir -type f -size +512M -print — all files large then 512M in ./somedir\nfind /usr/bin ! -type l — no symbol link in /usr/bin\nfind $HOME -type f -atime +365 -exec rm {} + — remove all files that have not been available for a year\nfind . \\( -name \"*.c\" -o -name \"*.h\" \\) — all files with .c or .h extention")
	create(db, "Linux grep\n(tags: linux grep)\n---\n\ngrep -i -n 'c.l' states.txt\n// print number of string whoes start with t\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | grep -n '^t'\n  2:two\n  3:three\n// options:\n-i: ignore case\n-n: print string number with strings\n-v: invert - print that not matched\n-c: print count of matched strings\n-A<n>: print <n> strings after\n-B<n>: print <n> strings before\n-o: print only matched, not whole string\n-E: allowed to use extention regexp\n-r: recurcive in dirs\n-w: find word\n-l: print with file names\n--color: colorise print")
	create(db, "Linux awk\n(tags: linux awk)\n---\n\n// $0 - all string, $1 - first word, $2 - second...\necho \"I'm Tom\" | awk '{$2=\"Bill\"; print $0}' \n  I'm Bill\nprintf \"12\\n32\\n54\\n6\" | awk '{if ($1>20) print $1}'\n  32\n  54 \n// use function  \nprintf \"first a\\nsecond b\\nthird c\" | awk '{print(toupper($1))}' >&1\n  FIRST\n  SECOND\n  THIRD\n// set other word delimeter\nprintf \"first:a\\nsecond:b\\nthird:c\" | awk 'BEGIN{FS=\":\"}{print(toupper($1))}' >&1\nprintf \"first:a\\nsecond:b\\nthird:c\" | awk -F: '{print(toupper($1))}' >&1\n  FIRST\n  SECOND\n  THIRD\n// print last field\nprintf \"a b c d e f\" | awk '{print(toupper($NF))}' >&1\n  f\n// set other string delimeter and use filter\nprintf \"1a 1b 2c 2d 3e 3f\" | awk 'BEGIN{RS=\" \"}{print(toupper($NF))}' | awk '/2/{print $0}'\n  2C\n  2D\n// use variables\necho -e 'one 1\\n two 2' | awk '{sum+=$2}END{print sum}'\n  3\n// sum of values in last column in file\n< requests.log awk '{totalBytes+=$NF}END{print totalBytes}'\n// substr function (printf(string), system(command), length(string))\nprintf \"1a 1b\" | awk 'BEGIN{RS=\" \"}{print(substr($1,2,1))}'\n  a\n  b")
	create(db, "Linux sed\n(tags: linux sed)\n---\n\n// print 2-4 strings from file, show only result (-n)\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | sed -n '2,4p'\n  two\n  three\n  four\n// print without 1-2 strings\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | sed '1,2d'\n  three\n  four\n  five\n// replace words\nprintf \"one\\ntwo\\nthree\" | sed 's/tw/TW/g'\n  one\n  TWo\n  three\n// replace chars\nprintf \"one\\ntwo\\nthree\" | sed 'y/t/T/'\n  one\n  Two\n  Three\n// append string\n  printf \"one\\ntwo\" | sed 'a-----'\n  one\n  -----\n  two\n  -----")
	create(db, "Compile for android\n(tags: compile android)\n---\n\nenv GOOS=android GOARCH=arm64 go build main.go")
	create(db, "Cli tool\n(tags: cli tool)\n---\n\nimport \"github.com/urfave/cli/v2\"\n\nfunc main() {\n  var language string\n  app := &cli.App{\n    Flags: []cli.Flag {\n      &cli.StringFlag{\n        Name:        \"lang\",\n\t\tAliases:     []string{\"l\"},\n        Value:       \"english\",\n        Usage:       \"language for the greeting\",\n        Destination: &language,\n      },\n    },\n    Action: func(c *cli.Context) error {\n      name := \"someone\"\n      if c.NArg() > 0 {\n        name = c.Args().Get(0)\n      }\n      if language == \"spanish\" {\n        fmt.Println(\"Hola\", name)\n      } else {\n        fmt.Println(\"Hello\", name)\n      }\n      return nil\n    },\n  }\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}")
	create(db, "Linux tree\n(tags: linux tree)\n---\n\n// print only dir with low than 26 files\ntree -d --filelimit 26\n// print hiden dir, sort by depth, show modify date\ntree -avD\n// print files that matched template, do not show dir that gave not needed files\ntree -P '*.pdf' --prune\n// write three with dir into a file\ntree -d -o tree_command_results.txt\n// print size, user, permissions, full path\ntree -hupf")
	create(db, "Build go app in docker from scratch\n(tags: docker build scratch)\n---\n\nFROM golang AS builder\nADD . /app\nWORKDIR /app\nRUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags \"-static\"' -o kit\n\nFROM scratch\nCOPY --from=builder /app/kit /app/kit\nEXPOSE 8080 8080\nENTRYPOINT [\"/app/kit\"]")
	create(db, "Use prometheus and grafana\n(tags: docker prometheus grafana compose)\n---\n\n// Dockerfile\nFROM golang AS builder\nADD . /app\nWORKDIR /app\nRUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags \"-static\"' -o kit\n\nFROM scratch\nCOPY --from=builder /app/kit /app/kit\nEXPOSE 8080 8080\nENTRYPOINT [\"/app/kit\"]\n\n// prometheus/prometheus.yml\nscrape_configs:\n  - job_name: my_group\n    scrape_interval: 10s\n    static_configs:\n      - targets:\n          - kit:8080\n\t\t  \n// docker-compose.yaml\nversion: \"3\"\n\nservices:\n  kit:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - 8080:8080\n\n  grafana:\n    image: grafana/grafana\n    container_name: grafana\n    ports:\n      - 3000:3000\n\n  prometheus:\n    image: prom/prometheus\n    container_name: prometheus\n#    restart: unless-stopped\n    ports:\n      - 9090:9090\n    volumes:\n      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml\n\n// docker-compose up")
	create(db, "Simple metrics for prometheus\n(tags: metrics prometheus)\n---\n\nimport (\n  \"github.com/prometheus/client_golang/prometheus\"\n  \"github.com/prometheus/client_golang/prometheus/promauto\"\n  \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc recordMetrics() {\n  go func() {\n    for {\n      opsProcessed.Inc()\n      time.Sleep(2 * time.Second)\n    }\n  }()\n}\n\nvar opsProcessed = promauto.NewCounter(prometheus.CounterOpts{\n    Name: \"myapp_processed_ops_total\",\n    Help: \"The total number of processed events\",\n  })\n\nfunc main() {\n  recordMetrics()\n  http.Handle(\"/metrics\", promhttp.Handler())\n  http.ListenAndServe(\":8080\", nil)\n}\n// curl http://localhost:8080/metrics")
	create(db, "Install golang on android\n(tags: install android)\n---\n\n1. Install Termux from Play Market\n2. pkg install golang \n3. cd ~\n4. mkdir gopath\n5. export GOPATH=$HOME/gopath\n6. pkg install git\n7. go get github.com/gorilla/mux")
	create(db, "Unsafe for loop\n(tags: unsafe for loop)\n---\n\narr := []uint32{1, 2, 3}\nconst size = unsafe.Sizeof(uint32(0)) //4\nfor i := 0; i < len(arr); i++ {\n  fmt.Printf(\"%d \",\n    *(*uint32)( // conver into (*uint32), then take value - *(*uint32)\n      unsafe.Pointer( // get address\n        // address 0-element + offset size (4)\n        uintptr(unsafe.Pointer(&arr[0])) + (uintptr(i) * size)))) // uintptr(i) for type assign\n}")
	create(db, "Unsafe string to bytes without copy\n(tags: unsafe string byte)\n---\n\nfunc string2bytes(s string) []byte {\n  stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))\n  bh := reflect.SliceHeader{\n    Data: stringHeader.Data,\n    Len:  stringHeader.Len,\n    Cap:  stringHeader.Len,\n  }\n  return *(*[]byte)(unsafe.Pointer(&bh))\n}")
	create(db, "Unsafe bytes to string without copy\n(tags: unsafe string byte)\n---\n\nfunc bytes2string(b []byte) string {\n  sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n  sh := reflect.StringHeader{\n    Data: sliceHeader.Data,\n    Len:  sliceHeader.Len,\n  }\n  return *(*string)(unsafe.Pointer(&sh))\n}")
	create(db, "Unsafe change struct fields\n(tags: unsafe struct field)\n---\n\ntype Programmer struct {\n  name     string\n  language string\n}\np := Programmer{\"Tom\", \"en\"}\nname := (*string)(unsafe.Pointer(&p))\n*name = \"Foma\"\nlang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Offsetof(p.language)))\n*lang = \"ru\"")
	create(db, "Unsafe change unexported struct fields from other package\n(tags: unsafe struct field unexported)\n---\n\np2 := a.Programmer2{}\n// cannot refer to unexported field or method name (p2.name = \"Foma\")\n// but we can see in source code what the fields there. First field is string\nname2 := (*string)(unsafe.Pointer(&p2))\n*name2 = \"Foma\"\n// second field is int. Doing the offset by string size\nage2 := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(\"\"))))\n*age2 = 25\n// third field is string\nlang2 := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(\"\")) + unsafe.Sizeof(int(0))))\n*lang2 = \"ru\"")
	create(db, "Json marshal infinity float to null\n(tags: json marshal float nan infinity)\n---\n\ntype Measure struct {\n  Type  string   `json:\"type\"`\n  Power *float64 `json:\"power\"`\n}\n\nfunc main() {\n  val := math.Inf(1)\n  power := &val\n  if math.IsInf(val, 0) {\n  \tpower = nil\n  }\n  m := Measure{\n  \tType: \"simple\",\n  \tPower: power,\n  }\n  j, _ := json.Marshal(&m)\n  fmt.Println(string(j)) // {\"type\":\"simple\",\"power\":null}\n}")
	create(db, "Scan arguments in string by template\n(tags: scan arg string)\n---\n\nvar name string\nvar age int\nn, err := fmt.Sscanf(\"Joe is 22 years old\", \"%s is %d years old\", &name, &age)")
	create(db, "Printf formats\n(tags: printf print format)\n---\n\nvar i int\nvar f float32\nvar s string\nvar b bool\nvar c Car\n\nfmt.Printf(\"%v\\n\", i) //0\nfmt.Printf(\"%v\\n\", f) //0\nfmt.Printf(\"%v\\n\", s) //\nfmt.Printf(\"%v\\n\", b) //false\nfmt.Printf(\"%v\\n\", c) //{ 0}\n\nfmt.Printf(\"%+v\\n\", i) //0\nfmt.Printf(\"%+v\\n\", f) //0\nfmt.Printf(\"%+v\\n\", s) //\nfmt.Printf(\"%+v\\n\", b) //false\nfmt.Printf(\"%+v\\n\", c) //{Model: Speed:0}\n\nfmt.Printf(\"%#v\\n\", i) //0\nfmt.Printf(\"%#v\\n\", f) //0\nfmt.Printf(\"%#v\\n\", s) //\"\"\nfmt.Printf(\"%#v\\n\", b) //false\nfmt.Printf(\"%#v\\n\", c) //main.Car{Model:\"\", Speed:0}\n\nfmt.Printf(\"%T\\n\", i) //int\nfmt.Printf(\"%T\\n\", f) //float32\nfmt.Printf(\"%T\\n\", s) //string\nfmt.Printf(\"%T\\n\", b) //bool\nfmt.Printf(\"%T\\n\", c) //main.Car\n\nfmt.Printf(\"%%\\n\") //%\n\ni = 15\nf = 32.7\ns = \"Pri vet!\"\nb = true\nc = Car{\"Audi\", 200}\n\nfmt.Printf(\"%#v\\n\", i) //15\nfmt.Printf(\"%#v\\n\", f) //32.7\nfmt.Printf(\"%#v\\n\", s) //\"Pri vet!\"\nfmt.Printf(\"%#v\\n\", b) //true\nfmt.Printf(\"%#v\\n\", c) //main.Car{Model:\"Audi\", Speed:200}\n\nfmt.Printf(\"%b\\n\", i) //1111\nfmt.Printf(\"%c\\n\", i) //☼\nfmt.Printf(\"%d\\n\", i) //15\nfmt.Printf(\"%o\\n\", i) //17\nfmt.Printf(\"%O\\n\", i) //0o17\nfmt.Printf(\"%q\\n\", i) //'\\x0f'\nfmt.Printf(\"%x\\n\", i) //f\nfmt.Printf(\"%X\\n\", i) //F\nfmt.Printf(\"%U\\n\", i) //U+000F\n\nfmt.Printf(\"%b\\n\", f) //8572109p-18\nfmt.Printf(\"%e\\n\", f) //3.270000e+01\nfmt.Printf(\"%E\\n\", f) //3.270000E+01\nfmt.Printf(\"%f\\n\", f) //32.700001\nfmt.Printf(\"%F\\n\", f) //32.700001\nfmt.Printf(\"%g\\n\", f) //32.7\nfmt.Printf(\"%G\\n\", f) //32.7\nfmt.Printf(\"%x\\n\", f) //0x1.05999ap+05\nfmt.Printf(\"%X\\n\", f) //0X1.05999AP+05\nfmt.Printf(\"%9.2f\\n\", f) //\t32.70\n\nfmt.Printf(\"%s\\n\", s) //Pri vet!\nfmt.Printf(\"%q\\n\", s) //\"Pri vet!\"\nfmt.Printf(\"%q\\n\", \"abc\\tdef\\n\") //\"abc\\tdef\\n\"\nfmt.Printf(\"%x\\n\", s) //5072692076657421\nfmt.Printf(\"%X\\n\", s) //5072692076657421\nfmt.Printf(\"% X\\n\", s) //50 72 69 20 76 65 74 21\n\nfmt.Println(\"\\n=== Slice ===\")\n// pointer on 0-element\nfmt.Printf(\"%p\\n\", []int{1, 2, 3}) //0x11812274\n\nfmt.Println(\"\\n=== Sprintf ===\") //pointer\ns1 := fmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\ns2 := fmt.Sprintf(\"%6.2f\", 12.0)\nfmt.Println(s1, s2) // 12.00  12.00\ns3 := fmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17) \nfmt.Println(s3) //16 17 0x10 0x11\n\n// errors:\nWrong type or unknown verb: %!verb(type=value)\n\tPrintf(\"%d\", \"hi\"):        %!d(string=hi)\nToo many arguments: %!(EXTRA type=value)\n\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\nToo few arguments: %!verb(MISSING)\n\tPrintf(\"hi%d\"):            hi%!d(MISSING)\nNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\nInvalid or invalid use of argument index: %!(BADINDEX)\n\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\nif a String method calls panic(\"bad\"), the resulting formatted message will look like\n\t%!s(PANIC=bad)")
	create(db, "Date to string\n(tags: date string)\n---\n\nfileName := fmt.Sprintf(\"data_%s.txt\", time.Now().Format(\"20060102_150405\"))")
	create(db, "Pattern chain of responsibility\n(tags: pattern chain responsibility)\n---\n\nПаттерн Chain Of Responsibility относится к поведенческим паттернам уровня объекта.\n\nПаттерн Chain Of Responsibility позволяет избежать привязки объекта-отправителя запроса к объекту-получателю запроса, при этом давая шанс обработать этот запрос нескольким объектам. Получатели связываются в цепочку, и запрос передается по цепочке, пока не будет обработан каким-то объектом.\n\nПо сути это цепочка обработчиков, которые по очереди получают запрос, а затем решают, обрабатывать его или нет. Если запрос не обработан, то он передается дальше по цепочке. Если же он обработан, то паттерн сам решает передавать его дальше или нет. Если запрос не обработан ни одним обработчиком, то он просто теряется.\n\nТребуется для реализации:\n\nБазовый абстрактный класс Handler, описывающий интерфейс обработчиков в цепочки;\nКласс ConcreteHandlerA, реализующий конкретный обработчик A;\nКласс ConcreteHandlerB, реализующий конкретный обработчик B;\nКласс ConcreteHandlerC, реализующий конкретный обработчик C;\nОбратите внимание, что вместо хранения ссылок на всех кандидатов-получателей запроса, каждый отправитель хранит единственную ссылку на начало цепочки, а каждый получатель имеет единственную ссылку на своего преемника - последующий элемент в цепочке.\n\npackage chain_of_responsibility\n\n// Handler provides a handler interface.\ntype Handler interface {\n\tSendRequest(message int) string\n}\n// ConcreteHandlerA implements handler \"A\".\ntype ConcreteHandlerA struct {\n\tnext Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerA) SendRequest(message int) (result string) {\n  if message == 1 {\n    result = \"Im handler 1\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n// ConcreteHandlerB implements handler \"B\".\ntype ConcreteHandlerB struct {\n  next Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerB) SendRequest(message int) (result string) {\n  if message == 2 {\n    result = \"Im handler 2\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n// ConcreteHandlerC implements handler \"C\".\ntype ConcreteHandlerC struct {\n  next Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerC) SendRequest(message int) (result string) {\n  if message == 3 {\n    result = \"Im handler 3\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n\nfunc TestChainOfResponsibility(t *testing.T) {\n  expect := \"Im handler 2\"\n  handlers := &ConcreteHandlerA{\n    next: &ConcreteHandlerB{\n      next: &ConcreteHandlerC{},\n    },\n  }\n  result := handlers.SendRequest(2)\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")

	create(db, "Pattern Command\n(tags: pattern command)\n---\n\nThe Command pattern refers to object-level behavioral patterns.\n\nThe Command pattern allows you to represent a request as an object. It follows that a command is an object. Such requests, for example, can be queued, canceled, or resumed.\n\nIn this pattern, we operate with the following concepts:\nCommand - a request in the form of an object for execution;\nReceiver - a request receiver object that will process our command;\nInvoker is the requestor object.\n\nThe Command pattern decouples the object that initiates an operation from the object that knows how to perform it. The only thing the initiator needs to know is how to send the command.\n\nRequired for implementation:\n\n1. Basic abstract class Command describing the command interface;\n2. The ConcreteCommand class that implements the command;\n3. The Invoker class, which implements the initiator, writes the command and provokes its execution;\n4. The Receiver class, which implements the receiver and has a set of actions that the command can request;\n\nInvoker knows how to stack commands and initiate their execution by some event. By contacting Invoker, you can cancel the command while it is not completed.\n\nThe ConcreteCommand contains the requests to the Receiver that it must execute. In turn, Receiver contains only a set of Actions that are executed when they are called from the ConcreteCommand.\n\npackage command\n\n// Command provides a command interface.\ntype Command interface {\n  Execute() string\n}\n// ToggleOnCommand implements the Command interface.\ntype ToggleOnCommand struct {\n  receiver *Receiver\n}\n// Execute command.\nfunc (c *ToggleOnCommand) Execute() string {\n  return c.receiver.ToggleOn()\n}\n// ToggleOffCommand implements the Command interface.\ntype ToggleOffCommand struct {\n  receiver *Receiver\n}\n// Execute command.\nfunc (c *ToggleOffCommand) Execute() string {\n  return c.receiver.ToggleOff()\n}\n// Receiver implementation.\ntype Receiver struct {\n}\n// ToggleOn implementation.\nfunc (r *Receiver) ToggleOn() string {\n  return \"Toggle On\"\n}\n// ToggleOff implementation.\nfunc (r *Receiver) ToggleOff() string {\n  return \"Toggle Off\"\n}\n// Invoker implementation.\ntype Invoker struct {\n  commands []Command\n}\n// StoreCommand adds command.\nfunc (i *Invoker) StoreCommand(command Command) {\n  i.commands = append(i.commands, command)\n}\n// UnStoreCommand removes command.\nfunc (i *Invoker) UnStoreCommand() {\n  if len(i.commands) != 0 {\n    i.commands = i.commands[:len(i.commands)-1]\n  }\n}\n// Execute all commands.\nfunc (i *Invoker) Execute() string {\n  var result string\n  for _, command := range i.commands {\n    result += command.Execute() + \"\\n\"\n  }\n  return result\n}\n\nfunc TestCommand(t *testing.T) {\n  expect := \"Toggle On\\n\" +\n    \"Toggle Off\\n\"\n  invoker := &Invoker{}\n  receiver := &Receiver{}\n  invoker.StoreCommand(&ToggleOnCommand{receiver: receiver})\n  invoker.StoreCommand(&ToggleOffCommand{receiver: receiver})\n  result := invoker.Execute()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Iterator\n(tags: pattern iterator)\n---\n\nПаттерн Iterator относится к поведенческим паттернам уровня объекта.\n\nПаттерн Iterator предоставляет механизм обхода коллекций объектов не раскрывая их внутреннего представления.\n\nЗачастую этот паттерн используется вместо массива объектов, чтобы не только предоставить доступ к элементам, но и наделить некоторой логикой.\n\nIterator представляет собой общий интерфейс, позволяющий реализовать произвольную логику итераций.\n\nТребуется для реализации:\n\n1. Интерфейс Iterator описывающий набор методов для доступа к коллекции;\n2. Класс ConcreteIterator, реализующий интерфейс Iterator. Следит за позицией текущего элемента при переборе коллекции (Aggregate).;\n3. Интерфейс Aggregate описывающий набор методов коллекции объектов;\n4. Класс ConcreteAggregate, реализующий интерфейс Aggregate и хранящий в себе элементы коллекции.\n\npackage iterator\n\n// Iterator provides a iterator interface.\ntype Iterator interface {\n  Index() int\n  Value() interface{}\n  Has() bool\n  Next()\n  Prev()\n  Reset()\n  End()\n}\n// Aggregate provides a collection interface.\ntype Aggregate interface {\n  Iterator() Iterator\n}\n// BookIterator implements the Iterator interface.\ntype BookIterator struct {\n  shelf    *BookShelf\n  index    int\n  internal int\n}\n// Index returns current index\nfunc (i *BookIterator) Index() int {\n  return i.index\n}\n// Value returns current value\nfunc (i *BookIterator) Value() interface{} {\n  return i.shelf.Books[i.index]\n}\n// Has implementation.\nfunc (i *BookIterator) Has() bool {\n  if i.internal < 0 || i.internal >= len(i.shelf.Books) {\n    return false\n  }\n  return true\n}\n// Next goes to the next item.\nfunc (i *BookIterator) Next() {\n  i.internal++\n  if i.Has() {\n    i.index++\n  }\n}\n// Prev goes to the previous item.\nfunc (i *BookIterator) Prev() {\n  i.internal--\n  if i.Has() {\n    i.index--\n  }\n}\n// Reset resets iterator.\nfunc (i *BookIterator) Reset() {\n  i.index = 0\n  i.internal = 0\n}\n// End goes to the last item.\nfunc (i *BookIterator) End() {\n  i.index = len(i.shelf.Books) - 1\n  i.internal = i.index\n}\n// BookShelf implements the Aggregate interface.\ntype BookShelf struct {\n  Books []*Book\n}\n// Iterator creates and returns the iterator over the collection.\nfunc (b *BookShelf) Iterator() Iterator {\n  return &BookIterator{shelf: b}\n}\n// Add adds an item to the collection.\nfunc (b *BookShelf) Add(book *Book) {\n  b.Books = append(b.Books, book)\n}\n// Book implements a item of the collection.\ntype Book struct {\n  Name string\n}\n\nfunc TestIterator(t *testing.T) {\n  shelf := new(BookShelf)\n  books := []string{\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"}\n  for _, book := range books {\n    shelf.Add(&Book{Name: book})\n  }\n  for iterator := shelf.Iterator(); iterator.Has(); iterator.Next() {\n    index, value := iterator.Index(), iterator.Value().(*Book)\n    if value.Name != books[index] {\n      t.Errorf(\"Expect Book.Name to %s, but %s\", books[index], value.Name)\n    }\n  }\n}")
	create(db, "Pattern Mediator\n(tags: pattern mediator)\n---\n\nПаттерн Mediator относится к поведенческим паттернам уровня объекта.\n\nПаттерн Mediator предоставляет объект-посредник, скрывающий способ взаимодействия множества других объектов-коллег. Mediator делает систему слабо связанной, избавляя объекты от необходимости ссылаться друг на друга, что позволяет изменять взаимодействие между ними независимо.\n\nНапример, у нас есть посредник между заводом производства хлебобулочных изделий, фермером и магазином сбыта. Посредник избавляет фермера от взаимодействия с заводом, который использует его сырье, а завод от взаимодействия с магазином, в который поступает продукция для сбыта.\n\nТребуется для реализации:\n\n1. Интерфейс Mediator - посредник описывающий организацию процесса по обмену информацией между объектами типа Colleague;\n2. Класс ConcreteMediator, реализующий интерфейс Mediator;\n3. Базовый абстрактный класс Colleague - коллега описывающий организацию процесса взаимодействия объектов-коллег с объектом типа Mediator;\n4. Класс ConcreteColleague, реализующий интерфейс Colleague. Каждый объект-коллега знает только об объекте-медиаторе. Все объекты-коллеги обмениваются информацией только через посредника.\n\npackage mediator\n\n// Mediator provides a mediator interface.\ntype Mediator interface {\n  Notify(msg string)\n}\n// Тип ConcreteMediator, реализует посредника\ntype ConcreteMediator struct {\n  *Farmer\n  *Cannery\n  *Shop\n}\n// Notify implementation.\nfunc (m *ConcreteMediator) Notify(msg string) {\n  if msg == \"Farmer: Tomato complete...\" {\n    m.Cannery.AddMoney(-15000.00)\n    m.Farmer.AddMoney(15000.00)\n    m.Cannery.MakeKetchup(m.Farmer.GetTomato())\n  } else if msg == \"Cannery: Ketchup complete...\" {\n    m.Shop.AddMoney(-30000.00)\n    m.Cannery.AddMoney(30000.00)\n    m.Shop.SellKetchup(m.Cannery.GetKetchup())\n  }\n}\n// СonnectСolleagues connects all colleagues.\nfunc СonnectСolleagues(farmer *Farmer, cannery *Cannery, shop *Shop) {\n  mediator := &ConcreteMediator{\n    Farmer:  farmer,\n    Cannery: cannery,\n    Shop:    shop,\n  }\n  mediator.Farmer.SetMediator(mediator)\n  mediator.Cannery.SetMediator(mediator)\n  mediator.Shop.SetMediator(mediator)\n}\n// Farmer implements a Farmer colleague\ntype Farmer struct {\n  mediator Mediator\n  tomato   int\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (f *Farmer) SetMediator(mediator Mediator) {\n  f.mediator = mediator\n}\n// AddMoney adds money.\nfunc (f *Farmer) AddMoney(m float64) {\n  f.money += m\n}\n// GrowTomato implementation.\nfunc (f *Farmer) GrowTomato(tomato int) {\n  f.tomato = tomato\n  f.money -= 7500.00\n  f.mediator.Notify(\"Farmer: Tomato complete...\")\n}\n// GetTomato returns tomatos.\nfunc (f *Farmer) GetTomato() int {\n  return f.tomato\n}\n// Cannery implements a Cannery colleague.\ntype Cannery struct {\n  mediator Mediator\n  ketchup  int\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (c *Cannery) SetMediator(mediator Mediator) {\n  c.mediator = mediator\n}\n// AddMoney adds money.\nfunc (c *Cannery) AddMoney(m float64) {\n  c.money += m\n}\n// MakeKetchup implementation.\nfunc (c *Cannery) MakeKetchup(tomato int) {\n  c.ketchup = tomato\n  c.mediator.Notify(\"Cannery: Ketchup complete...\")\n}\n// GetKetchup returns ketchup.\nfunc (c *Cannery) GetKetchup() int {\n  return c.ketchup\n}\n// Shop implements a Shop colleague.\ntype Shop struct {\n  mediator Mediator\n  money    float64\n}\n// SetMediator sets mediator.\nfunc (s *Shop) SetMediator(mediator Mediator) {\n  s.mediator = mediator\n}\n// AddMoney adds money.\nfunc (s *Shop) AddMoney(m float64) {\n  s.money += m\n}\n// SellKetchup converts ketchup to money.\nfunc (s *Shop) SellKetchup(ketchup int) {\n  s.money = float64(ketchup) * 54.75\n}\n// GetMoney returns money.\nfunc (s *Shop) GetMoney() float64 {\n  return s.money\n}\n\nfunc TestMediator(t *testing.T) {\n  farmer := new(Farmer)\n  cannery := new(Cannery)\n  shop := new(Shop)\n  farmer.AddMoney(7500.00)\n  cannery.AddMoney(15000.00)\n  shop.AddMoney(30000.00)\n  СonnectСolleagues(farmer, cannery, shop)\n  // A farmer grows a 1000kg tomato\n  // and informs the mediator about the completion of his work.\n  // Next, the mediator sends the tomatoes to the cannery.\n  // After the cannery produces 1000 packs of ketchup,\n  // he informs the mediator about his delivery to the store.\n  farmer.GrowTomato(1000)\n  expect := float64(54750)\n  result := shop.GetMoney()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %f, but %f.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Memento\n(tags: pattern memento)\n---\n\nПаттерн Memento относится к поведенческим паттернам уровня объекта.\n\nПаттерн Memento получает и сохраняет за пределами объекта его внутреннее состояние так, чтобы позже можно было восстановить объект в таком же состоянии. Если клиенту в дальнейшем нужно \"откатить\" состояние исходного объекта, он передает Memento обратно в исходный объект для его восстановления.\n\nПаттерн оперирует тремя объектами:\n\n1. Хозяин состояния (Originator);\n2. Хранитель (Memento) - Хранит в себе состояние объекта-хозяина класса Originator;\n3. Смотритель (Caretaker) - Отвечает за сохранность объекта-хранителя класса Memento.\n\nТребуется для реализации:\n\n1. Класс Originator, у которого есть какое-то меняющиеся состояние, а так же он может создавать и принимать хранителей (Memento) своего состояния;\n2. Класс Memento, реализует хранилище для состояния Originator;\n3. Класс Caretaker, получает и хранит объект-хранитель (Memento), пока он не понадобится хозяину.\n\npackage memento\n// Originator implements a state master.\ntype Originator struct {\n  State string\n}\n// CreateMemento returns state storage.\nfunc (o *Originator) CreateMemento() *Memento {\n  return &Memento{state: o.State}\n}\n// SetMemento sets old state.\nfunc (o *Originator) SetMemento(memento *Memento) {\n  o.State = memento.GetState()\n}\n// Memento implements storage for the state of Originator\ntype Memento struct {\n  state string\n}\n// GetState returns state.\nfunc (m *Memento) GetState() string {\n  return m.state\n}\n// Caretaker keeps Memento until it is needed by Originator.\ntype Caretaker struct {\n  Memento *Memento\n}\n\nfunc TestMomento(t *testing.T) {\n  originator := new(Originator)\n  caretaker := new(Caretaker)\n  originator.State = \"On\"\n  caretaker.Memento = originator.CreateMemento()\n  originator.State = \"Off\"\n  originator.SetMemento(caretaker.Memento)\n  if originator.State != \"On\" {\n    t.Errorf(\"Expect State to %s, but %s\", originator.State, \"On\")\n  }\n}")
	create(db, "Pattern Observer\n(tags: pattern observer)\n---\n\nПаттерн Observer относится к поведенческим паттернам уровня объекта.\n\nПаттерн Observer определяет зависимость \"один-ко-многим\" между объектами так, что при изменении состояния одного объекта все зависящие от него объекты уведомляются об этом и обновляются автоматически.\n\nОсновные участиники паттерна это Издатели (Subject) и Подписчики (Observer). \n\nИмеется два способа получения уведомлений от издателя:\n\n1. Метод вытягивания: После получения уведомления от издателя, подписчик должен пойти к издателю и забрать (вытянуть) данные самостоятельно.  \n2. Метод проталкивания: Издатель не уведомляет подписчика об обновлениях данных, а самостоятельно доставляет (проталкивает) данные подписчику.\n\nТребуется для реализации:\n\n1. Абстрактный класс Subject, определяющий интерфейс Издателя;\n2. Класс ConcreteSubject, реализует интерфейс Subject;\n3. Абстрактный класс Observer, определяющий общий функционал Подписчиков;\n4. Класс ConcreteObserver, реализует Подписчика;\n\npackage observer\n\n// Publisher interface.\ntype Publisher interface {\n  Attach(observer Observer)\n  SetState(state string)\n  Notify()\n}\n// Observer provides a subscriber interface.\ntype Observer interface {\n  Update(state string)\n}\n// ConcretePublisher implements the Publisher interface.\ntype ConcretePublisher struct {\n  observers []Observer\n  state     string\n}\n// NewPublisher is the Publisher constructor.\nfunc NewPublisher() Publisher {\n  return &ConcretePublisher{}\n}\n// Attach a Observer\nfunc (s *ConcretePublisher) Attach(observer Observer) {\n  s.observers = append(s.observers, observer)\n}\n// SetState sets new state\nfunc (s *ConcretePublisher) SetState(state string) {\n  s.state = state\n}\n// Notify sends notifications to subscribers.\n// Push model.\nfunc (s *ConcretePublisher) Notify() {\n  for _, observer := range s.observers {\n    observer.Update(s.state)\n  }\n}\n// ConcreteObserver implements the Observer interface.\ntype ConcreteObserver struct {\n  state string\n}\n// Update set new state\nfunc (s *ConcreteObserver) Update(state string) {\n  s.state = state\n}\n\nfunc ExampleObserver() {\n  publisher := NewPublisher()\n  publisher.Attach(&ConcreteObserver{})\n  publisher.Attach(&ConcreteObserver{})\n  publisher.Attach(&ConcreteObserver{})\n  publisher.SetState(\"New State...\")\n  publisher.Notify()\n}")
	create(db, "Pattern State\n(tags: pattern state)\n---\n\nПаттерн State относится к поведенческим паттернам уровня объекта.\n\nПаттерн State позволяет объекту изменять свое поведение в зависимости от внутреннего состояния и является объектно-ориентированной реализацией конечного автомата. Поведение объекта изменяется на столько, что создается впечатление, что изменился класс объекта.\n\nПаттерн должен применятся, когда поведение объекта зависит от его состояния и оно должно изменяться во время выполнения программы при условии того, что состояний достаточно много и использовать для этого условные операторы разбросаные по коду достаточно затруднительно.\n\nТребуется для реализации:\n\n1. Класс Context, представляет собой объектно-ориентированное представление конечного автомата;\n2. Абстрактный класс State, определяющий интерфейс различных состояний;\n3. Класс ConcreteStateA, реализует одно из поведений ассоциированное с определенным состоянием;\n4. Класс ConcreteStateB, реализует одно из поведений ассоциированное с определенным состоянием.\n\npackage state\n\n// MobileAlertStater provides a common interface for various states.\ntype MobileAlertStater interface {\n  Alert() string\n}\n// MobileAlert implements an alert depending on its state.\ntype MobileAlert struct {\n  state MobileAlertStater\n}\n// Alert returns a alert string\nfunc (a *MobileAlert) Alert() string {\n  return a.state.Alert()\n}\n// SetState changes state\nfunc (a *MobileAlert) SetState(state MobileAlertStater) {\n  a.state = state\n}\n// NewMobileAlert is the MobileAlert constructor.\nfunc NewMobileAlert() *MobileAlert {\n  return &MobileAlert{state: &MobileAlertVibration{}}\n}\n// MobileAlertVibration implements vibration alert\ntype MobileAlertVibration struct {\n}\n// Alert returns a alert string\nfunc (a *MobileAlertVibration) Alert() string {\n  return \"Vrrr... Brrr... Vrrr...\"\n}\n// MobileAlertSong implements beep alert\ntype MobileAlertSong struct {\n}\n// Alert returns a alert string\nfunc (a *MobileAlertSong) Alert() string {\n  return \"Белые розы, Белые розы. Беззащитны шипы...\"\n}\n\nfunc TestState(t *testing.T) {\n  expect := \"Vrrr... Brrr... Vrrr...\" +\n    \"Vrrr... Brrr... Vrrr...\" +\n    \"Белые розы, Белые розы. Беззащитны шипы...\"\n  mobile := NewMobileAlert()\n  result := mobile.Alert()\n  result += mobile.Alert()\n  mobile.SetState(&MobileAlertSong{})\n  result += mobile.Alert()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Strategy\n(tags: pattern strategy)\n---\n\nПаттерн Strategy относится к поведенческим паттернам уровня объекта.\n\nПаттерн Strategy определяет набор алгоритмов схожих по роду деятельности, инкапсулирует их в отдельный класс и делает их подменяемыми. Паттерн Strategy позволяет подменять алгоритмы без участия клиентов, которые используют эти алгоритмы.\n\nТребуется для реализации:\n\n1. Класс Context, представляющий собой контекст выполнения той или иной стратегии;\n2. Абстрактный класс Strategy, определяющий интерфейс различных стратегий;\n3. Класс ConcreteStrategyA, реализует одну из стратегий представляющую собой алгоритмы, направленные на достижение определенной цели;\n4. Класс ConcreteStrategyB, реализует одно из стратегий представляющую собой алгоритмы, направленные на достижение определенной цели.\n\npackage strategy\n\n// StrategySort provides an interface for sort algorithms.\ntype StrategySort interface {\n  Sort([]int)\n}\n// BubbleSort implements bubble sort algorithm.\ntype BubbleSort struct {\n}\n// Sort sorts data.\nfunc (s *BubbleSort) Sort(a []int) {\n  size := len(a)\n  if size < 2 {\n    return\n  }\n  for i := 0; i < size; i++ {\n    for j := size - 1; j >= i+1; j-- {\n      if a[j] < a[j-1] {\n        a[j], a[j-1] = a[j-1], a[j]\n      }\n    }\n  }\n}\n// InsertionSort implements insertion sort algorithm.\ntype InsertionSort struct {\n}\n// Sort sorts data.\nfunc (s *InsertionSort) Sort(a []int) {\n  size := len(a)\n  if size < 2 {\n    return\n  }\n  for i := 1; i < size; i++ {\n    var j int\n    var buff = a[i]\n    for j = i - 1; j >= 0; j-- {\n      if a[j] < buff {\n        break\n      }\n      a[j+1] = a[j]\n    }\n    a[j+1] = buff\n  }\n}\n// Context provides a context for execution of a strategy.\ntype Context struct {\n  strategy StrategySort\n}\n// Algorithm replaces strategies.\nfunc (c *Context) Algorithm(a StrategySort) {\n  c.strategy = a\n}\n// Sort sorts data according to the chosen strategy.\nfunc (c *Context) Sort(s []int) {\n  c.strategy.Sort(s)\n}\n\nfunc TestStrategy(t *testing.T) {\n  data1 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}\n  data2 := []int{8, 2, 6, 7, 1, 3, 9, 5, 4}\n  ctx := new(Context)\n  ctx.Algorithm(&BubbleSort{})\n  ctx.Sort(data1)\n  ctx.Algorithm(&InsertionSort{})\n  ctx.Sort(data2)\n  expect := \"1,2,3,4,5,6,7,8,9,\"\n  var result1 string\n  for _, val := range data1 {\n    result1 += strconv.Itoa(val) + \",\"\n  }\n  if result1 != expect {\n    t.Errorf(\"Expect result1 to equal %s, but %s.\\n\", expect, result1)\n  }\n  var result2 string\n  for _, val := range data2 {\n    result2 += strconv.Itoa(val) + \",\"\n  }\n  if result2 != expect {\n    t.Errorf(\"Expect result2 to equal %s, but %s.\\n\", expect, result2)\n  }\n}")
	create(db, "Pattern Template Method\n(tags: pattern template method)\n---\n\nПаттерн Template Method относится к поведенческим паттернам уровня класса.\n\nПаттерн Template Method формирует структуру алгоритма и позволяет в производных классах реализовать, перекрыть или переопределить определенные шаги алгоритма, не изменяя структуру алгоритма в целом.\n\nПроектировщик решает, какие шаги алгоритма являются неизменными, а какие изменяемыми. Абстрактный базовый класс реализует стандартные неизменяемые шаги алгоритма и может предоставлять реализацию по умолчанию для изменяемых шагов. Изменяемые шаги могут предоставляться клиентом компонента в конкретных производных классах.\n\nТребуется для реализации:\n\n1. Абстрактный класс AbstractClass, реализующий Template Method, который описывает порядок действий;\n2. Класс ConcreteClass, реализующий изменяемые действия.\n\npackage template_method\n\n// QuotesInterface provides an interface for setting different quotes.\ntype QuotesInterface interface {\n  Open() string\n  Close() string\n}\n// Quotes implements a Template Method.\ntype Quotes struct {\n  QuotesInterface\n}\n// Quotes is the Template Method.\nfunc (q *Quotes) Quotes(str string) string {\n  return q.Open() + str + q.Close()\n}\n// NewQuotes is the Quotes constructor.\nfunc NewQuotes(qt QuotesInterface) *Quotes {\n  return &Quotes{qt}\n}\n// FrenchQuotes implements wrapping the string in French quotes.\ntype FrenchQuotes struct {\n}\n// Open sets opening quotes.\nfunc (q *FrenchQuotes) Open() string {\n  return \"«\"\n}\n// Close sets closing quotes.\nfunc (q *FrenchQuotes) Close() string {\n  return \"»\"\n}\n// GermanQuotes implements wrapping the string in German quotes.\ntype GermanQuotes struct {\n}\n// Open sets opening quotes.\nfunc (q *GermanQuotes) Open() string {\n  return \"„\"\n}\n// Close sets closing quotes.\nfunc (q *GermanQuotes) Close() string {\n  return \"“\"\n}\n\nfunc TestTemplateMethod(t *testing.T) {\n  expect := \"«Test String»\"\n  qt := NewQuotes(&FrenchQuotes{})\n  result := qt.Quotes(\"Test String\")\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Visitor\n(tags: pattern visitor)\n---\n\nПаттерн Visitor относится к поведенческим паттернам уровня объекта.\n\nПаттерн Visitor позволяет обойти набор элементов (объектов) с разнородными интерфейсами, а также позволяет добавить новый метод в класс объекта, при этом, не изменяя сам класс этого объекта.\n\nТребуется для реализации:\n\n1. Абстрактный класс Visitor, описывающий интерфейс визитера;\n2. Класс ConcreteVisitor, реализующий конкретного визитера. Реализует методы для обхода конкретного элемента;\n3. Класс ObjectStructure, реализующий структуру(коллекцию), в которой хранятся элементы для обхода;\n4. Абстрактный класс Element, реализующий интерфейс элементов структуры;\n5. Класс ElementA, реализующий элемент структуры;\n6. Класс ElementB, реализующий элемент структуры.\n\npackage visitor\n\n// Visitor provides a visitor interface.\ntype Visitor interface {\n  VisitSushiBar(p *SushiBar) string\n  VisitPizzeria(p *Pizzeria) string\n  VisitBurgerBar(p *BurgerBar) string\n}\n// Place provides an interface for place that the visitor should visit.\ntype Place interface {\n  Accept(v Visitor) string\n}\n// People implements the Visitor interface.\ntype People struct {\n}\n// VisitSushiBar implements visit to SushiBar.\nfunc (v *People) VisitSushiBar(p *SushiBar) string {\n  return p.BuySushi()\n}\n// VisitPizzeria implements visit to Pizzeria.\nfunc (v *People) VisitPizzeria(p *Pizzeria) string {\n  return p.BuyPizza()\n}\n// VisitBurgerBar implements visit to BurgerBar.\nfunc (v *People) VisitBurgerBar(p *BurgerBar) string {\n  return p.BuyBurger()\n}\n// City implements a collection of places to visit.\ntype City struct {\n  places []Place\n}\n// Add appends Place to the collection.\nfunc (c *City) Add(p Place) {\n  c.places = append(c.places, p)\n}\n// Accept implements a visit to all places in the city.\nfunc (c *City) Accept(v Visitor) string {\n  var result string\n  for _, p := range c.places {\n    result += p.Accept(v)\n  }\n  return result\n}\n// SushiBar implements the Place interface.\ntype SushiBar struct {\n}\n// Accept implementation.\nfunc (s *SushiBar) Accept(v Visitor) string {\n  return v.VisitSushiBar(s)\n}\n// BuySushi implementation.\nfunc (s *SushiBar) BuySushi() string {\n  return \"Buy sushi...\"\n}\n// Pizzeria implements the Place interface.\ntype Pizzeria struct {\n}\n// Accept implementation.\nfunc (p *Pizzeria) Accept(v Visitor) string {\n  return v.VisitPizzeria(p)\n}\n// BuyPizza implementation.\nfunc (p *Pizzeria) BuyPizza() string {\n  return \"Buy pizza...\"\n}\n// BurgerBar implements the Place interface.\ntype BurgerBar struct {\n}\n// Accept implementation.\nfunc (b *BurgerBar) Accept(v Visitor) string {\n  return v.VisitBurgerBar(b)\n}\n// BuyBurger implementation.\nfunc (b *BurgerBar) BuyBurger() string {\n  return \"Buy burger...\"\n}\n\nfunc TestVisitor(t *testing.T) {\n  expect := \"Buy sushi...Buy pizza...Buy burger...\"\n  city := new(City)\n  city.Add(&SushiBar{})\n  city.Add(&Pizzeria{})\n  city.Add(&BurgerBar{})\n  result := city.Accept(&People{})\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Abstract Factory\n(tags: pattern abstract factory)\n---\n\nПаттерн Abstract Factory относится к порождающим паттернам уровня объекта.\n\nПаттерн Abstract Factory предоставляет общий интерфейс для создания семейства взаимосвязанных объектов. Это позволяет отделить функциональность системы от внутренней реализации каждого класса, а обращение к этим классам становится возможным через абстрактные интерфейсы.\n\nВ общем виде абстрактная фабрика выглядит следующим образом. Для каждого из семейств объектов, создается конкретная фабрика (наследник абстрактной), посредством которой создаются продукты этого семейства.\n\nПример: Есть две фабрики по производству газировки, Кока-Кола и Пепси. Эти фабрики выпускают семейство продуктов (объектов) - бутылка, крышка, этикетка, жидкость. Каждая из этих фабрик выпускает продукты, которые взаимодействуют между собой и не могут жить отдельно друг от друга. Фабрика Кока-Кола не может поставлять клиентам пустые бутылки.\n\nЧто бы реализовать простое создание семейства объектов, должен быть интерфейс, по которому работает фабрика, так же фабрика должна выпускать продукты с определенным интерфейсом. Например, бутылки обеих компаний обладают одним интерфейсом - у них есть горлышко через которое они наполняются жидкостью, так же мы можем узнать объем бутылок. Дальше бутылки могут отличаться по форме, объему или материалу, нас это не касается, нам нужно только знать, куда наливать жидкость, а так же, сколько этой жидкости нужно.\n\nТребуется для реализации:\n\n1. Класс абстрактной фабрики AbstractFactory, описывающий общий интерфейс фабрики, от которой будет наследоваться каждая конкретная фабрика;\n2. Класс абстрактного продукта AbstractProduct, описывающий общий интерфейс продукта, от которого будет наследоваться каждый конкретный продукт;\n3. Класс конкретной фабрики Factory;\n4. Класс конкретного продукта ProductA.\n5. Класс конкретного продукта ProductB.\n\nПодведем итог.\n\nАбстрактная фабрика представляет собой базовый класс, описывающий интерфейс конкретных фабрик, создающих продукты. Производные от него классы конкретных фабрик, должны реализовать этот интерфейс.\n\nТакже абстрактная фабрика должна описывать абстрактные продукты, которые она производит, что бы конкретные фабрики производили продукты с нужными интерфейсами.\n\npackage abstract_factory\n\n// AbstractFactory provides an interface for creating families of related objects.\ntype AbstractFactory interface {\n  CreateWater(volume float64) AbstractWater\n  CreateBottle(volume float64) AbstractBottle\n}\n// AbstractWater provides a water interface.\ntype AbstractWater interface {\n  GetVolume() float64\n}\n// AbstractBottle provides a bottle interface.\ntype AbstractBottle interface {\n  PourWater(water AbstractWater) // Bottle interacts with a water.\n  GetBottleVolume() float64\n  GetWaterVolume() float64\n}\n// CocaColaFactory implements AbstractFactory interface.\ntype CocaColaFactory struct {\n}\n// NewCocaColaFactory is the CocaColaFactory constructor.\nfunc NewCocaColaFactory() AbstractFactory {\n  return &CocaColaFactory{}\n}\n// CreateWater implementation.\nfunc (f *CocaColaFactory) CreateWater(volume float64) AbstractWater {\n  return &CocaColaWater{volume: volume}\n}\n// CreateBottle implementation.\nfunc (f *CocaColaFactory) CreateBottle(volume float64) AbstractBottle {\n  return &CocaColaBottle{volume: volume}\n}\n// CocaColaWater implements AbstractWater.\ntype CocaColaWater struct {\n  volume float64 // Volume of drink.\n}\n// GetVolume returns volume of drink.\nfunc (w *CocaColaWater) GetVolume() float64 {\n  return w.volume\n}\n// CocaColaBottle implements AbstractBottle.\ntype CocaColaBottle struct {\n  water  AbstractWater // Bottle must contain a drink.\n  volume float64       // Volume of bottle.\n}\n// PourWater pours water into a bottle.\nfunc (b *CocaColaBottle) PourWater(water AbstractWater) {\n  b.water = water\n}\n// GetBottleVolume returns volume of bottle.\nfunc (b *CocaColaBottle) GetBottleVolume() float64 {\n  return b.volume\n}\n// GetWaterVolume returns volume of water.\nfunc (b *CocaColaBottle) GetWaterVolume() float64 {\n  return b.water.GetVolume()\n}\n\nfunc TestAbstractFactory(t *testing.T) {\n  cocacolaFactory := NewCocaColaFactory()\n  cocacolaWater := cocacolaFactory.CreateWater(2.5)\n  cocacolaBottle := cocacolaFactory.CreateBottle(2.5)\n  cocacolaBottle.PourWater(cocacolaWater)\n  if cocacolaBottle.GetWaterVolume() != cocacolaBottle.GetBottleVolume() {\n    t.Errorf(\"Expect volume to %.1fL, but %.1fL\", cocacolaBottle.GetWaterVolume(), cocacolaBottle.GetBottleVolume())\n  }\n}")
	create(db, "Pattern Builder\n(tags: pattern builder)\n---\n\nПаттерн Builder относится к порождающим паттернам уровня объекта.\n\nПаттерн Builder определяет процесс поэтапного построения сложного продукта. После того как будет построена последняя его часть, продукт можно использовать.\n\nВ примере паттерна Abstract Factory приводился пример двух фабрик Кока-Кола и Перси. Возьмем одну фабрику, она производит сложный продукт, состоящий из 4 частей (крышка, бутылка, этикетка, напиток), которые должны быть применены в нужном порядке. Нельзя вначале взять крышку,  бутылку, завинтить крышку, а потом пытаться налить туда напиток. Для реализации объекта, бутылки Кока-Колы, которая поставляется клиенту, нам нужен паттерн Builder.\n\nВажно понимать, что сложный объект это не обязательно объект оперирующий несколькими другими объектами в смысле ООП. Например, нам нужно получить документ состоящий из заголовка, введения, содержания и заключения. Наш документ, это сложный объект. Что бы был какой-то единый порядок составления документа, мы будем использовать паттерн Builder.\n\nТребуется для реализации:\n\n1. Класс Director, который будет распоряжаться строителем и отдавать ему команды в нужном порядке, а строитель будет их выполнять;\n2. Базовый абстрактный класс Builder, который описывает интерфейс строителя, те команды, которые он обязан выполнять;\n3. Класс ConcreteBuilder, который реализует интерфейс строителя и взаимодействует со сложным объектом;\n4. Класс сложного объекта Product.\n\npackage builder\n\n// Builder provides a builder interface.\ntype Builder interface {\n  MakeHeader(str string)\n  MakeBody(str string)\n  MakeFooter(str string)\n}\n// Director implements a manager\ntype Director struct {\n  builder Builder\n}\n// Construct tells the builder what to do and in what order.\nfunc (d *Director) Construct() {\n  d.builder.MakeHeader(\"Header\")\n  d.builder.MakeBody(\"Body\")\n  d.builder.MakeFooter(\"Footer\")\n}\n// ConcreteBuilder implements Builder interface.\ntype ConcreteBuilder struct {\n  product *Product\n}\n// MakeHeader builds a header of document..\nfunc (b *ConcreteBuilder) MakeHeader(str string) {\n  b.product.Content += \"<header>\" + str + \"</header>\"\n}\n// MakeBody builds a body of document.\nfunc (b *ConcreteBuilder) MakeBody(str string) {\n  b.product.Content += \"<article>\" + str + \"</article>\"\n}\n// MakeFooter builds a footer of document.\nfunc (b *ConcreteBuilder) MakeFooter(str string) {\n  b.product.Content += \"<footer>\" + str + \"</footer>\"\n}\n// Product implementation.\ntype Product struct {\n  Content string\n}\n// Show returns product.\nfunc (p *Product) Show() string {\n  return p.Content\n}\n\nfunc TestBuilder(t *testing.T) {\n  expect := \"<header>Header</header>\" +\n    \"<article>Body</article>\" +\n    \"<footer>Footer</footer>\"\n  product := new(Product)\n  director := Director{&ConcreteBuilder{product}}\n  director.Construct()\n  result := product.Show()\n  if result != expect {\n    t.Errorf(\"Expect result to %s, but %s\", result, expect)\n  }\n}")
	create(db, "Pattern Factory Method\n(tags: pattern factory method)\n---\n\nПаттерн Factory Method относится к порождающим паттернам уровня класса и сфокусирован только на отношениях между классами.\n\nПаттерн Factory Method полезен, когда система должна оставаться легко расширяемой путем добавления объектов новых типов. Этот паттерн является основой для всех порождающих паттернов и может легко трансформироваться под нужды системы. По этому, если перед разработчиком стоят не четкие требования для продукта или не ясен способ организации взаимодействия между продуктами, то для начала можно воспользоваться паттерном Factory Method, пока полностью не сформируются все требования.\n\nПаттерн Factory Method применяется для создания объектов с определенным интерфейсом, реализации которого предоставляются потомками. Другими словами, есть базовый абстрактный класс фабрики, который говорит, что каждая его наследующая фабрика должна реализовать такой-то метод для создания своих продуктов.\n\nРеализация фабричного метода может быть разной, в большинстве случаем это зависит от языка реализации. Это может быть полиморфизм или параметризированный метод.\n\nПример: К нам приходят файлы трех расширений .txt, .png, .doc. В зависимости от расширения файла мы должны сохранять его в одном из каталогов /file/txt/, /file/png/ и /file/doc/. Значит, у нас будет файловая фабрика с параметризированным фабричным методом, принимающим путь к файлу, который нам нужно сохранить в одном из каталогов. Этот фабричный метод возвращает нам объект, используя который мы можем манипулировать с нашим файлом (сохранить, посмотреть тип и каталог для сохранения). Заметьте, мы никак не указываем какой экземпляр объекта-продукта нам нужно получить, это делает фабричный метод путем определения расширения файла и на его основе выбора подходящего класса продукта. Тем самым, если наша система будет расширяться и доступных расширений файлов станет, например 25, то нам всего лишь нужно будет изменить фабричный метод и реализовать классы продуктов.\n\nТребуется для реализации:\n\n1. Базовый абстрактный класс Creator, описывающий интерфейс, который должна реализовать конкретная фабрика для производства продуктов. Этот базовый класс описывает фабричный метод.\n2. Базовый класс Product, описывающий интерфейс продукта, который возвращает фабрика. Все продукты возвращаемые фабрикой должны придерживаться единого интерфейса.\n3. Класс конкретной фабрики по производству продуктов ConcreteCreator. Этот класс должен реализовать фабричный метод;\n4. Класс реального продукта ConcreteProductA;\n5. Класс реального продукта ConcreteProductB;\n6. Класс реального продукта ConcreteProductC.\n\nFactory Method отличается от Abstract Factory, тем, что Abstract Factory производит семейство объектов, эти объекты разные, обладают разными интерфейсами, но взаимодействуют между собой. В то время как Factory Method производит продукты придерживающиеся одного интерфейса и эти продукты не связаны между собой, не вступают во взаимодействие.\n\npackage factory_method\n\nimport \"log\"\n\n// Creater provides a factory interface.\ntype Creater interface {\n  CreateProduct(action string) Producter // Factory Method\n}\n// Producter provides a product interface.\n// All products returned by factory must provide a single interface.\ntype Producter interface {\n  Use() string // Every product should be can be used\n}\n// ConcreteCreater implements Creater interface.\ntype ConcreteCreater struct {\n}\n// NewCreater is the ConcreteCreater constructor.\nfunc NewCreater() Creater {\n  return &ConcreteCreater{}\n}\n// CreateProduct is a Factory Method\nfunc (p *ConcreteCreater) CreateProduct(action string) Producter {\n  var product Producter\n  switch action {\n  case \"A\":\n    product = &ConcreteProductA{action}\n  case \"B\":\n    product = &ConcreteProductB{action}\n  case \"C\":\n    product = &ConcreteProductC{action}\n  default:\n    log.Fatalln(\"Unknown Action\")\n  }\n  return product\n}\n// ConcreteProductA implements product \"A\"\ntype ConcreteProductA struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductA) Use() string {\n  return p.action\n}\n// ConcreteProductB implements product \"B\"\ntype ConcreteProductB struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductB) Use() string {\n  return p.action\n}\n// ConcreteProductC implements product \"C\"\ntype ConcreteProductC struct {\n  action string\n}\n// Use returns product action\nfunc (p *ConcreteProductC) Use() string {\n  return p.action\n}\n\nfunc TestFactoryMethod(t *testing.T) {\n  assert := []string{\"A\", \"B\", \"C\"}\n  factory := NewCreater()\n  products := []Producter{\n    factory.CreateProduct(\"A\"),\n    factory.CreateProduct(\"B\"),\n    factory.CreateProduct(\"C\"),\n  }\n  for i, product := range products {\n    if action := product.Use(); action != assert[i] {\n      t.Errorf(\"Expect action to %s, but %s.\\n\", assert[i], action)\n    }\n  }\n}")
	create(db, "Pattern Prototype\n(tags: pattern prototype)\n---\n\nПаттерн Prototype относится к порождающим паттернам уровня объекта.\n\nПаттерн Prototype позволяет создавать новые объекты, путем копирования (клонирования) созданного ранее объекта-оригинала-продукта (прототипа).\n\nПаттерн описывает процесс создания объектов-клонов на основе имеющегося объекта-прототипа, другими словами, паттерн Prototype описывает способ организации процесса клонирования.\n\nТребуется для реализации:\n\n1. Базовый класс Prototype, объявляющий интерфейс клонирования. Все классы его наследующие должны реализовывать этот механизм клонирования;\n2. Класс продукта ConcretePrototypeA, который должен реализовывать этот прототип;\n3. Класс продукта ConcretePrototypeB, который должен реализовывать этот прототип.\n\nОбычно операция клонирования происходит через метод clone(), который описан в базовом классе и его должен реализовать каждый продукт.\n\npackage prototype\n\n// Prototyper provides a cloning interface.\ntype Prototyper interface {\n  Clone() Prototyper\n  GetName() string\n}\n// ConcreteProduct implements product \"A\"\ntype ConcreteProduct struct {\n  name string // Имя продукта\n}\n// NewConcreteProduct is the Prototyper constructor.\nfunc NewConcreteProduct(name string) Prototyper {\n  return &ConcreteProduct{\n    name: name,\n  }\n}\n// GetName returns product name\nfunc (p *ConcreteProduct) GetName() string {\n  return p.name\n}\n// Clone returns a cloned object.\nfunc (p *ConcreteProduct) Clone() Prototyper {\n  return &ConcreteProduct{p.name}\n}\n\nfunc TestPrototype(t *testing.T) {\n  product := NewConcreteProduct(\"A\")\n  cloneProduct := product.Clone()\n  if cloneProduct.GetName() != product.GetName() {\n    t.Error(\"Expect name \\\"A\\\" to equal, but not equal.\")\n  }\n}")
	create(db, "Pattern Singleton\n(tags: pattern singleton)\n---\n\nПаттерн Singleton относится к порождающим паттернам уровня объекта. \nПаттерн контролирует создание единственного экземпляра некоторого класса и предоставляет доступ к нему. \nДругими словами, Singleton гарантирует, что у класса будет только один экземпляр и предоставляет к нему точку доступа, через фабричный метод.\n\nТребуется для реализации:\n\n1. Функция GetInstance, создающая экземпляр класса Singleton только один раз. Если до этого экземпляр уже был создан, то просто возвращает этот экземпляр.\n\npackage singleton\n\nimport \"sync\"\n\n// Singleton implementation.\ntype Singleton struct {\n}\nvar (\n  instance *Singleton\n  once     sync.Once\n)\n// GetInstance returns singleton\nfunc GetInstance() *Singleton {\n  once.Do(func() {\n    instance = &Singleton{}\n  })\n  return instance\n}\n\nfunc TestSingleton(t *testing.T) {\n  instance1 := GetInstance()\n  instance2 := GetInstance()\n  if instance1 != instance2 {\n    t.Error(\"Objects are not equal!\\n\")\n  }\n}")
	create(db, "Pattern Adapter\n(tags: pattern adapter)\n---\n\nПаттерн Adapter относится к структурным паттернам уровня класса.\n\nЧасто в новом проекте разработчики хотят повторно использовать уже существующий код. Например, имеющиеся классы могут обладать нужной функциональностью и иметь при этом несовместимые интерфейсы. В таких случаях следует использовать паттерн Adapter.\n\nСмысл работы этого паттерна в том, что если у вас есть класс и его интерфейс не совместим с кодом вашей системы, то что бы разрешить этот конфликт, мы не изменяем код этого класса, а пишем для него адаптер. Другими словами Adapter адаптирует существующий код к требуемому интерфейсу (является переходником).\n\nТребуется для реализации:\n\n1. Интерфейс Target, описывающий целевой интерфейс (тот интерфейс с которым наша система хотела бы работать);\n2. Класс Adaptee, который наша система должна адаптировать под себя;\n3. Класс Adapter, адаптер реализующий целевой интерфейс.\n\npackage adapter\n\n// Target provides an interface with which the system should work.\ntype Target interface {\n  Request() string\n}\n// Adaptee implements system to be adapted.\ntype Adaptee struct {\n}\n// NewAdapter is the Adapter constructor.\nfunc NewAdapter(adaptee *Adaptee) Target {\n  return &Adapter{adaptee}\n}\n// SpecificRequest implementation.\nfunc (a *Adaptee) SpecificRequest() string {\n  return \"Request\"\n}\n// Adapter implements Target interface and is an adapter.\ntype Adapter struct {\n  *Adaptee\n}\n// Request is an adaptive method.\nfunc (a *Adapter) Request() string {\n  return a.SpecificRequest()\n}\n\nfunc TestAdapter(t *testing.T) {\n  adapter := NewAdapter(&Adaptee{})\n  req := adapter.Request()\n  if req != \"Request\" {\n    t.Errorf(\"Expect volume to %s, but %s\", \"Request\", req)\n  }\n}")
	create(db, "Pattern Bridge\n(tags: pattern bridge)\n---\n\nПаттерн Bridge относится к структурным паттернам уровня объекта.\n\nПаттерн Bridge позволяет разделить объект на абстракцию и реализацию так, чтобы они могли изменяться независимо друг от друга.\n\nЕсли для одной абстракции возможно несколько реализаций, то обычно используют наследование. Однако такой подход не всегда удобен, так как наследование жестко привязывает реализацию к абстракции, что затрудняет независимую модификацию и усложняет их повторное использование.\n\nПаттерн следует применять, когда у нас имеется абстракция и несколько её реализаций. Разумеется, нет смысла отделять абстракцию от реализации, если реализация может быть только одна.\n\nЯ не нашел не одного адекватного описания паттерна \"Мост\". Все что мне встречалось, либо не соответствует действительности и примеры высосаны из пальца или очень размыты. Из того, что я понял и могу объяснить на пальцах - Мост это хитрая агрегация. Класс реализующий изделие, реализует интерфейс агрегируемого класса, который подсовывается на этапе создания экземпляра класса изделия.\n\nКак я понял... у нас есть 3 машины и 3 разных двигателя. Каждый двигатель подходит к каждой машине, т.е. она реализует его интерфейс. Если делать это наследованием, мы получим 9 разных классом. Получается у каждой машины 3 модификации. Это неудобно, поэтому мы будем подсовывать двигатель на этапе создания машины. Так же каждый двигатель, может работать на разном топливе, дизель или бензин, что бы не плодить 6 разных реализаций, при создании двигателя мы будем подсовывать в него тип топлива.\n\nДля реализации паттерна в этом примере необходимо в базовом классе автомобилей добавить поле для хранения указателя на тип реализации, значение которого класс будет получать в своём конструкторе, и вызывать по необходимости методы вложенного объекта.\n\nТребуется для реализации:\n\n1. Базовый абстрактный класс (в нашем случаем описывающий автомобиль);\n2. Класс реализующий базовый класс. В нем есть свойство в которое мы будем подсовывать указатель на используемый двигатель (машина может работать с любым из представленных двигателей);\n3. Абстракция двигателя;\n4. Реализация двигателя.\n\nВ общем свойство хранящее указатель на используемый объект и есть мост. Мы в него можем подсовывать разные объекты, главное, что бы они имели одинаковый интерфейс.\n\npackage bridge\n\n// Carer provides car interface.\ntype Carer interface {\n  Rase() string\n}\n// Enginer provides engine interface.\ntype Enginer interface {\n  GetSound() string\n}\n// Car implementation.\ntype Car struct {\n  engine Enginer\n}\n// NewCar is the Car constructor.\nfunc NewCar(engine Enginer) Carer {\n  return &Car{\n    engine: engine,\n  }\n}\n// Rase implementation.\nfunc (c *Car) Rase() string {\n  return c.engine.GetSound()\n}\n// EngineSuzuki implements Suzuki engine.\ntype EngineSuzuki struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineSuzuki) GetSound() string {\n  return \"SssuuuuZzzuuuuKkiiiii\"\n}\n// EngineHonda implements Honda engine.\ntype EngineHonda struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineHonda) GetSound() string {\n  return \"HhoooNnnnnnnnnDddaaaaaaa\"\n}\n// EngineLada implements Lada engine.\ntype EngineLada struct {\n}\n// GetSound returns sound of the engine.\nfunc (e *EngineLada) GetSound() string {\n  return \"PhhhhPhhhhPhPhPhPhPh\"\n}\n\nfunc TestBridge(t *testing.T) {\n  expect := \"SssuuuuZzzuuuuKkiiiii\"\n  car := NewCar(&EngineSuzuki{})\n  sound := car.Rase()\n  if sound != expect {\n    t.Errorf(\"Expect sound to %s, but %s\", expect, sound)\n  }\n}")
	create(db, "Pattern Composite\n(tags: pattern composite)\n---\n\nПаттерн Composite относится к структурным паттернам уровня объекта.\n\nПаттерн Composite группирует схожие объекты в древовидные структуры.\n\nДля построения дерева будут использоваться массивы, представляющие ветви дерева.\n\nТребуется для реализации:\n\n1. Базовый абстрактный класс Component который предоставляет интерфейс, как для ветвей, так и для листьев дерева;\n2. Класс Composite, реализующий интерфейс Component и являющийся ветвью дерева;\n3. Класс Leaf, реализующий интерфейс Component и являющийся листом дерева.\n\nОбратите внимание, что лист дерева является классом листовых узлов и не может иметь потомков (из листа не может вырасти ветвь или другой лист).\n\nВетви дерева задают поведение объектов, входящих в структуру дерева, у которых есть потомки, а также сами хранит в себе компоненты дерева. Другим словами ветви могут содержать другие ветви и листья.\n\nОсновным назначением паттерна, является обеспечение единого интерфейса как к составному (ветви) так и конечному (листу) объекту, что бы клиент не задумывался над тем, с каким объектом он работает. \n\npackage composite\n\n// Component provides an interface for branches and leaves of a tree.\ntype Component interface {\n  Add(child Component)\n  Name() string\n  Child() []Component\n  Print(prefix string) string\n}\n// Directory implements branches of a tree\ntype Directory struct {\n  name   string\n  childs []Component\n}\n// Add appends an element to the tree branch.\nfunc (d *Directory) Add(child Component) {\n  d.childs = append(d.childs, child)\n}\n// Name returns name of the Component.\nfunc (d *Directory) Name() string {\n  return d.name\n}\n// Child returns child elements.\nfunc (d *Directory) Child() []Component {\n  return d.childs\n}\n// Print returns the branche in string representation.\nfunc (d *Directory) Print(prefix string) string {\n  result := prefix + \"/\" + d.Name() + \"\\n\"\n  for _, val := range d.Child() {\n    result += val.Print(prefix + \"/\" + d.Name())\n  }\n  return result\n}\n// File implements a leaves of a tree\ntype File struct {\n  name string\n}\n// Add implementation.\nfunc (f *File) Add(child Component) {\n}\n// Name returns name of the Component.\nfunc (f *File) Name() string {\n  return f.name\n}\n// Child implementation.\nfunc (f *File) Child() []Component {\n  return []Component{}\n}\n// Print returns the leave in string representation.\nfunc (f *File) Print(prefix string) string {\n  return prefix + \"/\" + f.Name() + \"\\n\"\n}\n// NewDirectory is constructor.\nfunc NewDirectory(name string) *Directory {\n  return &Directory{\n    name: name,\n  }\n}\n// NewFile is constructor.\nfunc NewFile(name string) *File {\n  return &File{\n    name: name,\n  }\n}\n\nfunc TestComposite(t *testing.T) {\n  expect := \"/root\\n/root/usr\\n/root/usr/B\\n/root/A\\n\"\n  rootDir := NewDirectory(\"root\")\n  usrDir := NewDirectory(\"usr\")\n  fileA := NewFile(\"A\")\n  rootDir.Add(usrDir)\n  rootDir.Add(fileA)\n  fileB := NewFile(\"B\")\n  usrDir.Add(fileB)\n  result := rootDir.Print(\"\")\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Decorator\n(tags: pattern decorator)\n---\n\nПаттерн Decorator относится к структурным паттернам уровня объекта.\n\nПаттерн Decorator используется для расширения функциональности объектов путем динамического добавления объекту новых возможностей. При реализации паттерна используется отношение композиции.\n\nСущность работы декоратора заключается в обёртывании готового объекта новым функционалом, при этом весь оригинальный интерфейс объекта остается доступным, путем передачи декоратором всех запросов обернутому объекту.\n\nТребуется для реализации:\n\n1. Базовый абстрактный класс Component который предоставляет интерфейс для класса декоратора и компонента;\n2. Класс ConcreteDecorator, реализующий интерфейс Component и перезагружающий все методы компонента, по необходимости к ним добавляется функционал;\n3. Класс ConcreteComponent реализующий интерфейс Component и который будет обернут декоратором.\n\nПри такой структуре нам не важно является ли компонент декоратором или конкретной реализацией, так как интерфейс у них совпадает, и мы можем делать цепочки декораторов. Тем самым динамически менять состояние и поведение объекта.\n\nЯ слышал пример с Карлсоном и мне он очень понравился. У нас есть Карлсон, мы на него одеваем комбинезон тем самым меняя его состояние, потом на штаны одеваем пропеллер тем самым меняем поведение. Пропеллер в зависимости от ситуации можно снять, изменив поведение на обратное или можно одеть другой комбинезон с другими свойствами.\n\npackage decorator\n\n// Component provides an interface for a decorator and component.\ntype Component interface {\n  Operation() string\n}\n// ConcreteComponent implements a component.\ntype ConcreteComponent struct {\n}\n// Operation implementation.\nfunc (c *ConcreteComponent) Operation() string {\n  return \"I am component!\"\n}\n// ConcreteDecorator implements a decorator.\ntype ConcreteDecorator struct {\n  component Component\n}\n// Operation wraps operation of component\nfunc (d *ConcreteDecorator) Operation() string {\n  return \"<strong>\" + d.component.Operation() + \"</strong>\"\n}\n\nfunc TestDecorator(t *testing.T) {\n  expect := \"<strong>I am component!</strong>\"\n  decorator := &ConcreteDecorator{&ConcreteComponent{}}\n  result := decorator.Operation()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Facade\n(tags: pattern facade)\n---\n\nПаттерн Facade относится к структурным паттернам уровня объекта.\n\nПаттерн Facade предоставляет высокоуровневый унифицированный интерфейс в виде набора имен методов к набору взаимосвязанных классов или объектов некоторой подсистемы, что облегчает ее использование.\n\nРазбиение сложной системы на подсистемы позволяет упростить процесс разработки, а также помогает максимально снизить зависимости одной подсистемы от другой. Однако использовать такие подсистемы становиться довольно сложно. Один из способов решения этой проблемы является  паттерн Facade. Наша задача, сделать простой, единый интерфейс, через который можно было бы взаимодействовать с подсистемами.\n\nВ качестве примера можно привести интерфейс автомобиля. Современные автомобили имеют унифицированный интерфейс для водителя, под которым скрывается сложная подсистема. Благодаря применению навороченной электроники, делающей большую часть работы за водителя, тот может с лёгкостью управлять автомобилем, не задумываясь, как там все работает.\n\nТребуется для реализации:\n\n1. Класс Facade предоставляющий унифицированный доступ для классов подсистемы;\n2. Класс подсистемы SubSystemA;\n3. Класс подсистемы SubSystemB;\n4. Класс подсистемы SubSystemC.\n\nЗаметьте, что фасад не является единственной точкой доступа к подсистеме, он не ограничивает возможности, которые могут понадобиться \"продвинутым\" пользователям, желающим работать с подсистемой напрямую.\n\npackage facade\n\nimport \"strings\"\n\n// NewMan creates man.\nfunc NewMan() *Man {\n  return &Man{\n    house: &House{},\n    tree:  &Tree{},\n    child: &Child{},\n  }\n}\n// Man implements man and facade.\ntype Man struct {\n  house *House\n  tree  *Tree\n  child *Child\n}\n// Todo returns that man must do.\nfunc (m *Man) Todo() string {\n  result := []string{\n    m.house.Build(),\n    m.tree.Grow(),\n    m.child.Born(),\n  }\n  return strings.Join(result, \"\\n\")\n}\n// House implements a subsystem \"House\"\ntype House struct {\n}\n// Build implementation.\nfunc (h *House) Build() string {\n  return \"Build house\"\n}\n// Tree implements a subsystem \"Tree\"\ntype Tree struct {\n}\n// Grow implementation.\nfunc (t *Tree) Grow() string {\n  return \"Tree grow\"\n}\n// Child implements a subsystem \"Child\"\ntype Child struct {\n}\n// Born implementation.\nfunc (c *Child) Born() string {\n  return \"Child born\"\n}\n\nfunc TestFacade(t *testing.T) {\n  expect := \"Build house\\nTree grow\\nChild born\"\n  man := NewMan()\n  result := man.Todo()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Flyweight\n(tags: pattern flyweight)\n---\n\nПаттерн Flyweight относится к структурным паттернам уровня объекта.\n\nПаттерн Flyweight используется для эффективной поддержки большого числа мелких объектов, он позволяет повторно использовать мелкие объекты в различном контексте.\n\nТребуется для реализации:\n\n1. Класс FlyweightFactory, являющейся модифицированным паттерном фабрики, для создания приспособленцев;\n2. Базовый абстрактный класс Flyweight, для описания общего интерфейса приспособленцев;\n3. Класс ConcreteFlyweight реализующий приспособленца, который будет замещать собой одинаковые мелкие объекты.\n\nСуть в том, что мы можем запрашивать приспособленцев у фабрики по запросу, в свою очередь она будет отдавать те объекты, которые уже были созданы, или создавать новые. Это означает, что мы будем использовать уже созданные объекты, а не создавать ещё больше, если объекты под наши нужны уже имеются. \n\npackage flyweight\n\n// Flyweighter interface\ntype Flyweighter interface {\n  GetName() string\n  SetName(name string)\n}\n// FlyweightFactory implements a factory.\n// If a suitable flyweighter is in pool, then returns it.\ntype FlyweightFactory struct {\n  pool map[int]Flyweighter\n}\n// GetFlyweight creates or returns a suitable Flyweighter by state.\nfunc (f *FlyweightFactory) GetFlyweight(state int) Flyweighter {\n  if f.pool == nil {\n    f.pool = make(map[int]Flyweighter)\n  }\n  if _, ok := f.pool[state]; !ok {\n    f.pool[state] = &ConcreteFlyweight{state: state}\n  }\n  return f.pool[state]\n}\n// ConcreteFlyweight implements a Flyweighter interface.\ntype ConcreteFlyweight struct {\n  state int\n  name  string\n}\n// GetName returns name\nfunc (f *ConcreteFlyweight) GetName() string {\n  return \"My name: \" + f.name\n}\n// SetName sets a name\nfunc (f *ConcreteFlyweight) SetName(name string) {\n  f.name = name\n}\n\nfunc TestFlyweight(t *testing.T) {\n  expect := \"My name: Jeck\"\n  factory := new(FlyweightFactory)\n  flyweight1 := factory.GetFlyweight(1)\n  flyweight2 := factory.GetFlyweight(2)\n  flyweight3 := factory.GetFlyweight(3)\n  flyweight1.SetName(\"Jim\")\n  flyweight2.SetName(\"Jeck\")\n  flyweight3.SetName(\"Jill\")\n  flyweightN := factory.GetFlyweight(2)\n  result := flyweightN.GetName()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Proxy\n(tags: pattern proxy)\n---\n\nПаттерн Proxy относится к структурным паттернам уровня объекта.\n\nПаттерн Proxy предоставляет объект для контроля доступа к другому объекту.\n\nДругое название паттерна - \"Суррогат\". В этом понимании, это предмет или продукт, заменяющий собой какой-либо другой предмет или продукт, с которым суррогат имеет лишь некоторые общие свойства, но он не обладает всеми качествами оригинального предмета или продукта.\n\nПаттерна Proxy выдвигается ряд важных требований, а именно то, что оригинальный объект и его суррогат должны взаимодействовать друг с другом, а также должна быть возможность, замещения оригинальным объектом, суррогата в месте его использования, соответственно интерфейсы взаимодействия оригинального объекта и его суррогата должны совпадать.\n\nВам будет легче понять паттерн, если вы смотрели фильм \"Суррогаты\".\n\nТребуется для реализации:\n\n1. Интерфейс Subject, являющейся общим интерфейсом для реального объекта и его суррогата;\n2. Класс RealSubject, реализующий реальный объект;\n3. Класс Proxy, реализующий объект суррогата. Хранит в себе ссылку на реальный объект, что позволяет заместителю обращаться к реальному объект напрямую;\n\nНапример, паттерн Proxy можно использовать, если нам нужно управлять ресурсоемкими объектами, но мы не хотим создавать экземпляры таких объектов до момента их реального использования.\n\nВы можете подумать, что это тоже самое, что и Adapter или Decorator. Но... \n\nProxy предоставляет своему объекту тот же интерфейс. \nAdapter предоставляет другой интерфейс. \nDecorator предоставляет расширенный интерфейс.\n\npackage proxy\n\n// Subject provides an interface for a real subject and its surrogate.\ntype Subject interface {\n  Send() string\n}\n// Proxy implements a surrogate.\ntype Proxy struct {\n  realSubject Subject\n}\n// Send sends a message\nfunc (p *Proxy) Send() string {\n  if p.realSubject == nil {\n    p.realSubject = &RealSubject{}\n  }\n  return \"<strong>\" + p.realSubject.Send() + \"</strong>\"\n}\n// RealSubject implements a real subject\ntype RealSubject struct {\n}\n// Send sends a message\nfunc (s *RealSubject) Send() string {\n  return \"I’ll be back!\"\n}\n\nfunc TestProxy(t *testing.T) {\n  expect := \"<strong>I’ll be back!</strong>\"\n  proxy := new(Proxy)\n  result := proxy.Send()\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")
	create(db, "Pattern Specification\n(tags: pattern specification)\n---\n\nСпецификация — шаблон проектирования, посредством которого представление правил бизнес логики может быть преобразовано в виде цепочки объектов, связанных операциями булевой логики.\n\n// Pattern Specification\n//\n// In the following example, we are retrieving invoices and sending them to a collection agency if\n//  1. they are overdue,\n//  2. notices have been sent, and\n//  3. they are not already with the collection agency.\n// This example is meant to show the end result of how the logic is 'chained' together.\n//\n// This usage example assumes a previously defined OverdueSpecification class\n// that is satisfied when an invoice's due date is 30 days or older,\n// a NoticeSentSpecification class that is satisfied when three notices\n// have been sent to the customer, and an InCollectionSpecification class\n// that is satisfied when an invoice has already been sent to the collection\n// agency. The implementation of these classes isn't important here.\n\npackage specification\n\n// Data for analysis\ntype Invoice struct {\n  Day    int\n  Notice int\n  IsSent bool\n}\n/////\n// Invoice Specification Interface\ntype Specification interface {\n  IsSatisfiedBy(Invoice) bool\n  And(Specification) Specification\n  Or(Specification) Specification\n  Not() Specification\n  Relate(Specification)\n}\n/////\n// Invoice BaseSpecification\ntype BaseSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *BaseSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return false\n}\n// Condition AND\nfunc (self *BaseSpecification) And(spec Specification) Specification {\n  a := &AndSpecification{\n    self.Specification, spec,\n  }\n  a.Relate(a)\n  return a\n}\n// Condition OR\nfunc (self *BaseSpecification) Or(spec Specification) Specification {\n  a := &OrSpecification{\n    self.Specification, spec,\n  }\n  a.Relate(a)\n  return a\n}\n// Condition NOT\nfunc (self *BaseSpecification) Not() Specification {\n  a := &NotSpecification{\n    self.Specification,\n  }\n  a.Relate(a)\n  return a\n}\n// Relate to specification\nfunc (self *BaseSpecification) Relate(spec Specification) {\n  self.Specification = spec\n}\n/////\n// AndSpecification\ntype AndSpecification struct {\n  Specification\n  compare Specification\n}\n// Check specification\nfunc (self *AndSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return self.Specification.IsSatisfiedBy(elm) && self.compare.IsSatisfiedBy(elm)\n}\n/////\n// OrSpecification\ntype OrSpecification struct {\n  Specification\n  compare Specification\n}\n// Check specification\nfunc (self *OrSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return self.Specification.IsSatisfiedBy(elm) || self.compare.IsSatisfiedBy(elm)\n}\n/////\n// NotSpecification\ntype NotSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *NotSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return !self.Specification.IsSatisfiedBy(elm)\n}\n/////\n// Invoice's due date is 30 days or older\ntype OverDueSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *OverDueSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return elm.Day >= 30\n}\n// Constructor\nfunc NewOverDueSpecification() Specification {\n  a := &OverDueSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n// Three notices have been sent to the customer\ntype NoticeSentSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *NoticeSentSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return elm.Notice >= 3\n}\n// Constructor\nfunc NewNoticeSentSpecification() Specification {\n  a := &NoticeSentSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n// Invoice has already been sent to the collection agency.\ntype InCollectionSpecification struct {\n  Specification\n}\n// Check specification\nfunc (self *InCollectionSpecification) IsSatisfiedBy(elm Invoice) bool {\n  return !elm.IsSent\n}\n// Constructor\nfunc NewInCollectionSpecification() Specification {\n  a := &InCollectionSpecification{&BaseSpecification{}}\n  a.Relate(a)\n  return a\n}\n\nfunc TestSpecification(t *testing.T) {\n  overDue := NewOverDueSpecification()\n  noticeSent := NewNoticeSentSpecification()\n  inCollection := NewInCollectionSpecification()\n  sendToCollection := overDue.And(noticeSent).And(inCollection.Not())\n  invoice := Invoice{\n    Day:    31,    // >= 30\n    Notice: 4,     // >= 3\n    IsSent: false, // false\n  }\n  // true!\n  result := sendToCollection.IsSatisfiedBy(invoice)\n  if !result {\n    t.Errorf(\"Expect result to equal %v, but %v.\\n\", false, true)\n  }\n}")

	//create(db, "")
	//create(db, "")
	//create(db, "")

}
