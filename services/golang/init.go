package golang

import (
	"gorm.io/gorm"
	"tbot/internal/errors"
)

func initialize(db *gorm.DB) {
	err := db.Debug().AutoMigrate(&Topic{}, &Tag{})
	errors.PanicIfErr(err)

	create(db, "Get executable dir\n(tags: executable dir)\n---\n\nex, err := os.Executable()\ndir := filepath.Dir(ex)\nfmt.Println(\"dir:\", dir)\n")
	create(db, "Extract beginning of string (prefix)\n(tags: extract beginning string prefix)\n---\n\nt := string([]rune(s)[:5])")
	create(db, "Extract string suffix\n(tags: extract string suffix)\n---\n\nt := string([]rune(s)[len([]rune(s))-5:])")
	create(db, "Exec other program\n(tags: exec program)\n---\n\nerr := exec.Command(\"program\", \"arg1\", \"arg2\").Run()")
	create(db, "Telegram message markdown\n(tags: telegram message markdown)\n---\n\n*полужирный*\n_курсив_\n[ссылка](http://www.example.com/)\n`строчный моноширинный`\n```text\nблочный моноширинный (можно писать код)\n```\n\nimport \"github.com/go-telegram-bot-api/telegram-bot-api\"\n\nmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\nmsg.ParseMode = \"markdown\" //msg.ParseMode = tgbotapi.ModeMarkdown")
	create(db, "Telegram message html\n(tags: telegram message html)\n---\n\n<b>полужирный</b>, <strong>полужирный</strong>\n<i>курсив</i>\n<a href=\"http://www.example.com/\">ссылка</a>\n<code>строчный моноширинный</code>\n<pre>блочный моноширинный (можно писать код)</pre>\n\nimport \"github.com/go-telegram-bot-api/telegram-bot-api\"\n\nmsg := tgbotapi.NewMessage(update.Message.Chat.ID, update.Message.Text)\nmsg.ParseMode = \"HTML\" //msg.ParseMode = tgbotapi.ModeHTML")
	create(db, "Iterate over map entries ordered by keys\n(tags: iterate map order key)\n---\n\nkeys := make([]string, 0, len(mymap))\nfor k := range mymap {\n    keys = append(keys, k)\n}\nsort.Strings(keys)\nfor _, k := range keys {\n    x := mymap[k]\n    fmt.Println(\"Key =\", k, \", Value =\", x)\n}\n")
	create(db, "Iterate over map entries ordered by values\n(tags: iterate map order value)\n---\n\ntype entry struct {\n    key   string\n    value int\n}\nentries := make([]entry, 0, len(mymap))\nfor k, x := range mymap {\n    entries = append(entries, entry{key: k, value: x})\n}\nsort.Slice(entries, func(i, j int) bool {\n    return entries[i].value < entries[j].value\n})\nfor _, e := range entries {\n    fmt.Println(\"Key =\", e.key, \", Value =\", e.value)\n}")
	create(db, "Slice to set\n(tags: slice set)\n---\n\ny := make(map[T]struct{}, len(x))\nfor _, v := range x {\n    y[v] = struct{}{}\n}")
	create(db, "Deduplicate slice\n(tags: deduplicate slice remove duplicate)\n---\n\nseen := make(map[T]bool)\nj := 0\nfor _, v := range x {\n    if !seen[v] {\n        x[j] = v\n        j++\n        seen[v] = true\n    }\n}\nfor i := j; i < len(x); i++ {\n    x[i] = nil\n}\nx = x[:j]")
	create(db, "Shuffle a slice\n(tags: slice shuffle)\n---\n\ny := make(map[T]struct{}, len(x))\nfor _, v := range x {\n    y[v] = struct{}{}\n}")
	create(db, "Sort slice asc\n(tags: sort slice asc)\n---\n\nsort.Slice(items, func(i, j int) bool {\n    return items[i].p < items[j].p\n})")
	create(db, "Sort slice desc\n(tags: sort slice desc)\n---\n\nsort.Slice(items, func(i, j int) bool {\n    return items[i].p > items[j].p\n})")
	create(db, "Remove item from slice by index\n(tags: remove item slice index)\n---\n\nitems = append(items[:i], items[i+1:]...)")
	create(db, "Graph with adjacency lists\n(tags: graph struct)\n---\n\ntype Vertex struct{\n    Id int\n    Label string\n    Neighbours map[*Vertex]bool\n}\ntype Graph []*Vertex")
	create(db, "Reverse a string\n(tags: string reverse)\n---\n\nrunes := []rune(s)\nfor i, j := 0, len(runes)-1; i < j; i, j = i+1, j-1 {\n   runes[i], runes[j] = runes[j], runes[i]\n}\nt := string(runes)")
	create(db, "Insert item in slice\n(tags: insert item slice)\n---\n\ns = append(s, 0)\ncopy(s[i+1:], s[i:])\ns[i] = x")
	create(db, "Filter slice\n(tags: filter slice)\n---\n\ny := make([]T, 0, len(x))\nfor _, v := range x{\n    if p(v){\n        y = append(y, v)\n    }\n}")
	create(db, "File content to string\n(tags: file content string)\n---\n\nb, err := ioutil.ReadFile(f)\nlines := string(b)")
	create(db, "Write to std error\n(tags: write std error)\n---\n\nfmt.Fprintln(os.Stderr, x, \"is negative\")")
	create(db, "Big int\n(tags: big integer)\n---\n\nx := new(big.Int)\nx.Exp(big.NewInt(3), big.NewInt(247), nil)")
	create(db, "Round float to int\n(tags: round float int)\n---\n\ny := int(math.Floor(x + 0.5))")
	create(db, "Check if int addition will overflow\n(tags: check int add overflow)\n---\n\nfunc willAddOverflow(a, b int64) bool {\n    return a > math.MaxInt64 - b\n}")
	create(db, "Check if int multiplication will overflow\n(tags: check int multiply overflow)\n---\n\nfunc multiplyWillOverflow(x, y uint64) bool {\n   if x <= 1 || y <= 1 {\n     return false\n   }\n   d := x * y\n   return d/y != x\n}")
	create(db, "Load json file into struct\n(tags: load json file struct)\n---\n\nbuffer, err := ioutil.ReadFile(\"data.json\")\nerr = json.Unmarshal(buffer, &x)")
	create(db, "Load yaml file into struct\n(tags: load yaml file struct)\n---\n\nimport \"gopkg.in/yaml.v3\"\n\nbuffer, err := ioutil.ReadFile(\"data.yaml\")\nerr = yaml.Unmarshal(buffer, &x)")
	create(db, "Save struct into json file\n(tags: save struct json file)\n---\n\nbuffer, err := json.MarshalIndent(x, \"\", \"  \")\nerr = ioutil.WriteFile(\"data.json\", buffer, 0644)")
	create(db, "Print type of variable\n(tags: print type variable)\n---\n\nfmt.Printf(\"%T\", x) //fmt.Println(reflect.TypeOf(x))")
	create(db, "Load from HTTP GET request into a string\n(tags: load http get string)\n---\n\nres, err := http.Get(u)\nbuffer, err := ioutil.ReadAll(res.Body)\nres.Body.Close()\ns := string(buffer)")
	create(db, "Read int from stdin\n(tags: read int std in)\n---\n\n_, err := fmt.Scan(&n)")
	create(db, "UDP listen and read\n(tags: udp listen read)\n---\n\nServerAddr,err := net.ResolveUDPAddr(\"udp\",p)\nServerConn, err := net.ListenUDP(\"udp\", ServerAddr)\ndefer ServerConn.Close()\nn,addr,err := ServerConn.ReadFromUDP(b[:1024])\nif n<1024 {\n    return fmt.Errorf(\"Only %d bytes could be read.\", n)\n}")
	create(db, "Binary search in sorted slice\n(tags: binary search slice)\n---\n\nfunc binarySearch(a []T, x T) int {\n    imin, imax := 0, len(a)-1\n    for imin <= imax {\n        imid := (imin + imax) / 2\n        switch {\n        case a[imid] == x:\n        return imid\n        case a[imid] < x:\n        imin = imid + 1\n        default:\n        imax = imid - 1\n        }\n    }\n    return -1\n}")
	create(db, "Measure func call duration\n(tags: measure func call duration time)\n---\n\nt1 := time.Now()\nfoo()\nt := time.Since(t1)\nns := t.Nanoseconds()\nfmt.Printf(\"%dns\\n\", ns)")
	create(db, "Breadth-first traversing in a graph\n(tags: bfs traversing graph)\n---\n\nfunc (start *Vertex) Bfs(f func(*Vertex)) {\n    queue := []*Vertex{start}\n    seen := map[*Vertex]bool{start: true}\n    for len(queue) > 0 {\n        v := queue[0]\n        queue = queue[1:]\n        f(v)\n        for next, isEdge := range v.Neighbours {\n            if isEdge && !seen[next] {\n                queue = append(queue, next)\n                seen[next] = true\n            }\n        }\n    }\n}")
	create(db, "Depth-first traversing in a graph\n(tags: dfs traversing graph)\n---\n\nfunc (v *Vertex) Dfs(f func(*Vertex), seen map[*Vertex]bool) {\n    seen[v] = true\n    f(v)\n    for next, isEdge := range v.Neighbours {\n        if isEdge && !seen[next] {\n            next.Dfs(f, seen)\n        }\n    }\n}")
	create(db, "Check if string contains only digits\n(tags: check string contains only digits)\n---\n\nisNotDigit := func(c rune) bool { return c < '0' || c > '9' }\nb := strings.IndexFunc(s, isNotDigit) == -1")
	create(db, "Check if file exists\n(tags: check file exist)\n---\n\n_, err := os.Stat(fp)\nb := !os.IsNotExist(err)")
	create(db, "Read slice of int from stdin\n(tags: read slice int std in)\n---\n\nvar ints []int\ns := bufio.NewScanner(os.Stdin)\nfor s.Scan() {\n    i, err := strconv.Atoi(s.Text())\n    if err == nil {\n        ints = append(ints, i)\n    }\n}")
	create(db, "Detect if 32-bit or 64-bit architecture\n(tags: detect 32 64 architecture)\n---\n\nif strconv.IntSize==32 {\n    f32()\n}\nif strconv.IntSize==64 {\n    f64()\n}")
	create(db, "Parse flags\n(tags: parse flags args)\n---\n\nvar b = flag.Bool(\"b\", false, \"Do bat\")\nfunc main() {\n    flag.Parse()\n    if *b {\n        bar()\n    }\n}")
	create(db, "Open URL in default browser\n(tags: open url default browser)\n---\n\nfunc openbrowser(url string) {\n    var err error\n    switch runtime.GOOS {\n    case \"linux\":\n        err = exec.Command(\"xdg-open\", url).Start()\n    case \"windows\":\n        err = exec.Command(\"rundll32\", \"url.dll,FileProtocolHandler\", url).Start()\n    case \"darwin\":\n        err = exec.Command(\"open\", url).Start()\n    default:\n        err = fmt.Errorf(\"unsupported platform\")\n    }\n    if err != nil {\n        log.Fatal(err)\n    }\n}")
	create(db, "Concatenate two slices\n(tags: concat two slice)\n---\n\nab := append(a, b...)")
	create(db, "String length\n(tags: string length)\n---\n\nn := utf8.RuneCountInString(s)")
	create(db, "Make HTTP POST request\n(tags: make http post request)\n---\n\nresponse, err := http.Post(u, contentType, body)")
	create(db, "Bytes to hex string\n(tags: byte hex string)\n---\n\ns := hex.EncodeToString(a)")
	create(db, "Hex string to byte array\n(tags: byte hex string)\n---\n\na, err := hex.DecodeString(s)")
	create(db, "Find files with a given list of filename extensions\n(tags: file extension walk)\n---\n\nL := []string{}\nerr := filepath.Walk(D, func(path string, info os.FileInfo, err error) error {\n    if err != nil {\n        fmt.Printf(\"failure accessing a path %q: %v\\n\", path, err)\n        return err\n    }\n    for _, ext := range []string{\".jpg\", \".jpeg\", \".png\"} {\n        if strings.HasSuffix(path, ext) {\n            L = append(L, path)\n            break\n        }\n    }\n    return nil\n})\n")
	create(db, "Check if point is inside rectangle\n(tags: check point inside rect)\n---\n\np := image.Pt(x, y)\nr := image.Rect(x1, y1, x2, y2)\nb := p.In(r)")
	create(db, "List files in directory\n(tags: list file dir)\n---\n\nx, err := ioutil.ReadDir(d)")
	create(db, "Make HTTP PUT request\n(tags: make http put request)\n---\n\nreq, err := http.NewRequest(\"PUT\", u, body)\nreq.Header.Set(\"Content-Type\", contentType)\nreq.ContentLength = contentLength\nresponse, err := http.DefaultClient.Do(req)")
	create(db, "Execute function in 30 seconds\n(tags: exec func after time)\n---\n\ntimer := time.AfterFunc(\n    30*time.Second,\n    func() {\n        f(42)\n    })")
	create(db, "Matrix multiplication\n(tags: matrix multiply)\n---\n\nc := new(mat.Dense)\nc.Mul(a, b)")
	create(db, "Filter and transform slice\n(tags: filter transform slice)\n---\n\nvar y []Result\nfor _, e := range x {\n    if P(e) {\n        y = append(y, T(e))\n    }\n}")
	create(db, "Get an environment variable\n(tags: env var)\n---\n\nfoo, ok := os.LookupEnv(\"FOO\")\nif !ok {\n    foo = \"none\"\n}")
	create(db, "Create folder\n(tags: create folder dir)\n---\n\nerr := os.MkdirAll(path, os.ModeDir)")
	create(db, "Pad string on the right\n(tags: pad string right)\n---\n\nif n := utf8.RuneCountInString(s); n < m {\n    s += strings.Repeat(c, m-n)\n}")
	create(db, "Pad string on the left\n(tags: pad string left)\n---\n\nif n := utf8.RuneCountInString(s); n < m {\n    s = strings.Repeat(c, m-n) + s\n}")
	create(db, "Progress bar\n(tags: progress bar)\n---\n\nfunc printProgressBar(n int, total int) {\n    var bar []string\n    tantPerFourty := int((float64(n) / float64(total)) * 40)\n    tantPerCent := int((float64(n) / float64(total)) * 100)\n    for i := 0; i < tantPerFourty; i++ {\n        bar = append(bar, \"█\")\n    }\n    progressBar := strings.Join(bar, \"\")\n    fmt.Printf(\"\\r \" + progressBar + \" - \" + strconv.Itoa(tantPerCent) + \"\")\n}")
	create(db, "Create a zip archive\n(tags: create zip archive)\n---\n\nbuf := new(bytes.Buffer)\nw := zip.NewWriter(buf)\nfor _, filename := range list {\n    input, err := os.Open(filename)\n    output, err := w.Create(filename)\n    _, err = io.Copy(output, input)\n}\nerr := w.Close()\nerr = ioutil.WriteFile(name, buf.Bytes(), 0777)")
	create(db, "Slice intersection\n(tags: slice intersection)\n---\n\nseta := make(map[T]bool, len(a))\nfor _, x := range a {\n    seta[x] = true\n}\nsetb := make(map[T]bool, len(a))\nfor _, y := range b {\n    setb[y] = true\n}\n\nvar c []T\nfor x := range seta {\n    if setb[x] {\n        c = append(c, x)\n    }\n}")
	create(db, "Replace multiple spaces with single space\n(tags: replace space)\n---\n\nwhitespaces := regexp.MustCompile('\\s+')\nt := whitespaces.ReplaceAllString(s, \" \")")
	create(db, "Create a tuple value\n(tags: create tuple interface)\n---\n\nt := []interface{}{\n    2.5,\n    \"hello\",\n    make(chan int),\n}")
	create(db, "Remove all non-digits chars\n(tags: remove digit char)\n---\n\nre := regexp.MustCompile(\"[^\\\\d]\")\nt := re.ReplaceAllLiteralString(s, \"\")")
	create(db, "Add element to the beginning of the slice\n(tags: add beginning slice)\n---\n\nitems = append([]T{x}, items...)")
	create(db, "Copy slice\n(tags: copy slice)\n---\n\ny := make([]T, len(x))\ncopy(y, x)")
	create(db, "Copy file\n(tags: copy file)\n---\n\nfunc copy(dst, src string) error {\n    data, err := ioutil.ReadFile(src)\n    stat, err := os.Stat(src)\n    return ioutil.WriteFile(dst, data, stat.Mode())\n}")
	create(db, "Cancel an operation\n(tags: cancel operation func)\n---\n\nctx, cancel := context.WithCancel(context.Background())\ngo p(ctx)\nsomethingElse()\ncancel()")
	create(db, "Timeout\n(tags: timeout operation func)\n---\n\nctx, cancel := context.WithTimeout(context.Background(), 5*time.Second)\ndefer cancel()\np(ctx)")
	create(db, "Check if bytes are a valid UTF-8 string\n(tags: check byte valid utf8)\n---\n\nb := utf8.Valid(s)")
	create(db, "Encode bytes to base64\n(tags: encode byte base64)\n---\n\ns := base64.StdEncoding.EncodeToString(data)")
	create(db, "Decode base64\n(tags: decode string base64)\n---\n\ndata, err := base64.StdEncoding.DecodeString(s)")
	create(db, "Set value on field of structure in map\n(tags: set value field struct map)\n---\n\ntemp := m[key]\ntemp.SomeField = 42\nm[key] = temp")
	create(db, "Deploy on Heroku\n(tags: heroku deploy)\n---\n\nCheck this:\n1. On site heroku/<myappname>/recources web toggle button turn on\n2. In code http.ListenAndServe(\":\" + os.Getenv(\"PORT\"), nil)\n3. In root app's dir you have \"Procfile\" with \"web: bin/myapp\"\n4. File go.mod have \"// +heroku goVersion go1.15\" above the line \"go 1.15\"")
	create(db, "HTTP file server\n(tags: http file server)\n---\n\nhttp.Handle(\"/\", http.FileServer(http.Dir(\".\")))\nhttp.ListenAndServe(\":80\", nil)\n// log.Fatal(http.ListenAndServe(\":8080\", http.FileServer(http.Dir(\"/usr/share/doc\"))))")
	create(db, "Update major version of package in go.mod\n(tags: update major version package mod)\n---\n\n// go mod init myapp\n// go mod vendor\nadd version on import github.com/go-telegram-bot-api/telegram-bot-api/v5 \nor if you want to use the newest commit\ngo get github.com/go-telegram-bot-api/telegram-bot-api@b6df6c2\ngo mod tidy")
	create(db, "Using go mod vendor\n(tags: mod vendor)\n---\n\ngo mod init myapp\ngo mod vendor\ngo build -mod=vendor main.go")
	create(db, "Linux tcpdump\n(tags: linux tcpdump)\n---\n\n// output format\n[Timestamp] [Protocol] [Src IP].[Src Port] > [Dst IP].[Dst Port]: [Flags], [Seq], [Ack], [Win Size], [Options], [Data Length]\n// show available interfaces\ntcpdump -D\n// catch all packets\ntcpdump -i any\n// catch first 5 packets\ntcpdump -i any -c 5\n// do not resolve ip (-n) and ports (-nn)\ntcpdump -i any -c5 -nn\n// filter by icmp packets\ntcpdump -i any -c5 icmp\n// filter packets by a special host\ntcpdump -i any -c5 -nn host 54.204.39.132\n// filer packets by subnet\ntcpdump -n net 192.168.1\n// filter by port\ntcpdump -i any -c5 -nn port 80\n// filter by ports\ntcpdump -n portrange 11128-11142\n// filter by destination \ntcpdump -i any -c5 -nn dst 192.168.122.98\n// complexly\ntcpdump -i any -c5 -nn src 192.168.122.98 and port 80\ntcpdump -i any -c5 -nn \"port 80 and (src 192.168.122.98 or src 54.204.39.132)\"\n// print packet content in ascii (-A) or hex (-X)\ntcpdump -i any -c10 -nn -A port 80\n// save result in file\ntcpdump -i any -c10 -nn -w webserver.pcap port 80\n// read result from file (you may use wireshark)\ntcpdump -nn -r webserver.pcap\ntcpdump -nn -r webserver.pcap src 54.204.39.132")
	create(db, "Linux info\n(tags: linux info)\n---\n\nid      // info about your account\nw       // who there are in the system now\nlscpu   // info about processors\nlsof    // list of open files\nfree    // info about memory\ncat     // show content of the file\nless    // show file in fragments\nmore    // for big files\ntail -f // show end of file in interactive\ncmp     // compare files by bytes\ncomm    // show sort files string by string\ndiff    // show diff between files\ngrep    // find in text by regexp \nfind    // find files\nwc      // words count")
	create(db, "Linux bash hotkeys\n(tags: linux bash hotkeys)\n---\n\nalt+b  // move cursor to the start of word (back)\nalt+f  // move to the end of word (forward)\nctrl+a // move to the start\nctrl+e // move to the end\nctrl+]<char> // move right to first <char> entry\nctrl+alt+]<char> // move left to <char>\nctrl+w // remove word before the cursor\nalt+d  // remove word after\nctrl+u // remove all before cursor\nctrl+k // remove all after cursor\nctrl+y // return removed \n!! // repeat last command\n!$ // \"cat a.txt\" then \"less !$\" = \"less a.txt\"\n!* // \"head a.txt | grep '^Al'\" then \"tail !*\"\nalt+. // insert last arg from previous command\nalt+<N>+alt+. // insert <N> arg from previous command\n>a.txt // creat file or clean it\nctrl+l // clean terminal\nctrl+r // show history\nctrl+d // exit")
	create(db, "Linux std\n(tags: linux std in out err)\n---\n\n> send to stream\n< get from straem\n>> append to stream\n<< join stream\n// send stdout to out.txt, stderr to err.txt\n./myapp > out.txt 2> err.txt\n// send stdout and stderr in outerr.txt\n./myapp > outerr.txt 2>&1 ac -pd &> outerr.txt\n// skip stdout and stderr\n./myapp &> /dev/null\n// stdout as arg\ndiff <(ls dirA) <(ls dirB)\n// create files with names from list\nxargs touch < list.txt")
	create(db, "Linux find\n(tags: linux find)\n---\n\nfind /opt -name \"README*\" -exec wc -l {} +\n// criteria:\n-name,  -iname, -type (f, d, l), -inum <Н>, -not-name\n-user<uname>, -group<gname>,  -perm (ugo+/-rwx)\n-size +x[c], -empty, -newer <fname>\n-atime +x, -amin +x, -mmin -x, -mtime -x\n-and (-a), or (-o)\n-~ (hiden files), -perm (permissions)\n// actions:\n-print — default print\n-ls — exec ls -lids for every result file\n-exec cmd — exec command\n-ok cmd — exec command after user confirmation\n// examples:\nfind . -type f -iname \"*.txt\" — xt-files in curdir\nfind . -maxdepth 1 — equivalent ls\nfind ./somedir -type f -size +512M -print — all files large then 512M in ./somedir\nfind /usr/bin ! -type l — no symbol link in /usr/bin\nfind $HOME -type f -atime +365 -exec rm {} + — remove all files that have not been available for a year\nfind . \\( -name \"*.c\" -o -name \"*.h\" \\) — all files with .c or .h extention")
	create(db, "Linux grep\n(tags: linux grep)\n---\n\ngrep -i -n 'c.l' states.txt\n// print number of string whoes start with t\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | grep -n '^t'\n  2:two\n  3:three\n// options:\n-i: ignore case\n-n: print string number with strings\n-v: invert - print that not matched\n-c: print count of matched strings\n-A<n>: print <n> strings after\n-B<n>: print <n> strings before\n-o: print only matched, not whole string\n-E: allowed to use extention regexp\n-r: recurcive in dirs\n-w: find word\n-l: print with file names\n--color: colorise print")
	create(db, "Linux awk\n(tags: linux awk)\n---\n\n// $0 - all string, $1 - first word, $2 - second...\necho \"I'm Tom\" | awk '{$2=\"Bill\"; print $0}' \n  I'm Bill\nprintf \"12\\n32\\n54\\n6\" | awk '{if ($1>20) print $1}'\n  32\n  54 \n// use function  \nprintf \"first a\\nsecond b\\nthird c\" | awk '{print(toupper($1))}' >&1\n  FIRST\n  SECOND\n  THIRD\n// set other word delimeter\nprintf \"first:a\\nsecond:b\\nthird:c\" | awk 'BEGIN{FS=\":\"}{print(toupper($1))}' >&1\nprintf \"first:a\\nsecond:b\\nthird:c\" | awk -F: '{print(toupper($1))}' >&1\n  FIRST\n  SECOND\n  THIRD\n// print last field\nprintf \"a b c d e f\" | awk '{print(toupper($NF))}' >&1\n  f\n// set other string delimeter and use filter\nprintf \"1a 1b 2c 2d 3e 3f\" | awk 'BEGIN{RS=\" \"}{print(toupper($NF))}' | awk '/2/{print $0}'\n  2C\n  2D\n// use variables\necho -e 'one 1\\n two 2' | awk '{sum+=$2}END{print sum}'\n  3\n// sum of values in last column in file\n< requests.log awk '{totalBytes+=$NF}END{print totalBytes}'\n// substr function (printf(string), system(command), length(string))\nprintf \"1a 1b\" | awk 'BEGIN{RS=\" \"}{print(substr($1,2,1))}'\n  a\n  b")
	create(db, "Linux sed\n(tags: linux sed)\n---\n\n// print 2-4 strings from file, show only result (-n)\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | sed -n '2,4p'\n  two\n  three\n  four\n// print without 1-2 strings\nprintf \"one\\ntwo\\nthree\\nfour\\nfive\" | sed '1,2d'\n  three\n  four\n  five\n// replace words\nprintf \"one\\ntwo\\nthree\" | sed 's/tw/TW/g'\n  one\n  TWo\n  three\n// replace chars\nprintf \"one\\ntwo\\nthree\" | sed 'y/t/T/'\n  one\n  Two\n  Three\n// append string\n  printf \"one\\ntwo\" | sed 'a-----'\n  one\n  -----\n  two\n  -----")

	create(db, "Compile for android\n(tags: compile android)\n---\n\nenv GOOS=android GOARCH=arm64 go build main.go")
	create(db, "Cli tool\n(tags: cli tool)\n---\n\nimport \"github.com/urfave/cli/v2\"\n\nfunc main() {\n  var language string\n  app := &cli.App{\n    Flags: []cli.Flag {\n      &cli.StringFlag{\n        Name:        \"lang\",\n\t\tAliases:     []string{\"l\"},\n        Value:       \"english\",\n        Usage:       \"language for the greeting\",\n        Destination: &language,\n      },\n    },\n    Action: func(c *cli.Context) error {\n      name := \"someone\"\n      if c.NArg() > 0 {\n        name = c.Args().Get(0)\n      }\n      if language == \"spanish\" {\n        fmt.Println(\"Hola\", name)\n      } else {\n        fmt.Println(\"Hello\", name)\n      }\n      return nil\n    },\n  }\n  err := app.Run(os.Args)\n  if err != nil {\n    log.Fatal(err)\n  }\n}")
	create(db, "Linux tree\n(tags: linux tree)\n---\n\n// print only dir with low than 26 files\ntree -d --filelimit 26\n// print hiden dir, sort by depth, show modify date\ntree -avD\n// print files that matched template, do not show dir that gave not needed files\ntree -P '*.pdf' --prune\n// write three with dir into a file\ntree -d -o tree_command_results.txt\n// print size, user, permissions, full path\ntree -hupf")
	create(db, "Build go app in docker from scratch\n(tags: docker build scratch)\n---\n\nFROM golang AS builder\nADD . /app\nWORKDIR /app\nRUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags \"-static\"' -o kit\n\nFROM scratch\nCOPY --from=builder /app/kit /app/kit\nEXPOSE 8080 8080\nENTRYPOINT [\"/app/kit\"]")
	create(db, "Use prometheus and grafana\n(tags: docker prometheus grafana compose)\n---\n\n// Dockerfile\nFROM golang AS builder\nADD . /app\nWORKDIR /app\nRUN CGO_ENABLED=0 go build -mod=vendor -ldflags '-extldflags \"-static\"' -o kit\n\nFROM scratch\nCOPY --from=builder /app/kit /app/kit\nEXPOSE 8080 8080\nENTRYPOINT [\"/app/kit\"]\n\n// prometheus/prometheus.yml\nscrape_configs:\n  - job_name: my_group\n    scrape_interval: 10s\n    static_configs:\n      - targets:\n          - kit:8080\n\t\t  \n// docker-compose.yaml\nversion: \"3\"\n\nservices:\n  kit:\n    build:\n      context: .\n      dockerfile: Dockerfile\n    ports:\n      - 8080:8080\n\n  grafana:\n    image: grafana/grafana\n    container_name: grafana\n    ports:\n      - 3000:3000\n\n  prometheus:\n    image: prom/prometheus\n    container_name: prometheus\n#    restart: unless-stopped\n    ports:\n      - 9090:9090\n    volumes:\n      - ./prometheus/prometheus.yml:/etc/prometheus/prometheus.yml\n\n// docker-compose up")
	create(db, "Simple metrics for prometheus\n(tags: metrics prometheus)\n---\n\nimport (\n  \"github.com/prometheus/client_golang/prometheus\"\n  \"github.com/prometheus/client_golang/prometheus/promauto\"\n  \"github.com/prometheus/client_golang/prometheus/promhttp\"\n)\n\nfunc recordMetrics() {\n  go func() {\n    for {\n      opsProcessed.Inc()\n      time.Sleep(2 * time.Second)\n    }\n  }()\n}\n\nvar opsProcessed = promauto.NewCounter(prometheus.CounterOpts{\n    Name: \"myapp_processed_ops_total\",\n    Help: \"The total number of processed events\",\n  })\n\nfunc main() {\n  recordMetrics()\n  http.Handle(\"/metrics\", promhttp.Handler())\n  http.ListenAndServe(\":8080\", nil)\n}\n// curl http://localhost:8080/metrics")
	create(db, "Install golang on android\n(tags: install android)\n---\n\n1. Install Termux from Play Market\n2. pkg install golang \n3. cd ~\n4. mkdir gopath\n5. export GOPATH=$HOME/gopath\n6. pkg install git\n7. go get github.com/gorilla/mux")
	create(db, "Unsafe for loop\n(tags: unsafe for loop)\n---\n\narr := []uint32{1, 2, 3}\nconst size = unsafe.Sizeof(uint32(0)) //4\nfor i := 0; i < len(arr); i++ {\n  fmt.Printf(\"%d \",\n    *(*uint32)( // conver into (*uint32), then take value - *(*uint32)\n      unsafe.Pointer( // get address\n        // address 0-element + offset size (4)\n        uintptr(unsafe.Pointer(&arr[0])) + (uintptr(i) * size)))) // uintptr(i) for type assign\n}")
	create(db, "Unsafe string to bytes without copy\n(tags: unsafe string byte)\n---\n\nfunc string2bytes(s string) []byte {\n  stringHeader := (*reflect.StringHeader)(unsafe.Pointer(&s))\n  bh := reflect.SliceHeader{\n    Data: stringHeader.Data,\n    Len:  stringHeader.Len,\n    Cap:  stringHeader.Len,\n  }\n  return *(*[]byte)(unsafe.Pointer(&bh))\n}")
	create(db, "Unsafe bytes to string without copy\n(tags: unsafe string byte)\n---\n\nfunc bytes2string(b []byte) string {\n  sliceHeader := (*reflect.SliceHeader)(unsafe.Pointer(&b))\n  sh := reflect.StringHeader{\n    Data: sliceHeader.Data,\n    Len:  sliceHeader.Len,\n  }\n  return *(*string)(unsafe.Pointer(&sh))\n}")
	create(db, "Unsafe change struct fields\n(tags: unsafe struct field)\n---\n\ntype Programmer struct {\n  name     string\n  language string\n}\np := Programmer{\"Tom\", \"en\"}\nname := (*string)(unsafe.Pointer(&p))\n*name = \"Foma\"\nlang := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p)) + unsafe.Offsetof(p.language)))\n*lang = \"ru\"")
	create(db, "Unsafe change unexported struct fields from other package\n(tags: unsafe struct field unexported)\n---\n\np2 := a.Programmer2{}\n// cannot refer to unexported field or method name (p2.name = \"Foma\")\n// but we can see in source code what the fields there. First field is string\nname2 := (*string)(unsafe.Pointer(&p2))\n*name2 = \"Foma\"\n// second field is int. Doing the offset by string size\nage2 := (*int)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(\"\"))))\n*age2 = 25\n// third field is string\nlang2 := (*string)(unsafe.Pointer(uintptr(unsafe.Pointer(&p2)) + unsafe.Sizeof(string(\"\")) + unsafe.Sizeof(int(0))))\n*lang2 = \"ru\"")
	create(db, "Json marshal infinity float to null\n(tags: json marshal float nan infinity)\n---\n\ntype Measure struct {\n  Type  string   `json:\"type\"`\n  Power *float64 `json:\"power\"`\n}\n\nfunc main() {\n  val := math.Inf(1)\n  power := &val\n  if math.IsInf(val, 0) {\n  \tpower = nil\n  }\n  m := Measure{\n  \tType: \"simple\",\n  \tPower: power,\n  }\n  j, _ := json.Marshal(&m)\n  fmt.Println(string(j)) // {\"type\":\"simple\",\"power\":null}\n}")
	create(db, "Scan arguments in string by template\n(tags: scan arg string)\n---\n\nvar name string\nvar age int\nn, err := fmt.Sscanf(\"Joe is 22 years old\", \"%s is %d years old\", &name, &age)")
	create(db, "Printf formats\n(tags: printf print format)\n---\n\nvar i int\nvar f float32\nvar s string\nvar b bool\nvar c Car\n\nfmt.Printf(\"%v\\n\", i) //0\nfmt.Printf(\"%v\\n\", f) //0\nfmt.Printf(\"%v\\n\", s) //\nfmt.Printf(\"%v\\n\", b) //false\nfmt.Printf(\"%v\\n\", c) //{ 0}\n\nfmt.Printf(\"%+v\\n\", i) //0\nfmt.Printf(\"%+v\\n\", f) //0\nfmt.Printf(\"%+v\\n\", s) //\nfmt.Printf(\"%+v\\n\", b) //false\nfmt.Printf(\"%+v\\n\", c) //{Model: Speed:0}\n\nfmt.Printf(\"%#v\\n\", i) //0\nfmt.Printf(\"%#v\\n\", f) //0\nfmt.Printf(\"%#v\\n\", s) //\"\"\nfmt.Printf(\"%#v\\n\", b) //false\nfmt.Printf(\"%#v\\n\", c) //main.Car{Model:\"\", Speed:0}\n\nfmt.Printf(\"%T\\n\", i) //int\nfmt.Printf(\"%T\\n\", f) //float32\nfmt.Printf(\"%T\\n\", s) //string\nfmt.Printf(\"%T\\n\", b) //bool\nfmt.Printf(\"%T\\n\", c) //main.Car\n\nfmt.Printf(\"%%\\n\") //%\n\ni = 15\nf = 32.7\ns = \"Pri vet!\"\nb = true\nc = Car{\"Audi\", 200}\n\nfmt.Printf(\"%#v\\n\", i) //15\nfmt.Printf(\"%#v\\n\", f) //32.7\nfmt.Printf(\"%#v\\n\", s) //\"Pri vet!\"\nfmt.Printf(\"%#v\\n\", b) //true\nfmt.Printf(\"%#v\\n\", c) //main.Car{Model:\"Audi\", Speed:200}\n\nfmt.Printf(\"%b\\n\", i) //1111\nfmt.Printf(\"%c\\n\", i) //☼\nfmt.Printf(\"%d\\n\", i) //15\nfmt.Printf(\"%o\\n\", i) //17\nfmt.Printf(\"%O\\n\", i) //0o17\nfmt.Printf(\"%q\\n\", i) //'\\x0f'\nfmt.Printf(\"%x\\n\", i) //f\nfmt.Printf(\"%X\\n\", i) //F\nfmt.Printf(\"%U\\n\", i) //U+000F\n\nfmt.Printf(\"%b\\n\", f) //8572109p-18\nfmt.Printf(\"%e\\n\", f) //3.270000e+01\nfmt.Printf(\"%E\\n\", f) //3.270000E+01\nfmt.Printf(\"%f\\n\", f) //32.700001\nfmt.Printf(\"%F\\n\", f) //32.700001\nfmt.Printf(\"%g\\n\", f) //32.7\nfmt.Printf(\"%G\\n\", f) //32.7\nfmt.Printf(\"%x\\n\", f) //0x1.05999ap+05\nfmt.Printf(\"%X\\n\", f) //0X1.05999AP+05\nfmt.Printf(\"%9.2f\\n\", f) //\t32.70\n\nfmt.Printf(\"%s\\n\", s) //Pri vet!\nfmt.Printf(\"%q\\n\", s) //\"Pri vet!\"\nfmt.Printf(\"%q\\n\", \"abc\\tdef\\n\") //\"abc\\tdef\\n\"\nfmt.Printf(\"%x\\n\", s) //5072692076657421\nfmt.Printf(\"%X\\n\", s) //5072692076657421\nfmt.Printf(\"% X\\n\", s) //50 72 69 20 76 65 74 21\n\nfmt.Println(\"\\n=== Slice ===\")\n// pointer on 0-element\nfmt.Printf(\"%p\\n\", []int{1, 2, 3}) //0x11812274\n\nfmt.Println(\"\\n=== Sprintf ===\") //pointer\ns1 := fmt.Sprintf(\"%[3]*.[2]*[1]f\", 12.0, 2, 6)\ns2 := fmt.Sprintf(\"%6.2f\", 12.0)\nfmt.Println(s1, s2) // 12.00  12.00\ns3 := fmt.Sprintf(\"%d %d %#[1]x %#x\", 16, 17) \nfmt.Println(s3) //16 17 0x10 0x11\n\n// errors:\nWrong type or unknown verb: %!verb(type=value)\n\tPrintf(\"%d\", \"hi\"):        %!d(string=hi)\nToo many arguments: %!(EXTRA type=value)\n\tPrintf(\"hi\", \"guys\"):      hi%!(EXTRA string=guys)\nToo few arguments: %!verb(MISSING)\n\tPrintf(\"hi%d\"):            hi%!d(MISSING)\nNon-int for width or precision: %!(BADWIDTH) or %!(BADPREC)\n\tPrintf(\"%*s\", 4.5, \"hi\"):  %!(BADWIDTH)hi\n\tPrintf(\"%.*s\", 4.5, \"hi\"): %!(BADPREC)hi\nInvalid or invalid use of argument index: %!(BADINDEX)\n\tPrintf(\"%*[2]d\", 7):       %!d(BADINDEX)\n\tPrintf(\"%.[2]d\", 7):       %!d(BADINDEX)\nif a String method calls panic(\"bad\"), the resulting formatted message will look like\n\t%!s(PANIC=bad)")
	create(db, "Date to string\n(tags: date string)\n---\n\nfileName := fmt.Sprintf(\"data_%s.txt\", time.Now().Format(\"20060102_150405\"))")
	create(db, "Pattern chain of responsibility\n(tags: pattern chain responsibility)\n---\n\nПаттерн Chain Of Responsibility относится к поведенческим паттернам уровня объекта.\n\nПаттерн Chain Of Responsibility позволяет избежать привязки объекта-отправителя запроса к объекту-получателю запроса, при этом давая шанс обработать этот запрос нескольким объектам. Получатели связываются в цепочку, и запрос передается по цепочке, пока не будет обработан каким-то объектом.\n\nПо сути это цепочка обработчиков, которые по очереди получают запрос, а затем решают, обрабатывать его или нет. Если запрос не обработан, то он передается дальше по цепочке. Если же он обработан, то паттерн сам решает передавать его дальше или нет. Если запрос не обработан ни одним обработчиком, то он просто теряется.\n\nТребуется для реализации:\n\nБазовый абстрактный класс Handler, описывающий интерфейс обработчиков в цепочки;\nКласс ConcreteHandlerA, реализующий конкретный обработчик A;\nКласс ConcreteHandlerB, реализующий конкретный обработчик B;\nКласс ConcreteHandlerC, реализующий конкретный обработчик C;\nОбратите внимание, что вместо хранения ссылок на всех кандидатов-получателей запроса, каждый отправитель хранит единственную ссылку на начало цепочки, а каждый получатель имеет единственную ссылку на своего преемника - последующий элемент в цепочке.\npackage chain_of_responsibility\n\n// Handler provides a handler interface.\ntype Handler interface {\n\tSendRequest(message int) string\n}\n// ConcreteHandlerA implements handler \"A\".\ntype ConcreteHandlerA struct {\n\tnext Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerA) SendRequest(message int) (result string) {\n  if message == 1 {\n    result = \"Im handler 1\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n// ConcreteHandlerB implements handler \"B\".\ntype ConcreteHandlerB struct {\n  next Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerB) SendRequest(message int) (result string) {\n  if message == 2 {\n    result = \"Im handler 2\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n// ConcreteHandlerC implements handler \"C\".\ntype ConcreteHandlerC struct {\n  next Handler\n}\n// SendRequest implementation.\nfunc (h *ConcreteHandlerC) SendRequest(message int) (result string) {\n  if message == 3 {\n    result = \"Im handler 3\"\n  } else if h.next != nil {\n    result = h.next.SendRequest(message)\n  }\n  return\n}\n\nfunc TestChainOfResponsibility(t *testing.T) {\n  expect := \"Im handler 2\"\n  handlers := &ConcreteHandlerA{\n    next: &ConcreteHandlerB{\n      next: &ConcreteHandlerC{},\n    },\n  }\n  result := handlers.SendRequest(2)\n  if result != expect {\n    t.Errorf(\"Expect result to equal %s, but %s.\\n\", expect, result)\n  }\n}")

	//create(db, "")
	//create(db, "")
	//create(db, "")
	//create(db, "")
	//create(db, "")
	//create(db, "")

}
